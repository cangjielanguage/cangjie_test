# Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
# This source file is part of the Cangjie project, licensed under Apache-2.0
# with Runtime Library Exception.
#
# See https://cangjie-lang.cn/pages/LICENSE for license information.

from shared import *

template = '''
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Assertion:   4.15(62) Arithmetic operators introduced above are safe in the Cangjie programming language. That is,
                if an overflow (i.e., the value of an expression is beyond the range of its type) is detected at
                compile time, then a compilation error will be reported; otherwise an ArithmeticException is thrown
                at runtime.
  @Description: Checks for {ty} a, b that a {op} b causes an ArithmeticException ({} bound overflow).
  @Mode: run
  @Negative: no
  @Structure: single
  @CompileWarning: no
  @Comment: Auto-generated by gen_exception.py
*/

from utils import utils.assert.Assert

func f(a: {ty}, b: {ty}) {{
    a {op} b
}}

main() {{
    let a = {}
    let b = {}
    var caught : Bool = false
    try {{
        f(a, b)
    }} catch (e: ArithmeticException) {{
        caught = true
    }}
    Assert.isTrue(caught)
}}
'''
counter = 36

for ty in types:
  ti = type_info[ty]
  for op, oi in operator_info.items():
    for bound in range(2):
      if not ti['signed']:
        if op is '-' and bound: continue
        elif op is not '-' and not bound: continue
      content = template.format('upper' if bound else 'lower', ti[oi[bound][0]], ti[oi[bound][1]], ty=ty, op=op)
      counter += 1
      with open(path.format(str(counter).zfill(2)), 'w') as file:
        file.write(content)
       