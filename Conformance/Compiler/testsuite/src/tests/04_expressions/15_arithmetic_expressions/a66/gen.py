# Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
# This source file is part of the Cangjie project, licensed under Apache-2.0
# with Runtime Library Exception.
#
# See https://cangjie-lang.cn/pages/LICENSE for license information.

from os import path

types = ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64']
operator_info = {
  '+' : '-',
  '-' : '+',
  '*' : '/'
}
path = path.dirname(path.realpath(__file__)) + '/test_a66_{}.cj'
template = '''
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Assertion:   4.15(66)   If overflow occurs, throwing an exception
  @Description: Checks for {ty} a, b that a {op} b overflow causes an ArithmeticException if
                @OverflowThrowing is used.
  @Mode: run
  @Negative: no
  @Structure: single
  @CompileWarning: no
  @Comment: Auto-generated by gen.py
*/

from utils import utils.assert.Assert
from std import random.Random

@OverflowThrowing
func f(a: {ty}, b: {ty}) {{
    a {op} b
}}

main() {{
    let rnd = Random(123)
    var overflowCount : Int32 = 0

    do {{
        let a = rnd.next{ty}()
        var b = rnd.next{ty}()
        try {{
            f(a, b)
        }} catch (e: ArithmeticException) {{
            overflowCount++
            var overflowCondition : Bool = false
            try {{
                overflowCondition ||= a > {ty}.Max {inv_op} b
            }} catch (e: ArithmeticException) {{}}
            try {{
                overflowCondition ||= a < {ty}.Min {inv_op} b
            }} catch (e: ArithmeticException) {{}}
            Assert.isTrue(overflowCondition)
        }}
    }} while (overflowCount < 256)
}}
'''
counter = 0

for ty in types:
  for op, inv_op in operator_info.items():
    content = template.format(ty=ty, op=op, inv_op=inv_op)
    counter += 1
    with open(path.format(str(counter).zfill(2)), 'w') as file:
      file.write(content)
       