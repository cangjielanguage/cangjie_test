# Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
# This source file is part of the Cangjie project, licensed under Apache-2.0
# with Runtime Library Exception.
#
# See https://cangjie-lang.cn/pages/LICENSE for license information.


from os import path

integer_types = ['Int8', 'Int16', 'Int32', 'Int64', 'IntNative', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'UIntNative']
number_types = integer_types + ['Float16', 'Float32', 'Float64']
other_types = ['String', 'Rune', 'Bool', 'Unit', '(Int8, Int8)', 'Array<Int8>', 'C']
types = number_types + other_types
default_value_map = {'Bool' : 'true', 'Unit' : '()', 'Array<Int8>' : '[1]', 'Rune' : "'1'", 'String' : '"1"', '(Int8, Int8)' : '(1i8, 1i8)', 'C' : 'C(1)'}
ops = ['', '+', '-', '*', '/', '%', '&&', '||', '&', '|', '^', '<<', '>>']

def default_value(ty : str) -> str:
  if ty in integer_types: return '1'
  if 'Float' in ty: return '1.0'
  return default_value_map[ty]

valid_type_map = []
def valid_types(op: str) -> list:
  if op in ['%', '<<', '>>', '|', '&', '^']: return integer_types
  if op in ['&&', '||']: return ['Bool']
  if not op: return types
  return number_types

dir = path.dirname(path.realpath(__file__))
path = dir + '/test_' + path.basename(dir) + '_{}.cj'
template = '''
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Assertion:   4.23(29) 3. It is required that the a in a op= b must be assignable, e.g., a variable.
  @Description: %s
  @Mode: compileonly
  @Negative: yes
  @Structure: single
  @CompileWarning: ignore
  @Comment: Auto-generated by gen.py
*/
{}
main() {{
    var v : {t2} = {v2}
    {v1} {op}= v
    0
}}
'''
negative_template = template % 'Checks that the expression a {op}= b is invalid for type {t2} when a is a {}.'
power_template = template % 'Checks that the expression a **= b is invalid for types {t1} and {t2} when a is a {}.'
counter = 1
func_decl = '''
func f() : {t1} {{ {v1} }}
'''

def write_counted(contents : str):
  global counter
  with open(path.format(str(counter).zfill(3)), 'w') as file:
    file.write(contents)
    counter += 1

for a_ty in ['literal', 'function call', 'constant']:
  call = 'f' in a_ty
  const = 'co' in a_ty
  tests = [power_template.format(a_ty, func_decl.format(t1=t1, 
  v1=default_value(t1)) if call else 'let c : %s = %s' % (t1, default_value(t1)) if const else '',
    t1=t1, t2=t2, v1='f()' if call else 'c' if const else default_value(t1), v2=default_value(t2), op='**')
    for t1, t2 in [('Int64', 'UInt64'), ('Float64', 'Int64'), ('Float64', 'Float64')]]
  for test in tests:
    write_counted(test)
  tests = [negative_template.format(a_ty, func_decl.format(t1=t,
    v1=default_value(t)) if call else 'let c : %s = %s' % (t, default_value(t)) if const else '',
    t2=t, v1='f()' if call else 'c' if const else default_value(t), v2=default_value(t), op=op) for op in ops for t in valid_types(op)]
  for test in tests:
    write_counted(test)
