Cangjie Language Specification
Xinyu F eng Qiming Hou Xiao Xu Qihui Sun Jun Sun
Kunshan W ang Zirun Zhu Xiaoying Liu Y un Bai Gaogao Y an
Xiaosheng Dai Jun Liu Jianyun Zhu Chuanjiang Ma Xuezhi W ang
Hailong Y ang Changchun F an Sen W u Song Zhang Y ouzhi Gu
Dian Y ang Gang Liu Le T u Jialiang T an Jiazhen Xuan Yinfeng Lin
Yinsen Zhang Anqi Y u Jiameng Zhu Huafeng Zhang Ganbo Xiao
Filatov Alexandr Y anxuan Cui Victor Petukhov Belyaev Mikhail
Programming Language Lab, Huawei T echnologies Co., Ltd.Contents
1 Lexical Structure 1
1.1 Identifiers and Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Semicolons and Newline Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.3 Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3.1 Integer Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.2 Floating Point Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3.3 Character Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.3.4 Character Byte Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.5 Boolean Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.6 String Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.3.7 Byte Array Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.4 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.5 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2 Types 13
2.1 Value Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.1.1 Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.1.2 Rune Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.1.3 Bool Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.1.4 Unit Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.1.5 Nothing Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.1.6 String Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.1.7 Tuple Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.1.8 Range Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.1.9 Function Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.1.10 struct Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.1.11 enum Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.1.12 VArray Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.2 Reference Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.2.1 Array Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.2.2 class Types and interface Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.3 Type Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.3.1 Type Conversion Between Value Types . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.3.2 Type Conversion Between Class/Interface . . . . . . . . . . . . . . . . . . . . . . . . . 46
2.4 Type Alias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
2.4.1 Rules on type alias definition : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.4.2 Usage of type alias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.5 Relations between Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.5.1 Type Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.5.2 Subtyping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.5.3 Smallest Common Supertypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.5.4 Greatest Common Subtypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
3 Names, Scopes, Variables and Modifiers 51
3.1 Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.2 Scopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.2.1 Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.2.2 Scope level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.2.3 Scope principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3.2.4 Shadowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3.3 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3.3.1 Definition of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3.3.2 Initialization of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
3.4 Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
3.4.1 Access modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
3.4.2 Non-access modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4 Expressions 63
4.1 Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.2 Variable Names and Function Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
4.3 Conditional Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.4 Pattern Matching Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
4.4.1 Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.4.2 Classification of Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.4.3 Pattern Guards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.5 Loop Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.5.1 The for-in Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.5.2 The while Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
4.5.3 The do-while Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
4.5.4 Summary of Loop Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
4.6 The try Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.7 Control Transfer Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
4.7.1 The break Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.7.2 The continue Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
4.7.3 The return expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.7.4 The throw expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.8 Numeric Type Conversion Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.9 The this and super Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.10 spawn Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.11 synchronized Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
4.12 Parenthesized Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.13 Postfix Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.13.1 Member Access Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.13.2 Function Invocation Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.13.3 Index Access Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.13.4 The Question Mark Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
4.14 Increment and Decrement Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
4.15 Arithmetic Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.16 Relational Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.17 Type Check and Type Cast Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.17.1 The is Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.17.2 The as Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
4.18 Bitwise Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
4.19 Range Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
4.20 Logical Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
4.21 Coalescing Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
4.22 Flow Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.22.1 The pipeline operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.22.2 The composition operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.23 Assignment Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.24 Lambda Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.25 Quote Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.26 Macro Call Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.27 Pass-by-reference Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.28 Precedence and Associativity of Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
5 Function 107
5.1 Function Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
5.1.1 Function Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
5.1.2 Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
5.1.3 Function Body . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.1.4 Return Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.1.5 Function Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.1.6 Function Redefinitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.2 Function Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.3 Function Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
5.3.1 Named arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.3.2 Type Checking of Function Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.3.3 Trailing Lambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
5.3.4 Variable-Length Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.4 Function Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
5.5 Lambda Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
5.6 Closures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
5.7 Function Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
5.7.1 Function Overloading Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
5.8 Mut functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
5.8.1 Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
5.8.2 The mut function in the interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
5.8.3 Access Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6 Class and Interface 131
6.1 Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.1.1 Class Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.1.2 Class Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.1.3 The Class Object. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
6.1.4 This Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
6.1.5 Generic Class: Box . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
6.2 Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
6.2.1 Interface Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
6.2.2 Interface Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
6.2.3 Interface Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.2.4 Implementation of Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
6.2.5 Any Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
6.3 Overridding, Overloading, Shadowing, Redefinition . . . . . . . . . . . . . . . . . . . . . . . . 160
6.3.1 Overridding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
6.3.2 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
6.3.3 Shadowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
6.3.4 Redefinition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
6.3.5 Access Control Restriction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6.4 Limitations on the Use of Generics in Classes Interfaces . . . . . . . . . . . . . . . . . . . . . 164
6.4.1 Duplicated Function type signature caused by generic instantiation . . . . . . . . . . . 164
6.4.2 Generic Member Function in Class and Interface . . . . . . . . . . . . . . . . . . . . . 165
7 Property 167
7.1 Syntax of Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
7.2 Definition of Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.3 Implementation of Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7.4 Modifiers for Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
8 Extension 175
8.1 Extension Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8.1.1 Direct Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.1.2 Interface Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
8.2 Members of Extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
8.2.1 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
8.2.2 Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
8.3 Extensions for generic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
8.4 The Accessing and Shadowing of Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
8.5 Inheritance of Extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
8.6 Import and Export of Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.6.1 Export of Direct Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.6.2 Export of Interface Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.6.3 Import of Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
9 Generics 191
9.1 Type Parameters and Type Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.2 Generic Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.3 Type Variance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.3.1 Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.3.2 Generic is Invariant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.3.3 Type Variance in Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
9.3.4 Type Variance in Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
9.3.5 Derived constraints of upper bounds of a generic constraint . . . . . . . . . . . . . . . 193
9.4 Generic Functions and Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
9.4.1 Generic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
9.4.2 Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
9.5 Type Checking for Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
9.5.1 Type Checking for Generic Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . 194
9.5.2 Type Checking for the Usages of Generic Declarations . . . . . . . . . . . . . . . . . . 195
9.5.3 Depths of Generic Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
9.6 Generic Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
9.6.1 Generic function instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
9.6.2 Generic class and interface instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . 197
9.6.3 struct instantiation: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
9.6.4 Enum instantiation: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
9.7 Generic Function Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
10 Overloading 201
10.1 Function Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
10.1.1 Definition of Function Overload . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
10.1.2 Candidate Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
10.1.3 Function overloading Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
10.2 Operator Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
10.2.1 Define Operator Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
10.2.2 The Scope of Operator Functions and the Search Strategy when Operators are Used .209
10.2.3 Operators that can be Overloaded . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
10.2.4 Index Operator Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
11 Packages and Module Management 213
11.1 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
11.1.1 Package Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
11.1.2 Package Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
11.1.3 Import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
11.1.4 Mapping between Package Names and the File System . . . . . . . . . . . . . . . . . . 223
11.1.5 Package in the root directory of source files . . . . . . . . . . . . . . . . . . . . . . . . 224
11.2 External and Internal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
12 Exceptions 227
12.1 Try Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
12.1.1 Ordinary Try Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
12.1.2 The Try-With-Resources Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
12.2 Throw Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
13 Multi-language Interoperability 237
13.1 C Interoperability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
13.1.1 unsafe context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
13.1.2 Calling functions in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
13.1.3 Type mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
13.1.4 CType Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
13.2 JavaScript Interoperability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
13.2.1 Type Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
13.2.2 Calling JavaScript from Cangjie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
13.2.3 Calling Cangjie from JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
13.3 Java Interoperability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
13.3.1 Interoperation Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
13.3.2 Type Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
13.3.3 Java modifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
13.3.4 Nullable Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
13.3.5 Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
13.3.6 Generic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
14 Metaprogramming 267
14.1 quote expression and Tokens type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
14.1.1 Code interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
14.1.2 Rules for Evaluating the Quote Expression . . . . . . . . . . . . . . . . . . . . . . . . 269
14.2 Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
14.2.1 Macro Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
14.2.2 Macro Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
14.2.3 Macro Scope and Import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
14.2.4 Nested macros and Recursive macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
14.2.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
15 Concurrency 279
15.1 thread . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
15.1.1 Future<T> Generic Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
15.1.2 threadsleep. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
15.1.3 threadterminate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
15.2 thread context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
15.2.1 Thread-local variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
15.3 Synchronization mechanism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
15.3.1 Atomic operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
15.3.2 IllegalSynchronizationStateException . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
15.3.3 IReentrantMutex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
15.3.4 ReentrantMutex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
15.3.5 synchronized . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
15.3.6 Monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
15.3.7 MultiConditionMonitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
15.4 Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
15.4.1 Data Race . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
15.4.2 Happens-Before . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
16 Automatic Differentiation 295
16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
16.2 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
16.3 Differentiable Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
16.3.1 Differentiable Numerical types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
16.3.2 Differentiable Tuple Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
16.3.3 Differentiable struct Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
16.3.4 Differentiable Unit Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
16.4 Un-Differentiable Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
16.5 Differentiable Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
16.5.1 Custom Differentiation Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
16.5.2 Non Top-level Differentiable Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
16.6 Differentiation Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
16.6.1 @Gradexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
16.6.2 @ValWithGrad expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
16.6.3 @VJPexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
16.6.4 stopGradient API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
16.7 Export/Import of Adjointfunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
16.8 Except-Validity Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
16.9 Example Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
A Cangjie Grammar Summary 319
A.1 Lexical Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
A.1.1 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
A.1.2 Whitespace and Newline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
A.1.3 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
A.1.4 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
A.1.5 Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
A.1.6 Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
A.2 Syntactic Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
A.2.1 Translation Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
A.2.2 Package Definition and Package Import . . . . . . . . . . . . . . . . . . . . . . . . . . 326
A.2.3 Top-Level Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
A.2.4 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
A.2.5 Expressions Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337Chapter 1
Lexical Structure
This chapter describes the lexical structure of the Cangjie programming language. See Appendix A for a
complete lexical grammar and syntactic grammar.
Note: to increase the readability of the document, the syntax definitions in the text will be slightly
different from those in the appendix, i.e., symbols and keywords are replaced in the main text with their
literal representations (rather than their names in the lexical grammar).
1.1 Identifiers and Keywords
Identifiers can be used as names of variables, functions, types, packages,modules, etc. There are two kinds
of of identifiers: ordinary identifiers and raw identifiers. An ordinary identifier is a string (not including
keywords) that beginning with a letter and followed by any length of letters, digits or underscores. The
letters include uppercase and lowercase ASCII Latin letters A-Zand a-z, and the digits include the ASCII
digits 0-9, and the underscore is the ASCII underscore _. A raw identifier is got by adding a pair of
backquotes (i.e., “ `..`”) outside of ordinary identifiers or keywords. The syntax of Identifier is defined as:
identifier
: Identifier
| PUBLIC
| PRIVATE
| PROTECTED
| OVERRIDE
| ABSTRACT
| SEALED
| OPEN
| REDEF
| GET
| SET
;
Identifier
: '_'* Letter (Letter | '_' | DecimalDigit)*
| '`' '_'* Letter (Letter | '_' | DecimalDigit)* '`'
;
Letter
: [a-zA-Z]
;
DecimalDigit
: [0-9]
;
Keywords are special strings that cannot be used as (ordinary) identifiers. All keywords in the Cangjie
Programing Language are shown in the following table.
Keyword
as break Bool
case catch class
continue Rune do
else enum extend
false finally for
foreign from func
Float16 Float32 Float64
if import in
init interface is
Int8 Int16 Int32
Int64 IntNative let
macro match mut
main Nothing operator
package prop quote
return spawn struct
static super synchronized
this throw true
try type This
unsafe UInt8 UInt16
UInt32 UInt64 UIntNative
Unit var where
while inout
Contextual Keywords are special strings that can be used as identifiers; they exist as keywords in
some syntaxes, but can also be used as normal identifiers.
Contextual Keyword
abstract open override
private protected public
redef get set
sealed
1.2 Semicolons and Newline Characters
There are two symbols that can indicate the end of an expression or declaration: a semicolon ( ;) or a newline
character. Among them, the meaning of ;is fixed and indicates the end of an expression or declaration
regardless of where it appears, and multiple expressions or declarations separated by ;can be written on the
same line. However, the meaning of newline character is not fixed, depending on its position, it can either
be used as a separator of two tokens like the space character, or as an ending character of an expression or
declaration like ;.
A newline character may appear between any two tokens. Except the following scenarios where the use of
a newline character as a separator between two tokens is prohibited, string literals and multi-line comments,
in other scenarios, the principle of “maximal matching” (i.e., taking as many tokens as possible to form a
valid expression or declaration) will be used for determining whether the newline character is processed as a
separator of two tokens or as the terminator of the expression or declaration. Newline characters encountered
before the end of the “maximal matching” are treated as separators between tokens and the newline character
at the end is treated as the terminator of the expression or declaration. The following examples show the
usage of the semicolon and newline character.
let width1 :Int32 =32// The newline character is treated as a terminator.
let length1 :Int32 =1024 // The newline character is treated as a terminator.
let width2 :Int32 =32;let length2 :Int32 =1024 // The newline character is treated as a
terminator. ↪
var x=100 +// The newline character is treated as a connector.
200 *300 -// The newline character is treated as a connector.
50// The newline character is treated as a terminator.
Scenarios where the use of a newline character as a separator between two tokens is prohibited are listed
as follows:
•A newline character cannot be used as a separator between a unary operator and its operand.
•In the call expression, a newline character cannot be used as a separator between (and the token
before it.
•In the index access expression, a newline character cannot be used as a separator between [and the
tokenpreceding it.
•Inconstant pattern , a newline character cannot be used as a separator between $and the identifier
following it.
•Note: The above scenarios only prohibit the use of a newline character as a separator between two
tokens,itdoesnotmeanthatnewlinecharacterscannotbeusedinthesescenarios(ifanewlinecharacter
is used, it is directly treated as the end of an expression or declaration).
For String literals and multi-line comments, the principle of “maximal matching” is also not applicable.
•For single line string literal, the string literal is terminated by the first non-escape double quotation
(");
•For multi-line string literal, the string literal is terminated by the first non-escape three double quota-
tions ( """);
•For multi-line raw string literal, the raw string literal is termintaed by the first non-escapte double
quotation and the same number of number signs( #) as the beginning.
•For multi-line comment, the comment is terminated by the first */.
1.3 Literals
A literal is an expression that represents a value that cannot be modified.
Literals also have types. The types that have literals in Cangjie include: integer types, floating point
types, character type, boolean type and string type. The syntax of literal is defined as follows.
literalConstant
: IntegerLiteral
| FloatLiteral
| CharacterLiteral
| booleanLiteral
| stringLiteral
;
stringLiteral
: lineStringLiteral
| multiLineStringLiteral
| MultiLineRawStringLiteral
;
1.3.1 Integer Literals
Integer literals can be written in four bases: binary, octal, decimal, and hexadecimal. Binary literals must
start with 0b(or0B), octal literals must start with 0o(or0O), and hexadecimal literals must start with 0x(or
0X). Decimal literals do not require a prefix. Meanwhile, a suﬀix can be added to denote the exact type of
an integral literal.
The syntax of integer literals is:
IntegerLiteralSuffix
: 'i8' |'i16' |'i32' |'i64' |'u8' |'u16' |'u32' | 'u64'
;
IntegerLiteral
: BinaryLiteral IntegerLiteralSuffix?
| OctalLiteral IntegerLiteralSuffix?
| DecimalLiteral '_'* IntegerLiteralSuffix?
| HexadecimalLiteral IntegerLiteralSuffix?
;
BinaryLiteral
: '0' [bB] BinDigit (BinDigit | '_')*
;
BinDigit
: [01]
;
OctalLiteral
: '0' [oO] OctalDigit (OctalDigit | '_')*
;
OctalDigit
: [0-7]
;
DecimalLiteral
: ([1-9] (DecimalDigit | '_')*) | DecimalDigit
;
DecimalDigit
: [0-9]
;
HexadecimalLiteral
: '0' [xX] HexadecimalDigits
;
HexadecimalDigits
: HexadecimalDigit (HexadecimalDigit | '_')*
;
HexadecimalDigit
: [0-9a-fA-F]
;
The suﬀixes in IntegerLiteralSuffix and their corresponding types are showed in the following table:
Suﬀix Type Suﬀix Type
i8 Int8 u8 UInt8
i16 Int16 u16 UInt16
i32 Int32 u32 UInt32
i64 Int64 u64 UInt64
1.3.2 Floating Point Literals
Floating-point literals can be written in 2 bases: decimal (without prefix) and hexadecimal (prefixed
with 0xor0X). In the decimal representation, a floating-point number must contain an integer part or a
fractional part. An exponential part (prefixed with eorE) is required when there is no decimal part. In the
hexadecimal representation, a floating point number must contain at least one integer part or fractional part
and must contain an exponential part (prefixed with porP). Meanwhile, a suﬀix can be added to denote the
exact type of the floating point number.
The syntax of floating point literals is:
FloatLiteralSuffix
: 'f16' | 'f32' | 'f64'
;
FloatLiteral
: (DecimalLiteral DecimalExponent | DecimalFraction DecimalExponent? | (DecimalLiteral
DecimalFraction) DecimalExponent?) FloatLiteralSuffix? ↪
| (Hexadecimalprefix (HexadecimalDigits | HexadecimalFraction | (HexadecimalDigits
HexadecimalFraction)) HexadecimalExponent) ↪
DecimalFraction
: '.' DecimalFragment
;
DecimalFragment
: DecimalDigit (DecimalDigit | '_')*
;
DecimalExponent
: FloatE Sign? DecimalFragment
;
HexadecimalFraction
: '.' HexadecimalDigits
;
HexadecimalExponent
: FloatP Sign? DecimalFragment
;
FloatE
: [eE]
;
FloatP
: [pP]
;
Sign
: [-]
;
Hexadecimalprefix
: '0' [xX]
;
The suﬀixes in FloatLiteralSuffix and their corresponding types are showed in the following table:
Suﬀix Type
f16 Float16
f32 Float32
f64 Float64
1.3.3 Character Literals
A character literal consisting of a pair of single quotes and the character itself. The syntax is:
CharacterLiteral
: '\'' (SingleChar | EscapeSeq ) '\''
;
SingleChar
: ~['\\\r\n]
;
EscapeSeq
: UniCharacterLiteral
| EscapedIdentifier
;
UniCharacterLiteral
: '\\' 'u' '{' HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit '}' ↪
;
EscapedIdentifier
: '\\' ('t' | 'b' | 'r' | 'n' | '\'' | '"' | '\\' | 'f' | 'v' | '0' | '$')
;
1.3.4 Character Byte Literals
Cangjie programming language introduced character byte literal to denote the value of type UInt8conve-
niently. It consists of a leading character b, a pair of single quotes and an ASCII character. The syntax
is:
CharacterByteLiteral
:'b' '\'' (SingleCharByte |ByteEscapeSeq )'\''
;
ByteEscapeSeq
:HexCharByte
|ByteEscapedIdentifier
;
fragment SingleCharByte
// ASCII 0x00~0x7F without \n \r \' \" \\
// +-------+-----+-----+
// | Rune | Hex | Dec |
// +-------+-----+-----+
// | \n | 0A | 10 |
// | \r | 0D | 13 |
// | \" | 22 | 34 |
// | \' | 27 | 39 |
// | \\ | 5C | 92 |
// +-------+-----+-----+
:[\u0000-\u0009\u000B\u000C\u000E-\u0021\u0023-\u0026\u0028-\u005B\u005D-\u007F]
;
fragment ByteEscapedIdentifier
:'\\' ('t' |'b' |'r' |'n' |'\'' |'"' |'\\' |'f' |'v' |'0')
;
fragment HexCharByte
:'\\' 'u' '{' HexadecimalDigit '}'
|'\\' 'u' '{' HexadecimalDigit HexadecimalDigit '}'
;
•b'x'denotes decimal number 120 with type UInt8.
•b'\u{78}' denotes integer literal 0x78 in hexadecimal or 120 in decimal.
1.3.5 Boolean Literals
There are only two Boolean literals: trueand false.
booleanLiteral
: 'true'
| 'false'
;
1.3.6 String Literals
String Literals The Stringliterals in the Cangjie programming language can be divided into three categories:
single-line string literals, multi-line string literals and multi-line raw string literals.
A single-line string literal consists of zero or more characters (except non-escape character "and
alone character \) enclosed by a pair of double quote character (i.e., "). Furthermore, a single-line string
literal can only be written on the same line.
The syntax of the single-line string literal is:
lineStringLiteral
: '"' (lineStringExpression | lineStringContent)* '"'
;
lineStringExpression
: '${' SEMI* (expressionOrDeclaration (SEMI+ expressionOrDeclaration?)*) SEMI* '}'
;
lineStringContent
: LineStrText
;
LineStrText
: ~["\\\r\n]
| EscapeSeq
;
A multi-line string literal consists of zero or more valid characters (except alone character \and
non-escape characters """) enclosed by a pair of three double quote characters ( """), which begins after the
line terminator of begining double quotations and ends before the first matched non-escape ending double
quotations. There must be a line terminator after the begining double quotations, otherwise a compiler error
is reported. If non-escape three double quotations is not matched before the end of current file, a compiler
error is reported. Different from single-line string literals, a multi-line string literal can span multiple lines.
The syntax of the multi-line string literal is:
multiLineStringLiteral
: '"""' NL (multiLineStringExpression | multiLineStringContent)* '"""'
;
multiLineStringExpression
: '${' anysemi* (expressionOrDeclaration (anysemi+ expressionOrDeclaration?)*) anysemi* '}'
;
multiLineStringContent
: MultiLineStrText
;
MultiLineStrText
: ~('\\')
| EscapeSeq
;
A multi-line raw string literal starts with one or more number signs ( #) and a double quotation ( "),
followed by any valid characters (except one double quotation and the same number of number of number
singes as the begining), and is terminated only by first matched double quotation ( ") and the same number
of number signs ( #) as the beginning. If another double quotation ( ") and the same number of number signs
(#) as the beginning is not matched before the end of current file, a compiler error is reported. Different
from the multi-line string literals, escaping rules do not apply in a multi-line raw string.
The syntax of the multi-line raw string literal is:
MultiLineRawStringLiteral
: MultiLineRawStringContent
;
fragment MultiLineRawStringContent
: '#' MultiLineRawStringContent '#'
| '#' '"' .*? '"' '#'
;
1.3.7 Byte Array Literals
A byte array literal can be used to denote the values of ‘Array conveniently. It consists of a leading character
b, a pair of double quotes and a quoted sequence of ASCII chatacters.
fragment CharInByteStringArray
// ASCII 0x00~0x7F without \n \r \" \\
:[\u0000-\u0009\u000B\u000C\u000E-\u0021\u0023-\u005B\u005D-\u007F]
;
ByteStringArrayLiteral
:'b' '"' (CharInByteStringArray |ByteEscapeSeq )*'"'
;
For example, b"hello" is a value of type Array<UInt8> with length 5, each of the values in it corresponds
to the numeric value of the ASCII character.
1.4 Operators
The following table lists all the operators supported by Cangjie (the closer an operator is to the top of
the table, the higher precedence it has). Refer to Chapter 4 Expressions for a detailed description of each
operator.
Operator Description
@ Macro call expression
. Member access
[] Index access
() Function call
++ Postfix increment
-- Postfix decrement
? Question mark
! Logic NOT
- Unary negative
** Power
* Multiply
/ Divide
Operator Description
% Remainder
+ Add
- Subtract
<< Bitwise left shift
>> Bitwise right shift
< Less than
<= Less than or equal
> Greater than
>= Greater than or equal
is Type test
as Type cast
== Equal
!= Not equal
& Bitwise AND
^ Bitwise XOR
| Bitwise OR
.. Range operator
..=
&& Logic AND
|| Logic OR
?? coalescing
|> Pipeline
~> Composition
= Assignment
**= Compound assignment
*=
/=
%=
+=
-=
<<=
>>=
&=
^=
|=
&&=
||=
1.5 Comments
Multiple ways of writing comments are supported:
Single-line comments begin with //, whose syntax is:
LineComment
: '//' ~[\n\r]*
;
Multi-line comments put the comment between /*and */(nested multi-line comments are supported),
whose syntax is:
DelimitedComment
: '/*' ( DelimitedComment | . )*? '*/'
;Chapter 2
Types
The Cangjie Programming Language is a statically typed language, i.e. type checking for ensuring safety is
mostly performed at compile time. At the same time, it is a strongly typed language, i.e. every expression
is associated with a type and the type of expression not only decides its possible values, but also decides
that can be performed on them. Static typing and strong typing facilitate programmers to discover program
errors at compile time.
There are two categories of types at the top: value types and reference types. The value types include
numeric types (include integer types and floating-point types, see Numeric Types ),Chartype, Booltype,
Unittype, Nothingtype, Stringtype, Tupletype, Rangetype, Function type, structtype, enumtype and
VArraytype. The reference types include classtype and interface type.
The difference between a value type and a reference type is that the content of a value-type variable is
the value of the variable, whereas the content of a reference type variable is a reference which refers to a
value. Thus, when a variable is used in assignments and passed as a function parameter in a function call,
its value is copied if it is of a value type and its reference is copied if it is of a reference type.
In the following, we introduce each type, values of the type and the supported operations on the type.
2.1 V alue Types
The following introduces all value types of the Cangjie programming language.
2.1.1 Numeric Types
The numeric types are classified into integer types and floating-point types, which are used to represent
integers and floating-point numbers, respectively. The integer types can be further divided into signed
and unsigned integer types. Signed integer types include Int8,Int16,Int32,Int64and IntNative , which
are used to represent types of signed integer values whose lengths are 8-bit,16-bit,32-bit,64-bitand
platform dependent size, respectively. Unsigned integer types include UInt8,UInt16,UInt32,UInt64and
UIntNative , which are types of unsigned integer values encoded with 8-bit,16-bit,32-bit,64-bitand
platform dependent size, respectively. Floating-point types include Float16,Float32, and Float64, which are
types for floating-point numbers with encoding lengths of 16-bit,32-bit, and 64-bit, respectively.
The following table lists all the numeric types and their ranges.
Type Range
Int8 −27∼ 27− 1(-128 to 127)
Int16 −215∼ 215− 1(-32768 to 32767)
Int32 −231∼ 231− 1(-2147483648 to 2147483647)
Int64 −263∼ 263− 1(-9223372036854775808 to 9223372036854775807)
IntNative platform dependent
UInt8 0 ∼ 28− 1(0 to 255)
Type Range
UInt16 0 ∼ 216− 1(0 to 65535)
UInt32 0 ∼ 232− 1(0 to 4294967295)
UInt64 0 ∼ 264− 1(0 to 18446744073709551615)
UIntNative platform dependent
Float16 See IEEE 754 binary16 format
Float32 See IEEE 754 binary32 format
Float64 See IEEE 754 binary64 format
For ease of use, the Cangjie programming language provides a Bytetype as a type alias of UInt8, and
Byteis completely equivalent to UInt8. (For details about type aliases, see the Type Alias section below.)
let a:UInt8 =128
let b:Byte =a// ok
In the following, we introduce the literals of numeric types and the operations which are supported.
2.1.1.1 Numeric Literals
Terms such as 5,24,2.9, and 3.14are referred to as numeric literals. Literals can be referred to only by
their values and their values cannot be changed.
In the following, we introduce the integer literals as well as the floating point literals.
Integer literals can be written in four bases: binary, octal, decimal, and hexadecimal. Binary literals
must start with 0b(or0B), octal literals must start with 0o(or0O), and hexadecimal literals must start with
0x(or0X). Decimal literals do not require a prefix. For example, the decimal value 24may be written in any
one of the following four forms, in which the underline _acts as a separator for readability:
0b0001_1000 // Binary.
0o30 // Octal.
24 // Decimal.
0x18 // Hexadecimal.
See section Integer Literals for the syntax of integer literals.
Floating-pointtypes intheCangjieprogramminglanguagearerepresentedusingtheIEEE754formats.
In particular, Float16corresponds to the half-precision format (16-bit) in IEEE 754; Float32corresponds to
the single-precision format (32-bit) in IEEE 754, and Float64corresponds to the double-precision format(64-
bit) in IEEE 754. A floating-point literal usually contains an integer part, a fractional part (including a
decimal point), and an exponential part. There are two forms of representation: decimal or hexadecimal.
In the decimal representation, a floating-point number must contain an integer part or a fractional part.
An exponential part (prefixed with e or E, and base 10) is required when there is no decimal part. In the
hexadecimal representation, a floating point number must contain at least one integer part or fractional part
(prefixed with 0x) and must contain an exponential part (prefixed with p or P, and base 2). In addition, the
following are additional special floating-point literals: positive infinity ( POSITIVE_INFINITY ), negative infinity
(NEGATIVE_INFINITY ), Not a Number ( NaN), positive 0 ( +0.0) and negative 0 (- 0.0).infinity represents the
result of an operation beyond the range of the floating-point type. For example, if two large floating-point
numbers are multiplied or a non-zero number is divided by 0, the result is infinity . Note that the sign
of the infinity is determined by the signs of the operands. NaNrepresents a value that is neither a real
value nor infinity. For example, the result of POSITIVE_INFINITY * 0 isNaN. The following are examples of
floating-point literals.
3.14 // decimal Float64 3.14.
2.4e-1 // decimal Float64 0.24.
2e3 // decimal Float64 2000.0.
.8 // decimal Float64 0.8.
.123e2 // decimal Float64 12.3.
0x1.1p0 // hexadecimal Float64 1.0625 (decimal value).
0x1p2 // hexadecimal Float64 4 (decimal value).
0x.2p4 // hexadecimal Float64 2 (decimal value).
See section Floating Point Literals for the syntax of floating-point literals.
Floating point number in Cangjie programming language take the subnormal floating point number as
positive minimal number.
For Float32, the smallest representational positive number is 2−149, approximately 1.4e-45. The largest
representational positive number is (2 − 2−23) × 2127, approximately 3.40282e38 .
ForFloat64, the smallest representational positive number is 2−1074, approximately 4.9e-324 . The largest
representational positive (2 − 2−52) × 21023, approximately 1.79769e308 .
When a non-zero floating point literal rounds to 0or infinity, then compiler will emit an error.
2.1.1.2 Operators Supported by Number Types
Operators supported by numeric types include: arithmetic operators, bitwise operators, relational operators,
increment/decrement operators, unary negative operators, and (compound) assignment operators. All the
preceding operators are defined for integer types. All but bitwise operators are defined for floating-point
types. In the following, we focus on introducing how these operators are defined for integer types, with
understanding that the same applies to floating-point types.
Arithmetic operators include addition ( +), subtraction ( -), multiplication ( *), division ( /), reminder
(%), and power ( **). If arithmetic operators are not overload (see section operator overloading ), the operands
of them must have the same type. Explicit type conversion must be performed first to perform operations
on operands with different types. The following shows examples of arithmetic operations. The readers are
referred to section Arithmetic Expressions for the precedence and associativity of the arithmetic operators.
2+3 // add result: 5
3-1 // sub result: 2
3*9 // mul result: 27
24/8 // div result: 3
7%3 // mod result: 1
2**3 // power result: 8
5+15-2*10/4 // result: 15
5+10-3*4**2/3%5// result: 14
Bitwise operators include bitwise not ( !), bitwise left shift ( <<), bitwise right shift ( >>), bitwise and
(&), bitwise xor ( ^), and bit or ( |). For details about precedence, see the description of bitwise expressions
in Chapter 4. The following are simple examples of bit operations on integers.
!10 // bitwise logical NOT operator: -11
10<<1 // left shift operator: 10*2=20
10>>1 // right shift operator: 10/2=5
10&15 // bitwise logical AND operator: 10
10^15 // bitwise XOR operator: 5
10|15 // bitwise logical OR operator: 15
0b1010 &0b1110 ^0b1111 |0b0101 // result: 0b0101
Relational operators include less then ( <), greater than ( >), less than or equal to ( <=), greater than or
equal to ( >=), equal to ( ==), and not equal to ( !=). Their results are Boolean values (i.e. true or false). For
details about relational operations, see the description of relational operators in Chapter 4. The following
are examples relational operations on integers.
2==3 // result: false
2!=3 // result: true
8<10 // result: true
9<=9 // result: true
24>28 // result: false
24>=23 // result: true
Self-increment/decrement operators include the self-increment ( ++) and self-decrement ( --). These
canberegardedasspecialassignmentoperator, usingforaddingorsubtracting 1forthevariable. Inaddition,
the increment (decrement) operators can only be used as the postfix operators, and can only be applied to
integer variables, as the values of constants and integer literals cannot be modified. For details about the self-
increment (decrement) operations, see Chapter 4. The following are examples of self-increment (decrement)
operations on integers.
main() {
var i:Int32 =5
var j:Int32 =6
i++// i=6
j--// j=5
return 0
}
Unary minus operator is denoted as -. The unary minus operator returns the negation of its operand.
For details about the unary minus operator, see Chapter 4. The following are examples of unary minus
operator applied to integers.
var i:Int32 =5
var j:Int64 =100
var k:Int32 =-i // k = -5
var l:Int64 =-j // l = -100
(Compound) Assignment operators include assignment operation ( =) and compound assignment
operations ( op=) where the opmay be a binary operators (i.e. arithmetic operators, logical operators or
bitwise operators). (Compound) assignment operation are used for assigning a value to a variable. For
details about the (compound) assignment operation, see the description of the Assignment Expressions in
Chapter 4. The following are simple examples of (compound) assignment operation on integers.
main() {
var x:Int32 =5
var y:Int32 =10
x=y // assignment: x = 10
x+=y// compound assignment: x = 20
x-=y// x = 10
x*=y// x = 100
x/=y// x = 10
x%=y// x = 0
x=5 // x = 5
x**= 2// x = 25
x<<= 1// x = 50
x>>= 2// x = 12
x&=y// x = 8
x^=y// x = 2
x|=y// x = 10
return 0
}
Operators supported by floating-point types
Except bitwise operations, all operations defined on integer types are defined for floating-point types,
including arithmetic operation, relational operation, self-increment/decrement operation, unary plus (minus)
number operation, conditional operation, and (compound) assignment operation. The operations for floating
point may be performed with different accuracy from their types. We remark the operations are defined for
special floating-point values as follows: in a relational expression, if the value of one operand is NaN, the
result of the expression is false, except that the result of NaN != x is true where xcan be any floating-point
number including NaN.
let x=NaN
var y=3.14
var z=x<y// z = false
var v=x!=x// v = true
var w=(x<y)==!(x>=y)// w = false
In an arithmetic expression, the value of an expression containing NaNorinfinity is evaluated according
to the following rules:
Expression Result Remarks
num / 0 POSITIVE_INFINITY num is a non-zero positive floating-point
number
num / 0 NEGATIVE_INFINITY num is a non-zero negative floating point
number
0.0 / 0 NaN floating point number 0.0 is divided by 0
NaN op num NaN op is any arithmetic operator, and num
can be any floating point number
(including NaN, 0, POSITIVE_INFINITY
and NEGATIVE_INFINITY)
POSITIVE_INFINITY op
POSITIVE_INFINITYPOSITIVE_INFINITY op is ‘+’ or ’*’
POSITIVE_INFINITY op
POSITIVE_INFINITYNaN op is ‘-’ or ‘/’
NEGATIVE_INFINITY +
NEGATIVE_INFINITYNEGATIVE_INFINITY
NEGATIVE_INFINITY *
NEGATIVE_INFINITYPOSITIVE_INFINITY
POSITIVE_INFINITY /
numPOSITIVE_INFINITY num = 0 or num = 1.0
NEGATIVE_INFINITY /
numNEGATIVE_INFINITY num = 0 or num = 1.0
POSITIVE_INFINITY /
-1.0NEGATIVE_INFINITY
NEGATIVE_INFINITY /
-1.0POSITIVE_INFINITY
num / Inf sign(num)*sign(Inf)0.0 num is a non-zero positive floating-point
number. Inf is POSITIVE_INFINITY or
NEGATIVE_INFINITY. The sign of
result is determined by the signs of num
(i.e., sign(num)) and Inf (i.e.,
sign(NEGATIVE_INFINITY) = ‘-’)
0 / Inf sign(Inf)0.0 Inf is POSITIVE_INFINITY or
NEGATIVE_INFINITY, the sign of result
is determined by the sign of Inf (i.e.,
sign(NEGATIVE_INFINITY) = ‘-’)
2.1.2 Rune Type
The Cangjie programming language uses Charto represent characters type. A value of type Charis a Unicode
code point . Characters can be classified into printable characters, non-printable characters (such as control
characters), and special characters (such as single quotation marks and backslashes).
•Character Literals
See section Character Literals for the syntax of Rune literals.
A Rune literal consisting of a pair of single quotes and the character itself.
'S'
'5'
' ' // blank
Non-printable and special character literals are written escape sequences ( \).
escape character character
\0 Empty character
\\ backslash \
\b Backspace
\f Writer
\n newline
\r Enter
\t Horizontal tab
\v Vertical tab
\’ single quotation mark ’
\” double quotation marks ”
\u{X} Any Unicode code point, where Xis a 1-8 digit
hexadecimal number
•Operations Defined for the Character Type
OnlyrelationaloperationsaresupporedfortheChartype(forwhichthecomparisonisbasedonUnicode
code point).
main() {
'A'=='A' // result: true
'A'!='A' // result: false
'A'<'a' // result: true
'A'<='A' // result: true
'A'>'a' // result: false
'A'>='A' // result: true
return 0
}
2.1.3 Bool Type
The Boolean type is written as Bool.
•Bool Literal
There are only two Boolliterals: trueand false.
let bool1 :Bool =true
let bool2 :Bool =false
•Operations Defined for the Bool Type
The Cangjie programming language does not support implicit type conversion between the numeric
types and Bool. Only either trueand falsecan be used where a Boolean value is expected. Otherwise,
a compilation error is reported. The following operations are defined for Bool: assignment operation,
part of composite assignment operations ( &&=,||=), part of relational operations ( ==,!=), and all logical
operations ( !,&&,||).
main() {
let bool1 :Bool =true
var bool2 :Bool =false
bool2 =true // assignment
bool2 &&= bool1 // bool2=true
bool2 ||= bool1 // bool2=true
true ==false // return false
true !=false // return true
!false // logical NOT, return true
true &&false // logical AND, return false
false ||false // logical OR, return false
return 0
}
2.1.4 Unit Type
The Unittypehasonlyonevalue (). Exceptthe =operator(anexpressionwith Unittypecanbeassignedtoa
variable with Unittype), the equal ( ==) operator and the not equal ( !=) operator, there are no other operators
defined for Unit. Therefore, any operation (other than the above three operations) that is performed on Unit
type is invalid.
2.1.5 Nothing Type
The Nothingtype is a special type that does not contain any value, and it is the subtype of all types. The
Nothingtype usually implies dead code. For example, if a variable is of type Nothing, it will never be used
and therefore no memory needs to be allocated; if a function call takes an argument of type Nothing, other
arguments following that argument will not be evaluated and the function call itself will not be executed; if
an expression within a block is of type Nothing, then all subsequent expressions and declarations will never
be executed. The compiler will raise warnings for the dead code detected.
Expressions of type Nothingare described in section Control Transfer Expressions .
2.1.6 String Type
The string type is written as String, and useful for holding textual data. A string consists a series of Unicode
characters.
2.1.6.1 String Literals
The Stringliterals in the Cangjie programming language can be divided into three categories: single-line
string literals, multi-line string literals and multi-line raw string literals.
See section String Literals for the syntax of String literals.
A single-line string literal consists of zero or more characters (except non-escape character "and
alone character \) enclosed by a pair of double quote character (i.e., "). Furthermore, a single-line string
literal can only be written on the same line.
let s1="" // empty string
let s2:String ="Hello Cangjie Lang" // define string s2
var s3="\"Hello Cangjie Lang \"" // define string s3 containing character "
var s4:String ="Hello Cangjie Lang \n"// define string s4 containing character \n
// illegal string with character \
let s5="hello \"
// illegal string with character "
let s6="Hello " Cangjie Lang "
A multi-line string literal consists of zero or more valid characters (except alone character \and
non-escape characters """) enclosed by a pair of three double quote characters ( """), which begins after the
line terminator of begining double quotations and ends before the first matched non-escape ending double
quotations. There must be a line terminator after the begining double quotations, otherwise a compiler error
is reported. If non-escape three double quotations is not matched before the end of current file, a compiler
error is reported. Different from single-line string literals, a multi-line string literal can span multiple lines.
// empty multi-line string
let s1="""
"""
// Error: there must be a line terminator after the begining double quotations.
let errorStr ="""abc
"""
/*
The result of s2 is:
This
is a multi-line string
*/
let s2="""
This
is a multi-line string"""
/*
The result of s3 is:
This
is a multi-line string
*/
let s3="""
This
is a multi-line string"""
/*
The result of s4 is:
This
is a
multi-line string
*/
let s4="""
This
is a
multi-line string
"""
/*
The result of s5 is:
This is a
multi-line string
*/
let s5="""
This is a \n
multi-line string
"""
A multi-line raw string literal starts with one or more number signs ( #) and a double quotation ( "),
followed by any valid characters (except one double quotation and the same number of number of number
singes as the begining), and is terminated only by first matched double quotation ( ") and the same number
of number signs ( #) as the beginning. If another double quotation ( ") and the same number of number signs
(#) as the beginning is not matched before the end of current file, a compiler error is reported. Different
from the multi-line string literals, escaping rules do not apply in a multi-line raw string.
// empty multi-line raw string
let empty1 =#""#
// empty multi-line raw string
let empty2 =##""##
/*
The result of s2 is:
This
is a multi-line string
*/
let s2=##"
This
is a multi-line raw string"##
/*
The result of s3 is:
This is a\n
multi-line string
*/
let s3=#"This is a\n
multi-line string"#
/*
The result of s4 is:
This is a "#
*/
let s4=##" This is a "#
"##
// Error: the begining and ending numbers of `#` are not matched.
let errorStr1 =##" error string "#
// Error: the begining and ending numbers of `#` are not matched.
let errorStr2 =##" error string "###
// Error: the string literal is terminated when meeting the first matched `"##`.
let errorStr3 =##" error string "## error "##
String type support using ==(!=) for equality (inequality) comparison. We say two strings are equal, if
and only if their corresponding code point sequences are identical.
2.1.6.2 Interpolated String
An Interpolated String is a string literal containing one or more interpolation expressions, which does
not apply to multi-line raw string literals. When an interpolated string is resolved to a result string, items
with interpolation expressions are replaced by the string representations of the expression results.
Eachinterpolationexpressioninthestringliteraliswrappedinapairof {}, andprefixedby $. Asequence
of expressions and decalrations are allowed within the enclosing pair of curly brakets same as blocks, however,
empty sequence is forbidden. Line breaks are allowed in interpolation expressions inside multi-line strings.
let obj ="apples"
let count =10
let interps1 ="There are ${count *count }${obj}."
// The result of "interps1" is: There are 100 apples.
let error ="Empty sequence is not allowed ${}"// Error
If the $in the string is not followed by {, it should be treated as normal $character. If the $is escaped
by\, the content after $is not treated as interpolation expression, whether or not followed by {.
let d1="The $ sign."
// The result of "d1" is: The $ sign.
let d2="The \ ${v}."
// The result of "d2" is: The ${v}.
Interpolation expressions also support user-defined types, as long as the type implements the ToString
interface. The types described above all implement the ToString interface.
2.1.7 T uple Type
Tupleis an immutable data structure that can contain a heterogeneous sequence of elements. The Tupletype
has the syntax as (Type1, Type2, ..., TypeN) , where Nis the dimension of the tuple, and it is explained as
follows:
1.Any TypeIfrom Type1toTypeNcan be any type (N cannot be less than two, i.e., a tuple is of at least
two dimensions).
2.For each dimension of a Tuplelike the Kthdimension of type TypeK, any objects whose type is a subtype
ofTypeKcan be stored as the Kthelement.
3.If each TypeKin(Type1, Type2, ..., TypeN) supports equality (inequality) comparison ==(!=) , the
tuple type (Type1, Type2, ..., TypeN) supports ==(!=); otherwise, it does not support ==(!=), and a
compilation error will be reported when ==(!=) is used. Besides, two tuple objects with identical tuple
type (Type1, Type2, ..., TypeN) are equal if and only if they are pair-wise equal, which means that
any element pair in the same position (i.e., index) of these two tuples are equal.
The syntax of Tuple Type is defined as:
tupleType
: '(' type (',' type)+ ')'
;
2.1.7.1 Tuple Literals
The Tupleliteral has the format (expr1, expr2, ..., exprN) , in which multiple expressions are separated
by commas and each expression can have a different types. The syntax of Tuple literal is defined as:
tupleLiteral
: '(' expression (',' expression)+ ')'
;
Some examples of Tupleliterals:
(3.14 ,"PIE" )
(2.4,3.5)
(2,3,4)
((2,3),4)
2.1.7.2 Using Tuple to Deconstruct Values
Tuples can also be used to deconstruct another tuple value, i.e., binding elements at different locations in a
tuple to different variables. The following example shows how to deconstruct the return value of a function
with multiple return values.
func multiValues (a:Int32 ,b:Int32 ):(Int32 ,Int32 ){
return (a+b,a-b)// The type of the return value of the function multiValues is (Int32,
Int32). ↪
}
main() {
var (x, y)=multiValues( 8,24)// Define an anonymous tuple who has two elements, i.e., x and
y. ↪
print( "${x}")// output: 32
print( "${y}")// output: -16
return 0
}
2.1.7.3 Subscript Access to Tuple Values
Elements in specific locations can be accessed through tupleName[index] (index indicates the location in
the tuple which starting from ‘zero’, and can only be an integer literal). The following example shows how
anonymous tuples and index-based accessing are used:
main() {
var z=multiValues( 8,24)// the type of z is inferred to be (Int32, Int32)
print( "${z[0]}")// output: 32
print( "${z[1]}")// output: -16
return 0
}
2.1.7.4 Defining Tuple Variables
The type annotation can be omitted when defining a variable of Tuple type, which can be inferred by the
compiler.
let tuplePIE =(3.14 ,"PIE" ) // The type of tuplePIE is inferred to be (Float64, String).
var pointOne =(2.4,3.5) // The type of pointOne is inferred to be (Float64, Float64).
var pointTwo =(2,3,4) // The type of pointTwo is inferred to be (Int64, Int64, Int64).
var pointThree =((2,3),4) // The type of pointThree is inferred to be ((Int64, Int64),
Int64). ↪
2.1.8 Range Type
The Range type is written as Range<T> , where Tcan only be instantiated as types that implement the
Comparable interface and the AddInt64 interface. In above, the Comparable constrains instances of type Tto
be comparable using the relational operator, and the AddInt64 constrains instances of type Tcan be added
with values of type Int64.Rangeis an immutable type that represents an sequence of elements with fixed
step value.
Each instance of type Range<T> will contain three values, i.e., start,endand step. Where startand end
represent the start and end values of the sequence, respectively, and steprepresents the difference between
two adjacent elements in the sequence.
Rangetypes support using ==(! =) for equality (inequality) comparison. We say two instances of the
same Rangetype are equal, if and only if they are both half-open (orclosed) and the value of their start,
endand stepare equal, respectively.
2.1.8.1 Creating Instances of Range Types
There are two Rangeoperators: ..and ..=which are used to create half-open range instances and closed
range instances, respectively. For the expression start..end:step and the expression start..=end:step , it is
explained as follows.
1.It is required that the expression startand the expression endhave the same type and that stepbe of
type Int64.
2.The expression start..end:step returns an empty rangeinstance (i.e., an empty sequence) if step > 0
and start >= end , or step < 0 and start <= end . When the result of start..end:step is non-empty,
the number of elements in the rangeinstance is equal to the ceiling of (end-start)/step (i.e., the least
integer greater than or equal to (end-start)/step )
3.The expression start..=end:step returns an empty rangeinstance if step > 0 and start > end , orstep
< 0and start < end . When the result of start..=end:step is non-empty, the number of elements in
therangeinstance is equal to the floor of ((end-start)/step)+1 (i.e., the greatest integer less than or
equal to ((end-start)/step)+1 )
let range1 =0..10:1 // Define an half-open range [0,10) (with step = 1) which contains 0, 1,
2, 3, 4, 5, 6, 7, 8 and 9. ↪
let range2 =0..=10:2 // Define a closed range [0,10] (with step = 2) which contains 0, 2, 4,
6, 8 and 10. ↪
let range3 =10..0:-2 // Define an half-open range [10,0) (with step = -2) which contains 10,
8, 6, 4 and 2. ↪
let range4 =10..=0:-1// Define a closed range [10,0] (with step = -1) which contains 10, 9, 8,
7, 6, 5, 4, 3, 2, 1 and 0. ↪
let range5 =10..0:1 // Define an empty range.
let range6 =0..0:1 // Define an empty range.
let range7 =0..=0:1 // Define a closed range [0,0] (with step = 1) which only contains 0.
let range8 =0..=10:-1// Define an empty range.
4.In the expression start..end:step and start..=end:step , the value of stepmust not be 0.
let range9 =0..10:0 // error: the value of the step should not be zero.
let range10 =0..=10:0 // error: the value of the step should not be zero.
5.The startand (or) endcan be omitted in the scenario that using instances of type Range<Int64> in the
index access operator [](see the next section). But for other cases, only the stepis optional (defaultly
step=1), which means startand endare both mandatory.
let range11 =1..10 // Define an half-open range [1, 10) with step = 1.
let range12 =1..=10 // Define a closed range [1, 10] with step = 1.
let range13 =..10 // error: the start value is required.
let range14 =1.. // error: the end value is required.
let range15 =.. // error: the start and end value are required.
2.1.8.2 Use of Range Types
Rangeexpressions can be used as a part of the for inexpressions (refer to Loop Expressions ) or can be used
as index for slicing. It should be noted that:
•When instances of type Range<Int64> are used in the index access operator [], both startand endare
optional. The values of ommited item are determined by the context in which the instance is used:
when the operator []is overloaded on a custom type and its parameter type is Range<Int64> , the value
ofstartequals 0when startis omitted, and the value of endequals the maximum value of Int64.
2.1.8.3 Defining Range Variables
When defining Range<T> variables, the type annotation can be added or omitted (inferred by the compiler in
this situation).
let range16 :Range <Int64 >=0..10 // Define an half-open range [0,10) with step = 1
let range17 :Range <Int64 >=-10..10:2 // Define an half-open range [-10,10) with step = 2
let range18 =0..=10 // Define a closed range [0,10] with step = 1
let range19 =-10..=10:2 // Define a closed range [-10,10] with step = 2
2.1.9 F unction Type
The function type is immutable and is the type of functions. The syntax of function type is:
arrowType
:parameterTypes '->' type
;
parameterTypes
:'(' (type (',' type )*)? ')'
;
The parameter type list (i.e., parameterTypes ) and the return value type (i.e., type) are linked using ->.
The ()outside of the parameter type list is mandatory, in which zero or multiple types can be included
(multiple types are separated by ,).
()->Int32 // A function type has an empty parameter type list, and its return value type is
'Int32'. ↪
()->Unit // A function type has an empty parameter type list, and its return value type is
'Unit'. ↪
(Float32 )->Int32 // A function type has one parameter whose type is 'Float32', and its return
value type is 'Int32' ↪
(Int32 ,Int32 ,Float32 )->Int32 // A function type has three parameters, and its return value
type is 'Int32' ↪
(Int32 ,Int32 ,Float32 )->(Int32 ,Int32 )// A function type has three parameters, and its return
value type is '(Int32, Int32)' ↪
(Int32 ,Int32 ,Float32 )->Unit // A function type has three parameters, and its return value
type is 'Unit'. ↪
In the Cangjie programming language, functions are first-class citizens. This means functions can be used
as arguments of other functions, and can be used as return values to other functions, and can be assigned
directly to variables.
Function types do not support using ==(!=) for equality (inequality) comparison. For more information
about functions, see Chapter 5 Functions.
2.1.10 struct Type
The structtype is mutable, in which multiple member variables and member functions can be defined. The
following grammar shows the definition of structtypes:
structDefinition
: structModifier? 'struct' identifier typeParameters? ('<:' superInterfaces)?
genericConstraints? structBody ↪
;
structBody
: '{'
structMemberDeclaration*
structPrimaryInit?
structMemberDeclaration*
'}'
;
structMemberDeclaration
: structInit
| staticInit
| variableDeclaration
| functionDefinition
| operatorFunctionDefinition
| macroExpression
| propertyDefinition
;
In above, structModifier indicates the modifier of struct, and structis the keyword, and identi-
fieris the name of the struct type. typeParameters and genericConstraints are list of type variables
and their constraints (refer to chapter 9 for generics), respectively. In the structBody , it is allowed to de-
fine member variables ( variableDeclaration ), member properties ( propertyDefinition ), primary constructor
(structPrimaryInit ), constructor functions ( structInit ) and member functions (including ordinary functions
and operator functions).
For structtypes, it should be noted that:
1.structtypes can only be defined at top-level .
2.As custom types, structtypes do not support ==(and ! =) by default. Of course, it is possible to
override the ==(or! =) operator (see section operator overloading ) to make custom structtypes
support ==(or! =).
3.structs can not be inherited.
4.structs can implement interfaces .
5.A struct type is said to be recursive, if at least one of its non-static member variable’s type contains
the struct type itself. Multiple struct types are said to be mutually recursive, if circular references
exist between the types of their non-static member variables. The struct types defined recursively or
mutually recursively are illegal, unless there is at least one struct type T_iis encapsulated within a
class, interface, enum or function type on each recursive chain T_1, T_2, ..., T_N . That is to say, a
recursive (or mutually recursive) struct definition can be made legal by using class, interface, enum or
function types.
Examples of structdefinition:
struct Rectangle1 {
let width1 :Int32
let length1 :Int32
let perimeter1 :()->Int32
init (width1 :Int32 ,length1 :Int32 ){
this .width1 =width1
this .length1 =length1
this .perimeter1 ={=>2*(width1 +length1) }
}
init (side :Int32 ){
this (side, side)
}
func area1 ():Int32 {width1 *length1 }
}
// Define a generic struct type.
struct Pair <T1, T2>{
let first :T1
let second :T2
init (f:T1, s:T2) {
this .first =f
this .second =s
}
}
Examples of recursive or mutually recursive structtypes are defined as follows.
struct R1{// error: 'R1' cannot have a member that recursively contains it
let other :R1
}
struct R2{// ok
let other :Box<R2>
}
struct R3{// error: 'R3' cannot have a member that recursively contains it
let other :R4
}
struct R4{// error: 'R4' cannot have a member that recursively contains it
let other :R3
}
struct R5{// ok
let other :E1
}
enum E1{// ok
A(R5)
}
2.1.10.1 Member Variables in struct
The syntax for the definition of member variables is:
variableDeclaration
: variableModifier* NL* (LET | VAR) NL* patternsMaybeIrrefutable ((NL* COLON NL* type)? (NL*
ASSIGN NL* expression) | (NL* COLON NL* type)) ↪
;
In the process of defining member variables:
1.Allmember variables defined outside the primary constructor can have an initial value or no initial
value. For any member variable, only initialized member variables defined before it and static member
functions can be referenced in its default value expression.
2.1.10.2 Constructors
In Cangjie programming language, there are two types of class constructors: primary constructor and init
constructor.
Primary Constructor The syntax of the primary constructor is as follows:
structPrimaryInit
: (structNonStaticMemberModifier)? structName '('
structPrimaryInitParamLists? ')'
'{'
expressionOrDeclarations?
'}'
;
structName
: identifier
;
structPrimaryInitParamLists
: unnamedParameterList (',' namedParameterList)?
(',' structNamedInitParamList)?
| unnamedParameterList (',' structUnnamedInitParamList)?
(',' structNamedInitParamList)?
| structUnnamedInitParamList (',' structNamedInitParamList)?
| namedParameterList (',' structNamedInitParamList)?
| structNamedInitParamList
;
structUnnamedInitParamList
: structUnnamedInitParam (',' structUnnamedInitParam)*
;
structNamedInitParamList
: structNamedInitParam (',' structNamedInitParam)*
;
structUnnamedInitParam
: structNonStaticMemberModifier? ('let' | 'var') identifier ':' type
;
structNamedInitParam
: structNonStaticMemberModifier? ('let' | 'var') identifier '!' ':' type
('=' expression)?
;
A primary constructor definition includes the following:
**1. Modifier: optional. Primary constructors can be modified with one of publicorprivate, none of
which are visible within the package. See Access Modifiers for details
2. The primary constructor name is the same as the type name. The keyword funcis not allowed
before the primary constructor name.
3. Parameter list: The primary constructor name is followed by a parameter list. The parameter
list contains two types of parameters: regular parameters and non-static member variable parameters. The
syntax and semantics of regular parameters are consistent with those in the function definition.
The member variable parameter is introduced to reduce code redundancy. Defines a member variable
parmeter, including the definitions of both a parameter and a member variable. In addition, it indicates the
semantics of assigning value to member variable through the parameter. The definitions and expressions of
the omissions are automatically generated by the compiler.
•The syntax of the member variable parameter is the same as that defined outside the primary construc-
tor. In addition, it is supported by using !indicates whether the parameter is a named parameter.
-The members in the primary constructor can also be modified by using publicorprivate.See Access
Modifiers for details
•In the primary constructor, only non-static member variable declarations can be written.
•The member variable defined in the primary constructor cannot have the same name as those outside
the primary constructor.
•The initial values of the member variables defined by the primary constructor can be set through pa-
rameters when the object is initialized. This is because the primary constructor generates a constructor
by the compiler and assigns values to the member variables in the primary constructor.
•A member variable parameter defined by the primary constructor can have an optional initial value.
The initial value expression can refer to other parameters that have been defined before the parameter
(excluding instance member variables defined outside the primary constructor), but the values of these
referred parameters and member variables cannot be modified. Note that the initial values of member
variable form parameters are only valid in the main constructor and are not included in the member
variable definition.
•Regular parameters must precede all member variable parameters. The sequence of the parameters of
the primary constructor must follow the parameter sequence when the function is defined. Non-named
parameters must precede all named parameters.
4. Main constructor body: The primary constructor does not allow calls to other constructors in
this struct. Declarations and expressions are allowed in the primary constructor body but must meet the
requirements of init constructors.
The following example defines a struct with a primary constructor.
struct Test{
static let counter :Int64 =3
let name :String ="afdoaidfad"
private Test(
name :String, // regular parameter
annotation !:String ="nnn" , // regular parameter
var width !:Int64 =1, // member variable parameter with initial value
private var length !:Int64 , // member variable parameter
private var height !:Int64 =3 // member variable parameter
){}
}
A primary constructor is a syntax sugar of regular constructor. The compiler automatically generates a
definition of the constructor and member variables corresponding to the main constructor, the form of the
automatically generated constructor is as follows:
•The modifier is the same as that of the primary constructor.
•The sequence of parameters from left to right is the same as that of parameters declared in the primary
constructor parameter list.
•The constructor body is in the following format:
–Assign values to member variables in sequence. The syntax format is this.x = x , where xindicates
the member variable name.
–Then other code inside the primary constructor body.
struct B<X,Y>{
B(
x:Int64 , // primary constructor, it's name is the same as the struct
y:X,
v!:Int64 =1, // regular parameter
private var z!:Y// member variable parameter
){}
/* The corresponding init constructor with primary constructor auto-generated
by compiler.
private var z: Y // auto generated member variable definition
init( x: Int64, y: X, v!: Int64 = 1, z!: Y) { // auto generated named parameter definition
this.z = z // auto generated assign expression of member variable
}
*/
}
A struct can define one primary constructor. In addition to the primary constructor, other constructors
can be defined as usual, but the other constructors must form an overload with the corresponding constructor
of the primary constructor.
InitConstructors Inadditiontotheprimaryconstructor, itispossibletodefineuser-definedconstructors,
which are defined by starting with the keyword initand followed by the parameter list and the function body.
Astructcan have multiple constructors (including the constructor generated by the primary constructor),
but they should to meet the requirements of function overloading (see Function Overloading Definition for
details). Moreover,
1.The parameters of the constructor can have default values. Not allowed to use the instance mem-
ber variable this.variableName and its syntax sugar variableName as the default value of constructor
parameters.
2.Before all of the instance member variables are initialized, the constructor cannot use functions or
lambda that capture this, but can use this.variableName (the syntax sugar variableName ) to access
initialized member variables.
3.Inside constructor, thiscannot be captured in lambda expressions and nested functions. Also, this
cannot be used as a separate expression.
4.It is allowed to invoke other constructors via thisin a constructor. If called, it must be at the first
expression in the constructor body, without any expression or declaration before it. It is not allowed
to invoke a constructor via thisoutside of the constructor body.
5.If a constructor does not explicitly call other constructors, ensure that all instance member variables
declared in this struct have been initialized before returned from the constructor. Otherwise, an error
will be reported during compilation.
6.The compiler analyzes the dependency between all constructors. If a cyclic invoking is performed, an
error is reported.
7.The return type of the constructor is Unit type.
If neither the primary constructor nor the initconstructor is defined for a struct, the compiler attempts
to generate a ( publicmodified) parameterless constructor. If the one of the instance member variables of
the struct have no initial value, an error is reported during compilation.
2.1.10.3 Other Members in struct
Member functions, member attributes and a static initializer can also be defined in struct.
•See Section function definition for defining common member functions.
•See Section operator overloading for the syntax of defining operator functions.
•See Section definition of properties for the syntax of defining member properties.
•See Section Static initializers for defining static initializers.
2.1.10.4 Modifiers in struct
With respect to the modifiers of each items in struct, they are described as follows.
1.The structModifier in the structdefinition is an optional access modifier, which can only be public
or not provided (the default is accessible only within the package).
2.The visibility of structmembers can be controlled by the visibility modifiers publicorprivate. In
addition, static members can be declared using the staticmodifier. See Access Modifiers for details
3.The modifier for the primary constructor is optional and can be either publicorprivate, leaving it
out is Default. See Access Modifiers for details
4.Member variables defined within primary constructor can only be modified with visibility modifiers
(i.e. publicorprivate, leaving it out is Default), not with the staticmodifier. See Access Modifiers
for details
5.The structconstructor can only be modified with visibility modifiers (i.e. publicorprivate, leaving
it out is Default), not with static.See Access Modifiers for details
The meaning of each of the modifiers is explained as follows:
1.The members modified with private within structare visible only within the definition of struct.
Members modified with publicare visible both inside and outside the structdefinition and can be ac-
cessed outside structin the form of structInstance.varName and structInstance.funcName(arguments)
(structInstance denotes an instance of struct), respectively. Members without visibility modifiers are
visible both inside the structdefinition and inside the package.
2.Membersmodifiedwith staticarestaticmembers, andstaticmembersaremembersoftype struct, not
members of structinstances. Outside the structdefinition, instance member variables and instance
member functions can only be accessed through the structinstance, and static member variables and
static member functions can only be accessed through the name of the structtype.
2.1.10.5 Instances of struct Types
When a structtype is defined, the corresponding instance of the structcan be instanced. The definition
for an instance of a structcan be divided into two kinds, according to whether the struct is generic:
1.Using StructName(arguments) for defining instances of struct that are not generic. In above, StructName
is the name of the struct, and arguments is the list of argument. StructName(arguments) will invoke
the closest matching constructor (based on the rules in section Function overloading Resolution ), and
then generate an instance of StructName .
let newRectangle1_1 =Rectangle1() // Invoke the constructor defined by the empty init
block. ↪
let newRectangle1_2 =Rectangle1( 100,200)// Invoke the first custom constructor.
let newRectangle1_3 =Rectangle1( 300) // Invoke the second custom constructor.
2.Using StructName<Type1, Type2, ... , TypeK>(labelValue1, labelValue2, ... , labelValueN) for
defining instances of generic structs. The only difference from defining an instance of a non-generic
struct is that type variables need to be instanced for generic struct, i.e., ‘Type1’ to ‘TypeN’ should be
given. Some examples are given below:
let newRectangle2_1 =Rectangle2 <Int32 >(100)// Invoke the custom constructor.
let newRectangle2_1 =Rectangle2 <Int32 >(width2 :10,length2 :20)// Invoke another custom
constructor. ↪
Finally, note that structInstance (an instance of a struct type) does not support changing the value of
the member variable varNameby means of structInstance.varName = expr if it is defined by let(even though
the varNameis defined using var); if structInstance is defined using varand varNameis also defined using
var,structInstance.varName = expr is supported to modify the value of member variable varName.
2.1.11 enum Type
The enumtype is immutable , and used to enumerate a set of related values (called constructor s). A value of
anenumtype can only take one of these constructor s at any time.
2.1.11.1 Enum Definition
The syntax of the definition of enumtypes is:
enumDefinition
: enumModifier? 'enum' identifier typeParameters? ('<:' superInterfaces)?
genericConstraints? '{' enumBody '}' ↪
;
enumBody
: '|'? caseBody ('|' caseBody)* (functionDefinition | operatorFunctionDefinition |
propertyDefinition | macroExpression)* ↪
;
caseBody
: identifier ('(' type (',' type)* ')')?
;
In above, enumModifier indicates the modifier ( public) of enum, and enumis the keyword, and identifier
is the name of the enum type. typeParameters and genericConstraints are list of type variables and their
constraints (refer to chapter 10 for generics), respectively. A number of caseBodie s (i.e., constructor s) can be
defined in enumBody , and each constructor can have no parameters or have a set of parameters with different
types, with |separating multiple constructor s, the first constructor can be preceded by an optional |. After
enumBody you can define other members of enum, including member functions, operator overloading functions
and member properties.
Examples of enumdefinition:
/*
Define an enum type 'TimeUnit1' who has four constructors: 'Year', 'Month', 'Day' and 'Hour'.
*/
enum TimeUnit1 {
Year |Month |Day |Hour
}
/*
'TimeUnit2' has four constructors: 'Year(Int32)', 'Month(Int32, Float32)', 'Day(Int32, Float32,
Float32)' and 'Hour(Int32, Float32, Float32, Float32)'. ↪
*/
enum TimeUnit2 {
|Year( Float32 )
|Month( Float32 ,Float32 )
|Day( Float32 ,Float32 ,Float32 )
|Hour( Float32 ,Float32 ,Float32 ,Float32 )
}
/*
Define a generic enum type 'TimeUnit3<T1, T2>' who has four constructors: 'Year(T1)', 'Month(T1,
T2)', 'Day(T1, T2, T2)' and 'Hour(T1, T2, T2, T2)'. ↪
*/
enum TimeUnit3 <T1, T2 >{
|Year(T1)
|Month(T1, T2)
|Day(T1, T2, T2)
|Hour(T1, T2, T2, T2)
}
For enumtypes, it should be noted that:
1.enumtypes can only be defined at top-level .
2.It is not allowed to define a constructor with empty parentheses, and the type of a constructor without
parameters is not a function type but just the type of the enumbeing defined. A constructor with
parameters has a function type, but it is not a first-class citizen. For example:
enum E{
|mkE // OK. The type of mkE is E but not () -> E.
|mkE() // Syntax error.
}
enum E1{
|A
}
let a=A// ok, a: E1
enum E2{
|B(Bool )
}
let b=B// error
enum E3{
|C
|C(Bool )
}
let c=C// ok, c: E3
3.As custom types, enumtypes do not support ==(and ! =) by default. Of course, it is possible to override
the==(or! =) operator (see Section operator overloading ) to make custom enumtypes support ==(or
! =).
4.Overloading of constructor is supported in the same enum, but only the number of parameters is
involved in the overloading, not the type of parameters, i.e., multiple constructor s of the same name
are allowed to be defined in the same enum, but they are required to have different number of parameters
(despite the fact that the constructor without parameters is not of a function type, it can still be
overloaded with other constructor s). For example:
enum TimeUnit4 {
|Year
|Year( Int32 ) // ok
|Year( Float32 ) // error: redeclaration of 'Year'
|Month( Int32 ,Float32 ) // ok
|Month( Int32 ,Int32 ) // error: redeclaration of 'Month'
|Month( Int32 ) // ok
|Day( Int32 ,Float32 ,Float32 ) // ok
|Day( Float32 ,Float32 ,Float32 ) // error: redeclaration of 'Day'
|Day( Float32 ,Float32 ) // ok
|Hour( Int32 ,Float32 ,Float32 ,Float32 )// ok
|Hour( Int32 ,Int32 ,Int32 ,Int32 ) // error: redeclaration of 'Day'
|Hour( Int32 ,Int32 ,Int32 ) // ok
}
5.It is supported to define recursive and mutually recursive enum types. For example:
// recursive enum
enum TimeUnit5 {
|Year( Int32 )
|Month( Int32 ,Float32 )
|Day( Int32 ,Float32 ,Float32 )
|Hour( Int32 ,Float32 ,Float32 ,Float32 )
|Twounit(TimeUnit5, TimeUnit5)
}
// mutually recursive enums
enum E1{
A|B(E2)
}
enum E2{
C(E1) |D(E1)
}
6.enums can not be inherited.
7.enums can implement interfaces (for interfaces, see chapter 6).
2.1.11.2 Accessing Constructors
The first manner is access a constructor through the enumname and the constructor name, for example:
let time1 =TimeUnit1.Year
let time2 =TimeUnit2.Month( 1.0,2.0)
let time3 =TimeUnit3 <Int64 ,Float64 >.Day( 1,2.0,3.0)
The second way is to omit the enumname, for example:
let time4 =Year // syntax sugar of 'TimeUnit1.Year'
let time5 =Month( 1.0,2.0) // syntax sugar of 'TimeUnit2.Month(1.0, 2.0)'
let time6 =Day<Int64 ,Float64 >(1,2.0,3.0)// syntax sugar of 'TimeUnit3<Int64,
Float64>.Day(1, 2.0, 3.0)' ↪
Note that since Cangjie supports type inference for generic parameters, the generic parameter <T>can
be omitted when accessed using both way 1 and way 2 above.
The following rules need to be met regarding the second use.
enum constructors are always introduced automatically under the current scope and can be used by
omitting the type prefix.
The enum constructor participates in the resolution of function overloading. When it is not possible to
resolve, both the enum constructor and the function cannot be used directly, so the enum constructor needs
to be used by type prefixing and the function needs to be used by prefix qualification.
1.As long as more than one enum constructor passes the type check, it is unresolvable.
2.As long as there are enum constructor and functions that pass the type check, they just cannot be
resolved.
3.Only the only enum constructor that is considered capable of resolution.
package p
enum E{
|f(Int64 )
|f(Int64 ,Int64 ,Int64 )
}
func f(a:Int64 ){}
func f(a:Int64 ,b:Int64 ){}
func g(){
f(1)// error
p.f( 1)// ok
E.f( 1)// ok
f(1,2)// ok, find f(a: Int64, b: Int64)
f(1,2,3)// ok, find E.f(Int64, Int64, Int64)
}
When an enum constructor conflicts with other names (variable names, type names), neither the enum
constructor nor the conflicting name can be used directly; it must be used in a prefix-qualified manner.
package p
var A=0// conflict with A
var F:(Int64 )->Int64 ={i=>i}// conflict with F
enum E{
|A// conflict with A
|F(Int64 )// conflict with F
}
enum R{
|C(Int64 )// conflict with C
}
enum C{// conflict with C
|B
}
func g(){
let a=A// error
let b=E.A // ok
let c=p.A // ok
F(1)// error
E.F( 1)// ok
p.F( 1)// ok
let x:C// error
let y:p.C // ok
}
The enum constructor, when used with the type prefix omitted, can declare generic parameters of type
enum after the constructor name.
enum E<T>{
|A(T)
|B(T)
}
func f(){
let a=A(1) // ok, a: E<Int64>
let b=A<Int32 >(2)// ok, b: E<Int32>
}
2.1.11.3 Destructuring Enums
Amatchexpression and enum pattern s can be applied to destructure enum values. See section 4.4.1
Patterns for details.
Take the TimeUnit1 and TimeUnit2 as defined in above as examples, their deconstruction can be illustrated
as follows:
let time12 =TimeUnit1.Year
let howManyHours =match (time12) {
case Year =>365 *24// matched
case Month =>30*24
case Day =>24
case Hour =>1
}
let time13 =TimeUnit2.Month( 1.0,1.5)
let howManyHours =match (time13) {
case Year(y) =>y*365 *24
case Month(y, m)=>y*365 *24+m*30*24// matched
case Day(y, m,d)=>y*365 *24+m*30*24+d*24
case Hour(y, m,d,h)=>y*365 *24+m*30*24+d*24+h
}
2.1.11.4 Other Members in Enums
Member functions and member attributes can also be defined in enum.
•See Section function definition for defining common member functions.
•See Section operator overloading for the syntax of defining operator functions.
•See Section definition of properties for the syntax of defining member properties.
Here are some simple examples.
enum Foo {
A|B|C
func f1(){
f2(this )
}
static func f2(v:Foo) {
match (v) {
case A=>0
case B=>1
case C=>2
}
}
prop item :Int64 {
get() {
f1()
}
}
}
main() {
let a=Foo.A
a.f1()
Foo.f2(a)
a.item
}
The constructors, static member functions, and instance member functions of an enum type cannot be
overloaded. Therefore, the constructors, static member functions, instance member functions, and member
properties of the enum cannot have the same name.
2.1.11.5 Option Type
Option type is a generic enumtype defined as follows:
enum Option <T>{Some(T) |None }
Someand Noneare two different constructor s, where Some(T)represents a state with values and Nonerep-
resents a no-value state. Specific option types can be defined by generic instantiation, such as Option<Int32> ,
Option<String> etc.
An alternative way of writing Option type is to prefix the type name with a ?, i.e., for any type Type,?Type
is equivalent to Option<Type> . For example, ?Int32is equivalent to Option<Int32> ,?Stringis equivalent to
Option<String> , etc.
It should be noted that:
1.Although Tand Option<T> are different types, when it is clear that a location requires a value of type
Option<T> , you can pass a value of type Tdirectly, and the compiler will wrap the value of type Tinto
theSome constructor ofOption<T> . For example, the following definition is legal.
let v1:?Int64 =100
let v2:??Int64 =100
2.For two types T1and T2that are not equal , there is no subtype relationship between Option<T1> and
Option<T2> even if T1and T2have a subtype relationship.
The following shows the declaration and initialization of variables of Option type :
let opInt32_1 =Some( 100) // The type of 'opInt32_1' is 'Option<Int32>'
let opInt32_2 =Option <Int32 >.None // The type of 'opInt32_2' is 'Option<Int32>'
let opChar =Some( 'm') // The type of 'opChar' is 'Option<Rune>'
let opBool =Option <Bool >.None // The type of 'opBool' is 'Option<Bool>'
let opEnum =Some(TimeUnit1.Year) // The type of 'opEnum' is 'Option<TimeUnit1>'
Unwrapping Values of Option Types Several ways are provided to facilitate the unwrapping of option
type values, i.e., pattern matching, the getOrThrow function, the coalescing operator ( ??), and the question
mark operator ( ?).
1.As the Option type is a kind of enum type, the enum pattern introduced in the pattern matching
expression (see Enum Patterns for details) can be used to unwrap option type values.
let number1 =match (opInt32_1) {
case Some(num) =>num // matched
case None =>0
}
let number2 =match (opInt32_2) {
case Some(num) =>num
case None =>0 // matched
}
let enumValue =match (opEnum) {
case Some(tu) =>match (tu) {
case Year =>"Year" // matched
case Month =>"Month"
case Day =>"Day"
case Hour =>"Hour"
}
case None =>"None"
}
2.For an expression eof type Option<T> , the unwrapping of eis achieved by calling the function
getOrThrow() orgetOrThrow(exception: ()->Exception) : if the value of eequals to Option<T>.Some(v) ,
then the value of e.getOrThrow() (ore.getOrThrow(lambdaArg) ) is equal to the value of v; if the value of
eis equal to Option<T>.None , then e.getOrThrow() throws a NoneValueException exception at runtime
(e.getOrThrow(lambdaArg) throws a exception specified in the lambdaArg ).
let number1 =opInt32_1.getOrThrow() // number1 = 100
let number2 =opInt32_2.getOrThrow() // throw NoneValueException
let number3 =opInt32_2.getOrThrow{ MyException( "Get None value" )}// throw MyException
3.For an expression e1of type Option<T> and an expression e2of type T, the expression e1 ?? e2 has
type T. When the value of e1is equal to Option<T>.Some(v) , the value of e1 ?? e2 has a value equal to
the value of v; the value of e1 ?? e2 is equal to the value of e2when e1equals to Option<T>.None . For
more information about the ??operator, see section Coalescing Expressions .
let number1 =opInt32_1 ??0// number1 = 100
let number2 =opInt32_2 ??0// number2 = 0
4.The question mark operator ( ?) is a postfix unary operator. The ?shall be used with the postfix
operators .,()and []in order to make option types support for these postfix operators. For an
expression eof type Option,e?.bmeans that Option<T>.Some(b) is obtained when eis Some, otherwise
Option<T>.None (T is the type of b), and the same for the other operators. See section The Question
Mark Operator for more details of the ?operator.
class C{
var item =100
}
let c=C()
let c1=Some(c)
let c2=Option <C>.None
let r1=c1?.item // r1 = Option<Int64>.Some(100)
let r2=c2?.item // r2 = Option<Int64>.None
2.1.12 V Array Type
The VArraytype is written as a generic type VArray<T, $IntLiteral> , which is used to store a sequence of
values of the same type (or have a common parent type). For VArray<T, $IntLiteral> , it is explained as
follows:
1.The elements in VArray<T, $IntLiteral> are ordered and support accessing by index (starting from 0).
If the provided index is greater than or equal to the length, the compiler will report an error when
index value can be deduced by complier, otherwise, an exception is thrown at run time.
2.The length of a VArray<T, $IntLiteral> type is part of the type. The integer literal following the $
symbol indicates its length. When the provided integer literal is a negative number, an error is reported
during compilation.
3.VArrayis a value type. A variable defined as a value type stores the data directly instead of via
a reference or indirection, so the VArraytype copies the value when performing operations such as
assignment or function argument passing.
4.For 2 VArraytypes, if the type variables Tare instantiated as different types, or the $IntLiteral anno-
tation lengths are not equal, they are considered different VArraytypes. For example, VArray<Int32,
$5>and VArray<Float64, $5> are different types of VArray.VArray<Int32, $2> and VArray<Int32, $3>
are also different types of VArray.
5.When the generic argument TofVArrayis another VArraytype, it represents a multidimensional VArray
type.
2.1.12.1 Creating Instances of VArray
VArray can also use Array literals to create new instances. This approach can only be used if it is clear from
the context that the literal is of type VArray, otherwise it will still preferentially be inferred as Array.
The length of VArraymust be of the literal type Int64and must be the same as the length of the provided
literal array. Otherwise, an error is reported during compilation.
let arr1 :VArray <Int64 ,$5>=[1,2,3,4,5]
let arr2 :VArray <Int16 ,$0>=[]
let arr3 :VArray <Int16 ,$0>=[1]// error
let arr4 :VArray <Int16 ,$-1>=[]// error
In addition to this, VArray can also be created as an instance using a constructor.
// VArray<T, $IntLiteral>(initElement: (Int64)->T)
let arr5 :VArray <Int64 ,$5>=VArray <Int64 ,$5>{i=>i}// [0, 1, 2, 3, 4]
let arr6 :VArray <Int64 ,$5>=VArray <Int64 ,$5>(item :0)// [0, 0, 0, 0, 0]
The type argument <T, $IntLiteral> ofVArraycannot be omitted.
2.1.12.2 Accessing elements of VArrays
For an VArray instance arr, ways for accessing elements in arrare shown as follows:
Element at a specific location can be accessed through arr[index1]...[indexN] (where index1,...,indexN
are expressions for the index value, whose types are all Int64). For example:
var arr7 :VArray <Int64 ,$2>=[0,1]
let element0 =arr7[ 0] // element0 = 0
arr7[ 1]=10 // change the value of the second element of 'array5' through index
// Get and Set of Multidimensional Arrays.
var arr8 :VArray <VArray <Int64 ,$2>,$2>=[[1,2],[3,4]]
let element1 =arr8[ 1][0] // element1 = 3
arr8[ 1][1]=5 // change the value from 4 to 5
2.1.12.3 Obtain the length of the VArray.
The number of elements in arrcan be obtained arr.size .
let arr9 :VArray <Int64 ,$6>=[0,1,2,3,4,5]
let size =arr9.size // size = 6
2.1.12.4 VArray in function signature
When VArrayis used as a parameter or return value of a function, the length of VArrayneeds to be annotated.
func mergeArray <T>(a:VArray <T,$2>,b:VArray <T,$3>):VArray <T,$5>
2.2 Reference Types
The following introduces all reference types of the Cangjie programming language.
2.2.1 Array Type
The Arraytype is written as a generic type Array<T> . Arrays are used to store a sequence of values of the
same type (or has a common super type). For Array<T> , it is explained as follows:
1.Values in Array<T> are ordered and are accessed through the index (starting from 0).
2.The length of arrays are fixed. That is, once an array is initialized, its length cannot be changed.
3.Arrayis a reference type, defined as a variable of reference type, the variable name is stored in the
reference to the data value, so in the assignment or function passing, Arraycopies the reference.
4.Different types of Array are got when the type variable Ttakes different values (i.e., types), e.g.,
Array<Int32> and Array<Float64> are array of Int32and array of Float64, respectively.
5.Only when the concrete type TypeinArray<T> supports using ==(! =) for equality (inequality) compar-
ison, Array<T> supports ==and ! =, otherwise, Array<T> does not support ==and ! =(a compilation
error will be generated when using ==and ! =for comparison). We say two instances of Array<T> (with
the same type) are equal, if and only if elements in the same position (i.e., index) are all equal, which
means they have the same length.
6.Multidimensional arrays are defined as ‘arrays of array’ with the format Array<Array<...>> . For exam-
ple, Array<Array<Int32>> indicates a two-dimensional array with the type of element is Int32.
7.When ElementType have subtypes, the instantiated Array<ElementType> can store instances of any sub-
types of ElementType . For example, instances of any subtypes of Objectcan be stored in Array<Object> .
2.2.1.1 Creating Instances of Arrays
There are 2 ways for creating an instance of array:
Constructor
// Array<T>()
let emptyArr1 =Array <Int64 >() // create an empty array whose type is Array<Int64>
let emptyArr2 =Array <String >()// create an empty array whose type is Array<String>
// Array<T>(size: Int64, initElement: (Int64)->T)
let array3 =Array <Int64 >(3){i=>i*2}// 'array3' has 3 elememts: 0, 2, 4
let array4 =Array <String >(2){i=>"$i" }// 'array4' has 2 elememts: "0", "1"
Array Literals Arrayliterals have the format of [element1, element2, ..., elementN] , in which multiple
elements are separated by commas and each element can be an expressionElement (i.e., general expression ).
The syntax of Arrayliteral is then defined as:
arrayLiteral : '[' (elements)? ']' ;
elements : element (',' element)* ;
element : expression ;
For Arrayliterals, their elements are expressions:
let emptyArray :Array <Int64 >=[] // empty Array<Int64>
let array0 =[1,2,3,3,2,1] // array0 = [1, 2, 3, 3, 2, 1]
let array1 =[1+3,2+3,3+3] // array1 = [4, 5, 6]
•When the context does not require some specific type, assume the least common supertype of all
elements is T, then the type of the Array literal is Array<T> .
•When the context does require a specific type, then the type of all the elementmust be a subtype of
the specific elementtype required by the context.
2.2.1.2 Accessing elements of Arrays
For an array instance arr, manners for accessing elements in arris showed as follows:
Accessing an element at a specific location : Element at a specific location can be accessed through
arr[index1]...[indexN] (where index1,...,indexN is an expression for the index value, whose types are all
Int64). For example:
let array5 =[0,1]
let element0 =array5[ 0] // element0 = 0
array5[ 1]=10 // change the value of the second element of 'array5' through index
let array6 =[[0.1,0.2],[0.3,0.4]]
let element01 =array6[ 0][1]// element01 = 0.2
array6[ 1][1]=4.0 // change the value of the last element of 'array6' through index
Iterative access to elements in arrthrough for-inexpression (see Chapter Expressions). For example:
func access (){
let array8 =[1,8,0,1,0]
for (num inarray8) {
print( "${num}") // output: 18010
}
}
2.2.1.3 Accessing the size of Arrays
The number of elements in arrcan be got by arr.size .
let array9 =[0,1,2,3,4,5]
let array10 =[[0,1,2],[3,4,5]]
let size1 =array9.size // size1 = 6
let size2 =array10.size // size2 = 2
2.2.1.4 The slice of Arrays
When the expression of Range<Int64> type is used for array index, it indicates that intercepting a slice from
the array. It should be noted that:
•The step must be 1, otherwise an exception will be thrown when running.
•The type returned by slicing is still the same Arraytype and is a reference to the original Array.
Changes to the elements in the slice will affect the original array.
•When using start..end as an Arraysubscript, the value of startis set to 0ifstartis omitted, and
the value of endis set to the length of Arrayifendis omitted.
•When using start... =end as an Arraysubscript, if startis omitted, the value of startis set to 0.
•If the subscript is an empty rangevalue, then an empty array is returned.
let array7 =[0,1,2,3,4,5]
func slicingTest (){
array7[ 0..5] // [0, 1, 2, 3, 4]
array7[ 0..5:1] // [0, 1, 2, 3, 4]
array7[ 0..5:2] // runtime exception
array7[ 5..0:-1] // runtime exception
array7[ 5..0:-2] // runtime exception
array7[ 0..=5] // [0, 1, 2, 3, 4, 5]
array7[ 0..=5:1] // [0, 1, 2, 3, 4, 5]
array7[ 0..=5:2] // runtime exception
array7[ 5..=0:-1]// runtime exception
array7[ 5..=0:-2]// runtime exception
array7[.. 4] // [0, 1, 2, 3]
array7[ 2..] // [2, 3, 4, 5]
array7[..] // [0, 1, 2, 3, 4, 5]
array7[.. 4:2] // error: the 'range step' is not allowed here.
array7[ 2..:-2] // error: the 'range step' is not allowed here.
array7[.. :-1] // error: the 'range step' is not allowed here.
array7[ ..=4] // [0, 1, 2, 3, 4]
array7[ ..=4:2] // error: the 'range step' is not allowed here.
array7[ 0..5:-1] // runtime exception
array7[ 5..=0] // []
array7[.. 0] // []
array7[ ..=- 1] // []
let temp :Array <Int64 >=arr7[..]
temp[ 0]=6// temp == array7 == [6, 1, 2, 3, 4, 5]
}
When using slicing for assignment, two different uses are supported.
•If the type of the expression on the right side of =is the element type of the array, the value of this
expression will be used as an element to cover the elements of the slice range.
•If the type of =right expression is the same as the type of the array, the array will be copied to cover
the current slice range, which requires the size of the right expression to be the same as the slice range,
otherwise an exception will be thrown at runtime.
let arr =[1,2,3,4,5]
arr[..] =0
// arr = [0, 0, 0, 0, 0]
arr[ 0..2]=1
// arr = [1, 1, 0, 0, 0]
arr[ 0..2]=[2,2]
// arr = [2, 2, 0, 0, 0]
arr[ 0..2]=[3,3,3]// runtime exception
arr[ 0..2]=[4]// runtime exception
let arr2 =[1,2,3,4,5]
arr[ 0..2]=arr2[ 0..2]// ok
// arr = [1, 2, 0, 0, 0]
arr[ 0..2]=arr2 // runtime exception
arr[..] =arr2 // runtime exception
2.2.2 class Types and interface Types
See Chapter Class and Interface
2.3 Type Conversion
As a strongly typed language, Cangjie programming language supports only explicit type conversion (also
known as forced type conversion). For value types , using valueType(expr) to convert the type of exprto
thevalueType type. For classesand interfaces , type casting is achieved by using the asoperator (See The
as Operator ). For value types , we say valueTypeA tovalueTypeB is convertible, when rules for converting
valueTypeA tovalueTypeB is defined. Otherwise, valueTypeA tovalueTypeB is non-convertible. For classes
and interfaces , we say two types are convertible, if one type is the superclass (or subclass) of another type
in their class hierarchy (of course, the casting may also be fail). Otherwise, they are non-convertible.
The following describes the type conversion rules between value types and the type casting rules for
class/interface , respectively. For other types not mentioned, the type conversion between them is not
supported.
2.3.1 Type Conversion Between V alue Types
For numeric types , the following type conversion are supported (type conversions that are not listed below
are not supported):
1.Type conversion from ChartoUInt32.
2.Type conversion from integer types (i.e., Int8,Int16,Int32,Int64,IntNative ,UInt8,UInt16,UInt32,
UInt64and UIntNative ) to Rune.
3.Type conversion between all numeric types (including Int8,Int16,Int32,Int64,IntNative ,UInt8,
UInt16,UInt32,UInt64,UIntNative ,Float16,Float32and Float64).
The conversion of ChartoUInt32uses UInt32(e) , where eis an expression of type Charand the result of
UInt32(e) is the UInt32value corresponding to the Unicode scalar value of e.
The conversion of an integer type to Charis done by means of Rune(num) , where numcan be of any integer
type, and only if the value of numfalls in [0x0000, 0xD7FF] or[0xE000, 0x10FFFF] (i.e., the Unicode scalar
value), the character represented by the corresponding Unicode scalar value is returned; otherwise, a compile
error (the value of numcan be determined at compile time) is generated or a runtime exception is thrown.
main() {
var c:Rune ='a'
var num:UInt32 =0
num =UInt32 (c) // num = 97
num -=32 // num = 65
c=Rune (num) // c = `A`
return 0
}
For type safety, the Cangjie programming language does not support implicit type conversion between
numeric types. Note that types of numeric literals are inferred from the context. It is thus not considered
as implicit type conversion. To convert a value or a numeric type to another numeric type, explicit type
conversion must be used. That is, numericType(expr) converts the value of exprto the numericType type.
The grammar for type conversion between numeric types is defined as:
numericTypeConvExpr
: numericTypes '(' expression ')'
;
numericTypes
: 'Int8' | 'Int16' | 'Int32' | 'Int64' | 'IntNative' | 'UInt8' | 'UInt16' | 'UInt32' |
'UInt64' | 'UIntNative' | 'Float16' | 'Float32' | 'Float64' ↪
;
In the following, we introduce all forms of explicit type conversion supported in the Cangjie programming
language. We say that a type is bigger if more bits are required to encode a value of the type (e.g. Int16is
bigger than Int8) and smaller otherwise.
a)Bidirectional conversion between signed integers: A value is unchanged when it is converted from a
smaller type to a bigger type. When a value is converted from a bigger type to a smaller type, if the
valueis beyondthe range ofthe smaller type, then the overflowstrategy is determinedbythe attributed
macro used in the context (the default strategy is throwing exceptions), see Arithmetic Expressions
for details of the different overflow strategies. The following shows example conversions between Int8
and Int16using the strategy of throwing exceptions:
main() {
var i8Number :Int8 =127
var i16Number :Int16 =0
i16Number =Int16 (i8Number) // ok: i16Number = 127
i8Number =Int8 (i16Number) // ok: i8Number = 127
i16Number =128
i8Number =Int8 (i16Number) // throw an ArithmeticException
return 0
}
b)Bidirectional conversion between unsigned integers: The rules are the same as conversion between
singed integers. The following shows example conversions between UInt16and UInt32:
main() {
var u16Number :UInt16 =65535
var u32Number :UInt32 =0
u32Number =UInt32 (u16Number) // ok: u32Number = 65535
u16Number =UInt16 (u32Number) // ok: u16Number = 65535
u32Number =65536
u16Number =UInt16 (u32Number) // throw an ArithmeticException
return 0
}
c)Bidirectional conversion between floating-point types: the round-to-nearest mode is applied for round-
ing. The following examples illustrate the conversion between Float32and Float64:
main() {
var f32Number :Float32 =1.1
var f64Number :Float64 =0.0
f64Number =Float64 (f32Number) // f64Number = 1.100000023841858
f32Number =Float32 (f64Number) // f32Number = 1.1
f64Number =1.123456789
f32Number =Float32 (f64Number) // f32Number = 1.1234568
f32Number =4.4E38 // f32Number = POSITIVE_INFINITY
f64Number =Float64 (f32Number) // f64Number = POSITIVE_INFINITY
f64Number =4.4E38
f32Number =Float32 (f64Number) // f32Number = POSITIVE_INFINITY
f64Number =f32Number *0.0
f32Number =Float32 (f64Number) // f32Number = NaN
return 0
}
d)Bidirectional conversion between signed integers and unsigned integers: Note that the range of signed
integers are not contained in the range of unsigned integers with the same length, and vice versa.
Therefore, when a signed integer is converted to an unsigned one or the other way around, if the
value falls within the range of the target type, the conversion is successful. Otherwise, determine the
overflow strategy based on the attributed macro used in the context (the default strategy is throwing
exceptions), see Arithmetic Expressions for details of the different overflow strategies. The following
shows example conversions between between Int8and UInt8using the strategy of throwing exceptions:
main() {
var i8Number :Int8 =127
var u8Number :UInt8 =0
u8Number =UInt8 (i8Number) // ok: u8Number = 127
u8Number =100
i8Number =Int8 (u8Number) // ok: i8Number= 100
i8Number =-100
u8Number =UInt8 (i8Number) // throw an ArithmeticException
u8Number =255
i8Number =Int8 (u8Number) // throw an ArithmeticException
return 0
}
e)Bidirectional conversion between signed integers and floating point types: There are three cases. The
following conversions are always accurate: conversion from Int8toFloat16,Float32,Float64; conver-
sion from Int16toFloat32,Float64; conversion from Int32toFloat64. The following conversions may
result in loss of precision: conversion from Int16toFloat16; conversion from Int32toFloat32; and
conversion from Int64toFloat32 orFloat64. The following conversions may result in loss of preci-
sion and the result may be POSITIVE_INFINITY orNEGTIVE_INFINITY : conversion from Int32toFloat16;
conversion from Int64toFloat16.POSITIVE_INFINITY orNEGTIVE_INFINITY is returned when the value
exceeds the range of the target type. Furthermore, the sign is determined based on the original value.
When there is precision loss, the round-to-nearest mode is applied for rounding. Furthermore, the
conversion from floating-point to signed integer follows the round-toward-zero mode, i.e. the fractional
part is discarded. When the integer part is beyond the range of the target type, an exception is thrown.
In addition, when the value of a floating-point number is NaN,POSITIVE_INFINITY , or NEGTIVE_INFINITY ,
an exception is thrownwhen it is converted to a signed integer.
main() {
var i32Number :Int32 =1024
var f16Number :Float16 =0.0
var f32Number :Float32 =0.0
f16Number =Float16 (i32Number) // ok: f16Number = 1024.0
f32Number =Float32 (i32Number) // ok: f32Number = 1024.0
i32Number =2147483647
f16Number =Float16 (i32Number) // f16Number = POSITIVE_INFINITY
f32Number =Float32 (i32Number) // precision lost: f32Number = 2.14748365E9
f32Number =1024.1024
i32Number =Int32 (f32Number) // ok: i32Number = 1024
f32Number =1024e10
i32Number =Int32 (f32Number) // throw an ArithmeticException: (Int32)f32Number is not in
the range of Int32 ↪
f32Number =3.4e40 // f32Number = POSITIVE_INFINITY
i32Number =Int32 (f32Number) // throw an ArithmeticException
f32Number =3.4e40 *0.0 // f32Number = NaN
i32Number =Int32 (f32Number) // throw an ArithmeticException
return 0
}
f)Bidirectional conversion between unsigned integer types and floating point types: There are three cases.
The following conversions are accurate: conversion from UInt8toFloat16,Float32,Float64; conversion
from UInt16toFloat32,Float64; conversion from UInt32toFloat64. The following conversions may
result in loss of precision: conversion from UInt32toFloat32; and conversion from UInt64toFloat32
and Float64.The following conversions may result in loss of precision and the result may be infinity
(when the value is beyond the range of the target type): conversion from UInt16toFloat16; conversion
from UInt32toFloat16; and conversion from UInt64toFloat16. Similarly, when there is precision loss,
the round-to-nearest mode is applied for rounding. The conversion from floating point to unsigned
integer follows the round-toward-zero mode, i.e. the fractional part is discarded. When the floating-
point number is a negative number or the integer part is beyond the range of the target integer type, an
exception is thrown. In addition, when the value of a floating point number is NaN,POSITIVE_INFINITY ,
orNEGTIVE_INFINITY , an exception is thrown the behavior is undefined when it is converted to an
unsigned integer.
2.3.2 Type Conversion Between Class/Interface
For an instance of the class/interface , using obj as TargetType to cast its (static) type to TargetType .
See section The as Operator for the usuage of the asoperator and the type cast rules
2.4 Type Alias
In case the name of a type is too long or is not intuitive in a specific scenario, type aliases can be declared
to create a simple and intuitive alias for a special type. The syntax for type definition is:
typeAlias
: typeModifier? `type` identifier typeParameters? `=` type
;
In which, typeModifier is the optional modifier for accessibility ( public),typeis the keyword, and iden-
tifieris an arbitrary valid identifier, and typeis any type that is visible at top-level . The alias identifier
and the original type typeare connected with symbol =. Also, a generic type alias can be defined by adding a
list of type parameters (i.e., typeParameters in the above definition) after the alias identifier (refer to Chap-
ter 9 for generics). The above definition defines an alias of typewith the name identifier , i.e., identifier
and typeare treated as the same type. For example:
type Point2D =(Float64 ,Float64 )
type Point3D =(Float64 ,Float64 ,Float64 )
let point1 :Point2D =(0.5,0.8)
let point2 :Point3D =(0.5,0.8,1.1)
The above typedefinition does not define a new type. It just define another name for an existing type.
The alias and the original type are regarded as the same type, and the alias does not affect the use of the
original type.
2.4.1 Rules on type alias definition :
1.The type alias definition can only be defined at top-level .
func test (){
type Point2D =(Float64 ,Float64 ) // error: type alias can only be defined at
top-level ↪
type Point3D =(Float64 ,Float64 ,Float64 )// error: type alias can only be defined at
top-level ↪
}
2.When using typeto define a type alias for a (original) type, the original type must be visible at the
place where the typedefinition is defined.
class LongNameClassA {
}
type ClassB =LongNameClassB // error: use of undeclared type 'LongNameclassB'
3.When defining a generic type alias, if the type parameters in the alias are not appeared in the original
type, a compiler will report a warning.
type Class1 <V>=GenericClassA <Int64 ,V> // ok. ClassA is a generic class
type Class2 <Value, V >=GenericClassB <Int64 ,V>// warning: the type parameter 'Value' in
'Class2<Value, V>' is not used in 'GenericClassB<Int64, V>' ↪
type Int<T>=Int32 // warning: the type parameter 'T' in 'Int<T>' is
not used in `Int32` ↪
4.When defining a generic type alias, it is not allowed for adding generic constraints for type parameters
in the alias and the original type. The generic constraints can only be added when the generic type
alias is used. Moreover, the generic type alias naturally has the generic constraints in the original type.
type Class1 <V>where V <: MyTrait =GenericClassA <Int64 ,V>// error: generic constraints are not
allowed here ↪
type Class2 <V>=GenericClassB <Int64 ,V>where V <: MyTrait // error: generic constraints are not
allowed here ↪
type Class3 <V>=GenericClassC <Int64 ,V>
func foo<V>(p:Class3 <V>)where V <: MyTrait { // add generic constraints when
'Class3<V>' is used ↪
functionBody
}
class ClassWithLongName <T>where T<:MyTrait {
classBody
}
type Class <T>=ClassWithLongName <T> // Class<T> also has the constraint
'where T<:MyTrait' ↪
5.Circular reference (direct or indirect) are not allowed in one (or more) typedefinitions. In which, the
method of deciding circular reference is achieved by testing whether circular references exist by name,
rather than by using type expansion.
type Value =GenericClassAp <Int64 ,Value > // error: 'Value' references itself
type Type1 =(Int64 )->Type1 // error: 'Type1' references itself
type Type2 =(Int64 ,Type2) // error: 'Type2' references itself
type Type3 =Type4 // error: 'Type3' indirectlly references itself
type Type4 =Type3
6.The alias defined in the typedefinition is treated as a type who is same to the original type. In the
following example, parameters with Inttype and Int32type of can directly be added, as Intis defined
as the alias of Int32, but function overloading can not be achieved by using aliases for the definition
of function overloading):
type Int =Int32
let numOne :Int32 =10
let numTwo :Int =20
let numThree =numOne +numTwo
func add(left :Int, right :Int32 ):Int {left +right }
func add(left :Int32 ,right :Int32 ):Int32 {left +right } // error: invalid redeclaration
of 'add : (Int32, Int32)->Int32' ↪
7.By default, the typedefinition is internally accessible. When using the the alias defined in this package
in another package, the following two conditions must be met: (1) The accessibility of the original type
ispublic, and (2) The typedefinition is modified by publicmodifier. It should be noted that the alias
can have a different accessibility from the original type. However, the access level of the alias cannot
be higher than that of the original type.
// a.cj
package A
public class ClassWithLongNameA {
}
class ClassWithLongNameB {
}
public type classA =ClassWithLongNameA // ok
type classAInter =ClassWithLongNameA // ok
/* error: classB can not be declared with modifier 'public', as 'ClassWithLongNameB' is internal
*/ ↪
public type classB =ClassWithLongNameB
// b.cj
package B
import A.*
let myClassA :A.classA =ClassWithLongNameA()
2.4.2 Usage of type alias
A type alias can be used in any situation where the type on RHS of equality sign can be used:
1.It can be used as a type. For example:
type A=B
class B{}
var a:A=B() // Use typealias A as type B
2.If it is a type alias for class, struct, it can be used as a constructor
type A=B
class B{}
func foo(){A() }// Use type alias A as constructor of B
3.If it is a type alias for class, interface, struct, it can be used as a type name of its static member
variable or static function inside.
type A=B
class B{
static var b:int32 =0;
static func foo(){}
}
func foo(){
A.foo() // Use A to access static method in class B
A.b
}
4.If it is a type alias for enum, it can be used as a type name of data constructor of the enum declaration.
enum TimeUnit {
Day |Month |Year
}
type Time =TimeUnit
var a=Time.Day
var b=Time.Month // Use type alias Time to access constructors in TimeUnit
2.5 Relations between Types
There are two kinds of relations between types: equivalence and subtyping.
2.5.1 Type Equivalence
For any two types T1and T2, we say T1is equivalent to T2(denoted as 𝑇1 ≡ 𝑇2 ) if at least one of the
following conditions is satisfied:
•IfT1is defined by a type alias type T1 = T2 .
•Inside the definition of classand inside the extendofclass,T1is the name of classand T2isThis.
•The names of T1and T2are identical (reflexive property).
•𝑇2 ≡ 𝑇1 (symmetric property).
•There exists a type 𝑇𝑘which satisfies that 𝑇1 ≡ 𝑇𝑘 and𝑇𝑘 ≡ 𝑇2 (transitive property).
2.5.2 Subtyping
For any two types T1and T2, we say T1is the subtype of T2if at least one of the following conditions is
satisfied:
•If𝑇1 ≡ 𝑇2 .
•T1isNothingtype.
•T1and T2are Tupletypes, and the type of each element in T1is the subtype of the type of the
corresponding element in T2.
•T1and T2areFunction types, and the parameter type of T2is the subtype of the parameter type of T1
and the return type of T1is the subtype of the return type of T2.
•T1is any class/interface type, and T2is the Objecttype.
•T1and T2areinterface types, and T1inherits T2.
•T1and T2areclasstypes, and T1inherits T2.
•T1is a classtype and T2is an interface type, and T1implements T2.
•There exists a type 𝑇𝑘which satisfies that 𝑇1 <∶ 𝑇𝑘 and𝑇𝑘 <∶ 𝑇2 (transitive property).
2.5.3 Smallest Common Supertypes
In a type system with subtypes, there are cases where the least common parent of two types is required,
e.g. the type of an ifexpression is the least common parent of the types of its two branches, and a match
expression is similar.
The smallest common supertype of two types is the smallest of their common supertypes. Smallest
means that it is a subtype of all other common supertypes.
The smallest common supertype is defined as follows: for any two types T1and T2,LUBis the smallest
common supertype of T1and T2if the type LUBsatisfies the following:
•LUB <: T also holds for any type Tthat satisfies both T1 <: Tand T2 <: T.
Note that if LUBis no larger than the other common supertypes, then it is only necessarily the minimum
but just a minimal.
2.5.4 Greatest Common Subtypes
As there are cases of contra-variance in subtype relationships (see the Variance section under the Generics
chapter for definitions), such as the parameter type of a function type, the greatest common subtype of the
two types will be calculated.
The greatest common subtype of two types is the greatest of their common subtypes. Greatest means
that it is a supertype of all other common subtypes.
The greatest common subtype is defined as follows: for any two types T1and T2,GLBis the greatest
common subtype of T1and T2if the type GLBsatisfies the following:
•T <: GLB also holds for any type Tthat satisfies both T <: T1and T <: T2.
Note that if GLBis no smaller than the other common subtypes, then it is only necessarily the maximum
but just a maximal.Chapter 3
Names, Scopes, V ariables and
Modifiers
In this chapter, we first describe names, scopes and shadow. Finally, we will introduce one of the names -
variables, including variable definition and initialization, and finally, the modifiers.
3.1 Names
In the Cangjie programming language, we use namesto identify entities such as variables, functions, types,
packages and modules.
The name must be a valid [Identifier].
Keywords, variables, functions, types(including class,interface ,struct,enum, and type alias ), packages
and modules in the Cangjie programming language share the same name spaces. A name uniquely represents
one entity in any scope. That is, entities in the same scope are not allowed to have the same name, except
the names that make up overloading. Entities in different scopes may have the same name. If their scopes
overlap, the name of the lower-level scope shadows the name of the higher-level scope.
let f2=77
func f2(){// Error￿ function name is the same as the variable f2
print( "${f2}")
}
// Variable, function, type names cannot be the same as keywords
let Int64 =77 // Error: 'Int64' is a keyword
func class (){// Error: class is a keyword
print( "${f2}")
}
main() :Int64 {
print( "${f2}") // Print 77
let f2={=>// Shadowed the global variable f2
print( "10" )
}
f2()
return 1
}
3.2 Scopes
3.2.1 Blocks
In Cangjie, an optional sequence of expressions and declarations with the enclosing pair of curly brackets
form a block. Blocks are pervasive; for example, the bodies of function definitions, the two branches of if
expressions, and the bodies of while loops are all blocks. Blocks introduce new scopes.
The syntax of block is:
block
: '{' expressionOrDeclarations '}'
;
Blocks have their values. The value of a block is determined by the sequence of expressions and declara-
tions within it. When evaluating the value of a block, the expressions and declarations are processed in the
order in which they are declared in the block.
If the last item of the block is an expression, the value of the expression is the value of the block when
the expression is evaluated:
{
let a=1
let b=2
a+b
}// The value of the block is a + b
If the last item of the block is a variable declaration, the value of the block is ()when the variable
declaration is processed:
{
let a=1
}// The value of the block is ()
If the block does not contain any expression or statement, the value of the block is ():
{}// The value of this empty block is ()
3.2.2 Scope level
The scopeof a name is the part of the program where the name can be used to refer to the entity, without
any qualifier, provided that the name is not shadowed.
Scopes are nested. Names in its nested scope can be accessed directly by using the name without any
qualifier, if they are not shadowed or overridden.
Before presenting rules of scoping, we define the scope level of names using the following rules:
1.Names from other packages introduced by importclause have the lowest scope level.
2.Names defined at the top-level of the same package have higher scope level than the names in rule 1.
3.Names introduced inside a type or a block, whose defition is usually enclosed in a pair of curly braces {}
(i.e., a block), have higher scope level than the names outside the curly braces. Equivalently speaking,
every time a block that is enclosed in a pair of braces {}is entered, the scope level of the names defined
in the block is increased.
4.For classes and interfaces, the name in this class is at a higher level of scope than the name in the
superclass. The name in a subclass may shadow or override the name in the superclass.
import p1.a // a has the lowest scope level
var x=1 // x 's scope level is higher than p1.a
open class A{ // A's scope level the same as x at line 3
var x=3 // This x has higher scope level than the x at line 3
var y='a'
func f(a:Int32 ,b:Float64 ):Unit {
}
}
class B<:A {
var x=5 // This x has higher scope level than the x at line 6
func f(x!:Int32 =7){// This x's scope level is higher than the x at line 14
}
}
3.2.3 Scope principle
Based on where the names are declared or defined, we distinguish three types of scopes: top-level, local-level,
and type-internal. These three types of scopes have different scope principles, as we illustrate below.
3.2.3.1 Top-level
Names declared or defined at the top-level of a source file (i.e., not enclosed in {}) have top-level scope. The
following rules apply to names with top-level scope.
•The scope of top-level functions, types (including class,interface ,enum,struct, and type) is the entire
package, and thus they are accessible in the entire package.
•Top-level variables, whose names are introduced by letand varare only accessible after they are
defined (including the initialization) in the same source file, but in the other files of the same package
can be accessible. They must be defined and initialized before they are used.
/* Global variables can be accessed only after defined. */
let x=y //Error: y is used before being defined
let y=4
let a=b //Error: b is used before being defined
let b=a
let c=c //Error: unresolved identifier 'c' (in the right of '=')
//Function names are visible in the entire package
func test (){test2() } // OK
func f(){test() }// OK
func test2 ():Int64 {
var x=99
return x
}
3.2.3.2 Local-level
Names defined inside a function definition or an expression have local-level scope. The variables defined
within a block has higher level of scope than the ones defined outside. The following rules apply for local-
level names.
•The scope of local variables starts after the variable declaration and ends with the closing of the block.
A variable must be defined and initialized before being used. If the name of the local variable is the
same as an entities defined in an upper-level scope, the upper-level entity is shadowed whenever the
local variable is accessible.
•Local function scope starts after the function defined and ends with the closing of the block. As a
result, mutual recursion is not supported, but can call itself recursively.
•Names are inaccessible beyond its scope. For instance, local-level names are inaccessible beyond its
containing block, and types defined in a block are inaccessible beyond its containing block (e.g., a type
defined in a class cannot be the return-type of a public function of the class).
•The scope of a function type parameters and parameters start after the parameters defined and ends
with the closing of the function body. Its scope level is the same as the variables defined in the function
body.
–Function defined as func f (x: Int32, y!: Int32 = x) { } is valid.
–Function defined as func f (x!: Int32 = x) { } is invalid.
•The scope of type parameters introduced when a generic type is declared or extension is defined start
from the declaration of type parameters to the end of the type body or extension body. The scope
level is the same as the names defined in the type.
–The scope of Tin a generic type definition class C<T> {} starts from Tto the end of the declaration
ofclass C.
–The scope of Tin the extension extend C<T> {} is from the occurrence of Tto the end of extension
definition.
•The scope of the parameters of lambda expressions is similar to that of function parameters. For
instance, their scope level is the same as the variables defined in the body of the lambda expression.
•The scope of the names introduced in patterns of the match case is higher than that of the match
expression. The scope starts from the name introduced to the end of the match case. Each match case
has an independent scope.
•For all three types of loops, the loop condition has the same scope level as the loop block, i.e. the
names introduced therein must not shadow each other. And it is additionally specified that the loop
condition cannot refer to a variable defined in the loop body. Then we have the following corollary:
–For for-inexpressions, their loop bodies can refer to the names of variables introduced in the
loop condition.
–Forwhileand do-while expressions, neitherof theirloop conditionscan refer tothe variablenames
introduced in their loop bodies, even if the loop condition for do-while comes later then the loop
body.
•For exception handling expressions, the tryblock, each catchblock and the finally block are considered
different blocks. As a result, variable defined in the tryblock or catchblocks are not accessible in the
finallyblock.
•As for try-with-resources expressions: name introduced between tryand {}. Its scope starts after the
declaration and ends with the try-with-resources expression.
// a: The scope of a local variable begins after the declaration
let x=4
func f():Unit {
print( "${x}")// Print 4
let x=99
print( "${x}")// Print 99
}
let y=5
func g():Unit {
let y=y // 'y' in the right of '=' is the global variable 'y'
print( "${y}")// Print 5
let z=z // Error: unresolved identifier 'z' (in the right of '=')
}
// b: The scope of a local function begins after definition
func test1 ():Unit {
func test2 ():Unit {
print( "test2" )
test3() // Error￿test3's scope is begin after definition
}
func test3 ():Unit {
test2()
}
test2()
}
let score :Int64 =90
let good =70
var scoreResult :String =match (score) {// binding pattern
case 60=>"pass" // constant pattern.
case 100 =>"Full" // constant pattern.
case good =>"good" // This good has higher scope level than the good at line 2
}
3.2.3.3 Type-internal
•The scope of classes/interface/struct ’s members is the entire class/interface/struct definition.
•The scope of the type’s type parameter starts after the type parameter declaration and ends with the
closing of the type.
•The scope of the enumconstructor names is in the entire enumdefinition. More detailed description of
enumconstructors are in enum Type .
3.2.4 Shadowing
When two scopes overlap and the same name appears in both scopes, the name in the lower-scope shadows
the name in the upper-scope. As a result, the entity referred to by the name in the lower-scope cannot be
accessed directly through the name. Note that shadowing ends when the lower-scope ends.
•If the name Cis a type, the type in the upper-scope is shadowed.
•If the name xis a variable, the variable in the upper-scope is shadowed.For specific rules on masking
of member variables, see Shadowing .
•If the name pis a package name, the variable in the upper-scope is shadowed.
•If the name fis a non-static member function in a class or interface, fmay be overloaded based on
the overloading rule. If fis not overloaded, override may occur. If no overload occurs and cannot be
overridded, an error is reported. For details, see [Overriding].
•If the name fis a top-level function, fcan be either overloaded based on the overloading rule or
shadowed.
The following example illustrate shadowing on variables in different scenarios.
func g():Unit {
f(1,2)// OK. f is a top-level definition, which is visible in the whole file
}
func f(x:Int32 ,y:Int32 ):Unit {
// Error. Term Maze shadows the type Maze, the Maze cannot be used as a type
// let Maze : Maze
// var x = 1 // Error￿x was introduced by parameter
var i=1 // OK
for (iin1..3){// OK, a new i in the block
let v=1
} // i and v disappear
print( "${i}") // OK. i is defined at line 9
// print("${v}") // Error￿v disappeared and cannot be found
}
enum Maze {
C1|C2
// | C1 // Error. The C1 has been used
}
The following examples illustrate shadowing across different packages.
// File a.cj
package p1
class A{}
var v:Int32 =10
// File b.cj
package p2
import p1.A // A belongs to the package p1
import p1.v // v belongs to the package p1
// p2 has defined its own v, whose scope level is higher than the v from package p1
var v:Int32 =20
func displayV1 ():Unit {
// According to the scope level, p2.v shadows p1.v, therefore access p2.v here
print( "${v}") // output: 20
}
var a=A() // Invoke A in p1
The following example shows shadowing due to inheritance.
var x=1
open class A{
var x=3 // this x shadows the top level x
}
class B<:A {
var x=5 // this x shadows the top level x and the x in super class
func f(x!:Int32 =7):Unit {// this x shadows all the previous x
}
}
3.3 V ariables
As a statically typed language, the Cangjie programming language requires that the type of each variable
must be determined during compilation.
Variables can be classified into the following types based on whether they can be modified: immutable
variables (whose value cannot be modified once initialized) and mutable variables (whose values can be
modified).
3.3.1 Definition of V ariables
The syntax of variable definition is as follows.
variableDeclaration
: variableModifier* ('let' | 'var') patternsMaybeIrrefutable ( (':' type)? ('=' expression)
| (':' type))
;
patternsMaybeIrrefutable
: wildcardPattern
| varBindingPattern
| tuplePattern
| enumPattern
;
The declaration of variables includes four parts: modifiers, let/varkeyword , patternsMaybeIrrefutable,
and a variable type.
1.Modifier
•The modifiers of top-level variables include public.
•Local variables cannot be modified with modifiers.
•The modifiers of member variables of the class type are as follows: public,protected ,pri-
vate,static
•The modifiers of member variables of the struct type include static.
2.let/var
•letis used to define immutable variables. Once initialized, a let variable cannot be changed.
•varis used to define mutable variables.
3.patternsMaybeIrrefutable
•let(orvar) can only be followed by patterns that must or may be irrefutable (seeClassification
of Patterns ). At the semantic check stage, it is checked whether the pattern is actually irrefutable ,
if not, it is a compile-time error.
•Thenewvariablesintroducedinthepatternafter let(orvar)areall let-modified(or var-modified)
variables.
•When defining member variables in classes and structs, only the binding pattern can be used (see
Binding Patterns ).
4.Variable type
•The variable type is optional. If the variable type is not declared, you need to assign an initial
value to the variable. The compiler attempts to infer the variable type based on the initial value.
5.Variables can be defined in the top-level, expression, or class/struct type.
Note the following:
•When the variable type is specified, a colon ( :) must be used between the pattern and the type.
Otherwise, the type is inferred by the compiler. The type of the pattern needs to match the type after
the colon.
•The keyword let/varand the pattern are mandatory.
•In addition to the preceding syntax definitions, local variables may be introduced in the following
scenarios:
–pattern between forand inin the for-in loop expression. For details, see The for-in Expression .
–Parameters in function and lambda definitions. For details, see Parameters .
–Resource specifications in the try-with-resource expression. For details, see Exceptions
–Pattern after case in the match expression. For details, see Pattern Matching Expressions .
–To use keywords as variable names, a pair of backticks ( `)s must be used (such as `open`and
`throw`).
let b:Int32 // Define read-only variable b with type Int32.
let c:Int64 // Define read-only variable c with type Int64.
var bb:String // Define writeable variable bb with type String.
var (x, y):(Int8 ,Int16 )// Define two writeable variable: x with type Int8, x with type Int16.
var `open` =1 // Define a variable named `open` with value 1.
var `throw` ="throw" // Define a variable named `throw` with value "throw".
3.3.2 Initialization of V ariables
3.3.2.1 let and var
There are two ways of initializing variables: initialization during declaration and initialization after decla-
ration. Note that each variable must be initialized before being used. Otherwise, a compilation error is
reported.
func f(){
let a=1 // Define and initialize immutable variable a.
let b:Int32 // Define immutable variable b without initialization.
b=10 // Initialize variable b.
var aa:Float32 =3.14 // Define and initialize mutable variable aa.
}
Immutable variables can be assigned only once for initialization. If an immutable variable is assigned
multiple times, a compilation error is reported. Mutable variables can be assigned multiple times.
func f(){
let a=1 // Define and initialize immutable variable a.
a=2 // error: immutable variable a cannot be reassigned.
var b:Float32 =3.14 // Define and initialize mutable b.
b=3.1415 // ok: mutable variable b can be reassigned.
}
class C{
let m1:Int64
init (a:Int64 ,b:Int64 ){
m1=a
if(b>0){
m1=a*b// OK: immutable variable can be reassigned in constructor.
}
}
}
3.3.2.2 Initializing Global Variables and Static Variables
Variables defined at the top-level are called global variables. Static variables include static variables defined
in class or struct. The initialization of global variables and static variables must meet the following rules:
- Declaration of a global variable must initialize it immediately. That is, the declaration must provide an
initialization expression and be in the form of let v = e orvar v = e . - Declaration of a static variable must
initialize it either immediately, in the same way as for global variables which is described above, or in a static
initializer (see Static initializers section for more details). - Note that static variables couldn’t be initialized
within other static variables: cangjie class Foo { static let x: Int64 static
let y = (x = 1) // it's forbidden }- Initialization expression ecannot depend with uninitialized
global or static variables. The compiler performs a conservative analysis and considers that emay access
uninitialized global variables and static variables then reports an error. The detailed analysis depends on
the implementation of the compiler and is not specified in the specification.
When and how are global/static variable initializations executed? a. All global/static variables are
initialized before the execution of the main(the entry point);
b.For global/static variables declared in the same file, the initialization executes from the top to the
bottom, or according to the initialization order rules for a static initializer if a static variable is
initialized there (see Static initializers section for more details);
c.For variables declared in different files of the same package, or in different packages, the initialization is
done following the dependence relation between files (or packages). The initialization order (together
with our rules for initialization below) ensures that, if the initialization of a variable in File A (or
PackageA)reliesondeclarations(variables,functions,typeconstructors,etc.) inotherfilesorpackages,
then the initialization of global variables in these files or packages are executed before the initializations
in File A (Package A);
d.Note that the initialization order between files/packages doesn’t form a total order. If there are circular
dependencies or no dependency between files/packages, then the initialization order between them is
non-deterministic and depends on implementation.
/* The initialization of the global variable cannot depend on the global
variables defined in other files of the same package. */
// a.cj
let x=2
let y=z // OK, b.cj does not depend on this file directly or indirectly.
let a=x // OK.
let c=A()
/* c.f is an open function, the compiler cannot statically determine whether the
function meets the initialization rules of global variables, and an error will
be reported. */
let d=c.f() // Error.
class A{
// static var x = A.z // Error, A.z is used before its initialization.
// static var y = B.f // Error, B.f is used before its initialization.
static var z=1
open func f():Int64 {
return 77
}
}
class B{
static var e=A.z // OK.
static var f=x // OK.
}
// b.cj
let z=10
// let y = 10 // Error, y is already defined in a.cj.
// main.cj
main() :Int64 {
print( "${x}")
print( "${y}")
print( "${z}")
return 1
}
3.4 Modifiers
Cangjie provides a number of modifiers, which fall into the following two main categories.
•Access modifiers
•Non-access modifiers
The modifier is usually placed at the front of the definition to indicate that the definition has certain
characteristics.
3.4.1 Access modifiers
In Cangjie, access modifiers can be used to protect access to elements such as types, variables, functions, etc.
Cangjie supports 4 different kinds of access rights.
3.4.1.1 Default access modifier
Default access modifier, without any keyword modifiers.
Members declared with the default access modifier are visible to members within the same package.
Note: Members not modified with keywords are inaccessible outside the package.
// package pkg1
class A{
var v=0
}
let b=A().v // ok
// package pkg2
import pkg1 .*
func f(){
b=0// error, can not find b
}
3.4.1.2 Private Access Modifiers
The private access modifier privateis the most restrictive access level.
Members declared as privatecan only be accessed within the current scope.
Note: privatecannot modify top-level members.
class A{
private var v=0
}
let b=A().v // error
3.4.1.3 Public access modifiers
The public access modifier publicis the most lenient access level.
Members declared as publicare accessible in all scopes.
Note: public-modified top-level members are also accessible outside the package.
// package pkg1
public var v=0
public class A{
public var v=0
}
// package pkg2
import pkg1 .*
func f(){
v=2// ok
let a=A()
a.v =2// ok
}
3.4.1.4 Protected access modifier
The protected access modifier protected is an access level between default and public.
The members declared as protected can be accessed not only inside the package, but also outside the
package for the current class subclasses.
Note: protected cannot modify top-level members.
// package pkg1
public open class A{
protected var v=0
}
// package pkg2
import pkg1 .*
func f(){
let a=A()
a.v =2// error, can not find v
}
class B<:A {
func f(){
v=2// ok
}
}
3.4.2 Non-access modifiers
Cangjie provides a number of non-access modifiers to support other rich features.
•openindicates that the instance member can be overridden by a subclass, or that the class can be
inherited by a subclass, See classfor details
•sealedmeans that the class or interface can only be inherited or implemented in the current package,
Seeclassfor details
•override means overriding a member of the parent class, See classfor details
•redefmeans redefine the static members of the parent class, See classfor details
•staticmeans that the member is a static member, and static members cannot be accessed through
instance objects, See classfor details
•abstract means the class is an abstract class, See classfor details
•foreign indicates that the member is an external member, See Multi-language Interoperability for
details
•mutindicates that the member is of mutable semantics, See function for details
•operator indicates that the function is an operator overload function, See Operator Overloading for
details
The specific functions of these modifiers are detailed in the corresponding sections.Chapter 4
Expressions
An expression can consist of one or more operands, acted on by zero or more operators. Every expression
has a type. The process of calculating the value of an expression is called the evaluation of the expression.
In the Cangjie programming language, expressions are almost ubiquitous, including expressions for var-
ious calculations (such as arithmetic expressions, logical expressions, etc.), branches and loops (such as if
expressions, loop expressions, etc.). Expressions can be composed into composite expressions. If a expres-
sion contains multiple operators, it is necessary to specify the precedence, associativity and evaluation order
of the operators. Note that different precedence, associativity or evaluation order may result in different
evaluation values of the expression.
The following will successively introduce expressions in the Cangjie programming language.
Note: In this chapter, the specification for the type of operands for each operator is based on the
assumption that the operator is not overloaded.
4.1 Literals
A literal is an expression with a fixed syntax. For literals that contain no other expressions internally (see
section 1.3 Literals for details), their value is the literals themselves, and their type can be determined
by their syntax (for numeric type literals, the type is determined by the program context). For collective
literals and tuple literals (see Value Types ), whose value is the value of the literal obtained by evaluating all
expressions within it, and whose type is determined by its syntax.
Literal examples:
main() :Int64 {
10u8 // UInt8 literal
10i16 // Int16 literal
1024 u32 // UInt32 literal
1024 // Int64 literal
1024.512_ f32 // Float32 literal
1024.512 // Float64 literal
'a' // Rune literal
b'a' // Character byte literal, it has UInt8 type
true // Bool literal
"Cangjie" // String literal
b"Cangjie" // Byte string array literal, it has Array<UInt8> type
() // Unit literal
[1,2,3] // Array<Int64> literal
(1,2,3) // (Int64, Int64, Int64) literal
return 0
}
4.2 V ariable Names and F unction Names
The variable name and the function name themselves (including variables or functions referred to by package
names) are also expressions. For a variable name, its value is the value of the variable after it has been
evaluated, and its type is the type of the variable. For a function name, its value is a closure (see Section
5.7), and its type is the corresponding function type.
Examples of variable names and function names:
let intNum :Int64 =100 // 'intNum' is the name of a variable, whose value and type are '100' and
'Int64', respectively. ↪
/* 'add' is the name of a function, whose value and type are '(p1: Int64, p2: Int64) => {p1 +
p2}' and '(Int64, Int64) -> Int64', respectively. */ ↪
func add(p1:Int64 ,p2:Int64 ){
p1+p2
}
let value =p1.x // x is a variable defined in package p1.
For variable names, it is specified that variables declared by varare always mutable and that variables
declared by letmay only be assigned once (at or after its declaration), before the assignment it is mutable
and after the assignment it is immutable .
Note: Theinstancemembervariablesofstructandclassarealways mutable intheirconstructors,
regardless of whether they are declared with letorvar.
Cangjie supports first-class functions(See chapter 5). Also, it supports generics functions(See chapter
9) to declare type parameters. In this situation, generic function names can be used as expressions if type
arguments are given. For example:
func identity <T>(a:T){// identity is a generic function
return a
}
var b=identity // error: generic function 'identity' needs type arguments
var c=identity <Int32 >// ok: Int32 is given as a type argument
identity is a generic function, so identity is not a legal expression itself. identity<Int32> is a legal
expression since all type arguments are given.
If a function is overloaded in current scope, no matter it is a generic function or not, it is ambigous to
use its function name as an expression. For example:
func add(i:Int64 ,j:Int64 ):Int64 {
return i+j;
}
func add<T>(i:T,j:T):Twhere T <: Add {
return i+j;
}
main() :Int64 {
var plus =add // error: ambiguous function 'add'
return 0
}
4.3 Conditional Expressions
Conditional expressions (i.e., if expressions) facilitate the execution of different branches based on whether
certain condition is satisfied or not.
The syntax of the if expression is defined as follows.
ifExpression
: 'if' '(' ('let' deconstructPattern '=')? expression ')' block ('else' ( ifExpression |
block))? ↪
;
In above, ifis the keyword and it is followed by an expression in parentheses, then followed by a block
(see Section 4.15) and an optional elsebranch. The elsebranch begins with the elsekeyword, followed by
a new ifexpression or a block.
Examples of ifexpressions:
main() :Int64 {
let x=100
// if expression without else branch
if(x>0){
print( "x is larger than 0" )
}
// if expression with else branch
if(x>0){
print( "x is larger than 0" )
}else {
print( "x is not larger than 0" )
}
// if expression with nested if expression
if(x>0){
print( "x is larger than 0" )
}else if(x<0){
print( "x is lesser than 0" )
}else {
print( "x equals to 0" )
}
return 0
}
The ifexpression first evaluates the expression (requires it has type Bool) that follows if. If the value
of the expression is equal to true, the block following the condition part is executed; otherwise, the if
expression or the block (if exists) following the elsekeyword is executed. The value of the ifexpression is
equal to the value of the expression in the branch that be executed.
For ifexpressions that contain let, we call them if-letexpressions. We can use if-letexpressions to
do some simple deconstruction operations.
An example of a basic if-letexpression.
main() :Int64 {
let x:Option <Int64 >=Option <Int64 >.Some( 100)
// if-let expression without else branch
if(let Some(v) <-x){
print( "x has value" )
}
// if-let expression with else branch
if(let Some(v) <-x){
print( "x has value" )
}else {
print( "x has not value" )
}
return 0
}
The if-letexpression first evaluates the expression after <-(which can be of any type), and if the value of
the expression matches the pattern after let, then the block after it is executed, otherwise the ifexpression
after elseor the block after it (if it exists) is executed. The value of the if-letexpression is equal to the
value of the expression in the branch to which it is executed.
The pattern after letsupports constant pattern, wildcard pattern, variable binding pattern, Tuple pat-
tern, and enum pattern.
type of ifexpression
For ifexpressions without elsebranch, its type is Unitand its value is (). This is because if expr1
{expr2}is the syntactic sugar of if expr1 {expr2; ()} else {()} .
For ifexpressions containing elsebranches:
•When ifexpression is not read or returned, then the type of the ifexpression is Unit, and the two
branches’ types are not required to have common supertype; otherwise check types as below;
•When the context does not require some specific type, if the two branch types of ifexpression are T1
and T2, then the type of the ifexpression is the least common supertype TofT1and T2. If the least
common super type does not exist, a compilation error is reported.
•When the context does require a specific type, then both branches of the ifexpression must be a
subtype of the specific type required by the context.
Examples:
struct S1{}
struct S2{}
interface I1{}
class C1<:I1 {}
class C2<:I1 {}
interface I2{}
class D1<:I1&I2
class D2 <:I1&I2
func test12() {
if(true ){// OK. The type of this if expression is Unit.
S1()
}else {
S2()
}
if(true ){// OK. The type of this if expression is Unit.
C1()
}else {
C2()
}
return if(true ){// Error. The `if` expression is returned. There is no least common
supertype of `D1` and `D2`. ↪
D1()
}else {
D2()
}
}
Note that in order to avoid the dangling-else problem, the “body” of the ifand elsebranch must be a
block (even if it only contains only one expression) , i.e., enclosed with a pair of braces. (The dangling else
problem is the problem of not being able to determine whether the else expr2 in a code such as if cond1
if cond2 expr1 else expr2 belongs to the inner ifor the outer if. If it belongs to the inner if, the code
should be interpreted as if cond1 (if cond2 expr1 else expr2) ; if it belongs to the outer if, the code should
be interpreted as if cond1 (if cond2 expr1)expr2 . However, this is not a problem if we force to use curly
brackets for the branches.)
4.4 Pattern Matching Expressions
With matchexpressions, theCangjieprogramminglanguagesupportsapowerful pattern matching mechanism
that facilitates concise syntax for achieving complex control flow. Intuitively, a pattern represents a set of
instances that exhibit the pattern. Pattern matching is to decide whether a given instance belongs to the
set. There are only two matching results, i.e., succeed or fail. There are two kinds of matchexpressions:
matchexpressions with selector and matchexpressions without selector . The syntax of a matchexpression
is defined as follows.
The syntax of a matchexpression is defined as follows.
matchExpression
: 'match' '(' expression ')' '{' matchCase+ '}'
| 'match' '{' ('case' (expression | '_') '=>' expressionOrDeclaration+)+ '}'
;
matchCase
: 'case' pattern ('|' pattern)* patternGuard? '=>' expressionOrDeclaration+
;
patternGuard
: 'where' expression
;
For the matchexpression with a selector , the expression after the keyword matchis the selector to be
matched. Within {}after selector , a number of matchCase s can be defined, each starting with the keyword
case, followed by a patternor a sequence of patterns of the same kind separated by |(see the Patterns
section for detailed definitions of different pattern), an optional pattern guard , a double arrow =>and a
series of (at least one) declarations or expressions (multiple declarations or expressions are separated by
semicolons or newline characters).
When the match expression is evaluated, the patterns are matched one-by-one in the order defined by
the cases. Whenever the selector successfully matches a pattern(and its the pattern guard is satisfied),
the code after =>is executed. Note that the remaining patterns are not matched afterwards. The following
example shows how to use the constant pattern for pattern matching.
let score :Int64 =90
var scoreResult :String =match (score) {
case 0=>"zero"
case 10|20|30|40|50=>"fail"
case 60=>"pass"
case 70|80=>"good"
case 90|100 =>"excellent" // matched
case _=>"not a valid score"
}
For safety, it is required that the patterns (together with the pattern guards) in a cases should be
exhaustive for selector , i.e., there is a match for every value of selector . A compilation error is reported if
the patterns are not exhaustive. An easy way of ensuring exhaustiveness is to use the wildcard pattern (i.e.,
_) as the last casepattern so that it always covers the remaining patterns. Note that the patterns are not
necessarily mutually exclusive.
For matchexpressions without selector , there is no expression after the keyword match, and for each
casein{}, there can only be one expression of type Boolbetween the keyword caseand =>(or the wildcard
_, which means always true).
In the process of execution, the expression after caseis evaluated one-by-one. Once the value of the
current expression is true, the code after =>is executed, and remaining cases will not be evaluated. Actually,
thematchexpression without selector is a concise form of a series of nested if-else if expressions.
Similarly, matchexpressions without selector are required to be exhaustive (i.e. at least one caseis
satisfied). The compiler will try to do an exhaustive check, and if it cannot determine this, it will report an
error and prompt for a case _.
let score =80
var result :String =match {
case score <60=>"fail"
case score <70=>"pass"
case score <90=>"good" // matched
case _=>"excellent"
}
Similar to ifexpressions, the types of matchexpressions follow the following rules regardless whether
they have selector s or not:
•When matchexpression is not read or returned, then the type of the matchexpression is Unit, and the
branches’ types are not required to have common supertype; otherwise check types as below;
•When the context does not require some specific type, assuming that the branch types of the match
expression are T1, ..., Tn , then the type of the matchexpression is the least common supertype Tof
T1, ..., Tn . If the least common super type does not exist, a compilation error is reported.
•When the context does require a specific type, then all cases of the matchexpression must be a subtype
of the specific type required by the context.
4.4.1 Patterns
The Cangjie programming language supports a rich set of patterns as follows:
1.constant patterns.
2.wildcard pattern.
3.binding patterns.
4.tuple patterns.
5.type patterns.
6.enum patterns.
The syntax of patterns is defined as follows.
pattern
: constantPattern
| wildcardPattern
| varBindingPattern
| tuplePattern
| typePattern
| enumPattern
;
4.4.1.1 Constant Patterns
Constant patterns can be integer literals, character byte literals, floating point literals, character literals,
boolean literals, string literals (string interpolation is not supported), Unit literals. The literal in the
constant pattern needs to be of the same type as selector . A selector matches a constant pattern only if
the value of the selector is equal to the value of the literal in the pattern.
The syntax of constant patterns is as follows.
constantPattern
: literalConstant
;
The following show examples of constant patterns.
func f(){
let score :Int64 =90
var scoreResult :String =match (score) {
case 0=>"zero"
case 10|20|30|40|50=>"fail"
case 70|80=>"good"
case 90=>"excellent" // matched
case _=>"not a valid score"
}
}
Note that floating point literal matching in constant mode follows the same rules as floating point equiv-
alence, and will have the same precision problems as equivalence.
Character byte literal actually is unsigned 8-bit integer, so it can be used as patterns in a patter match
expression, for example:
func unhex (c:Byte) :Byte {
match {
case b'0' <=c&&c<=b'9' =>c-b'0'
case b'a' <=c&&c<=b'f' =>c-b'a' +10
case b'A' <=c&&c<=b'F' =>c-b'A' +10
case _=>0
}
}
Byte string array literals cannot be used as patterns in pattern match expressions.
4.4.1.2 Wildcard Patterns
A wildcard pattern is written as _, which matches any value. It is typically used as the last pattern in a
match expression to match “all other” cases.
The syntax of the wildcard pattern is as follows.
wildcardPattern
: '_'
;
The following is an example of the wildcard pattern:
let score :Int64 =90
var scoreResult :String =match (score) {
case 60=>"pass"
case 70|80=>"good"
case 90|100 =>"excellent" // matched
case _=>"fail" // wildcard pattern: used for default case
}
4.4.1.3 Binding Patterns
Like the wildcard pattern, a binding pattern matches any value. Unlike the wildcard pattern, a binding
pattern binds the matched value to a variable specified in the binding pattern, which can be accessed in the
expression after =>.
The syntax of binding patterns is as follows.
varBindingPattern
: identifier
;
The variable specified in the binding pattern is immutable.
The following illustrates how binding patterns are used.
let score :Int64 =90
var scoreResult :String =match (score) {
case 60=>"pass"
case 70|80=>"good"
case 90|100 =>"excellent" // matched
case failScore => // binding pattern
let passNeed =60-failScore
"failed with ${failScore }, and ${passNeed }need to pass"
}
The variable specified in the binding pattern have a scope from its first occurrence to the next case. Note
that binding pattern is not allowed to be used in patterns connected by |, nor can they be nested in other
patterns, otherwise a compiler error will be reported.
let opt =Some( 0)
match (opt) {
case x|x=>{} // error: variable cannot be introduced in patterns connected
by '|' ↪
case Some(x) |Some(x) =>{} // error: variable cannot be introduced in patterns connected
by '|' ↪
case x:Int64 |x:String =>{}// error: variable cannot be introduced in patterns connected
by '|' ↪
}
4.4.1.4 Tuple Patterns
Tuple patterns are used to match tuples. A tuple pattern is written in the form of multiple patterns enclosed
in a pair of parentheses, i.e., (pattern_1, pattern_2, ... pattern_k) . For example, (x, y, z) is a tuple
pattern consisting of three binding patterns, and (1, 0, 0) is a tuple pattern consisting of three constant
patterns. The number of patterns in the tuple pattern needs to be of the same as the dimension of the
selector . Moreover, if the patternin the tuple pattern is a constant pattern or an enum pattern , it needs
to has the same type as the corresponding element of the selector .
The syntax of the tuple pattern is as follows.
tuplePattern
: '(' pattern (',' pattern)+ ')'
;
The following is an example tuple pattern.
let scoreTuple =("Allen" ,90)
var scoreResult :String =match (scoreTuple) {
case ("Bob" ,90)=> "Bob got 90"
case ("Allen" ,score) => "Allen got ${score }"// matched
case ("Allen" ,100)|("Bob" ,100)=> "Allen or Bob got 100"
case (_,_)=> ""
}
4.4.1.5 Type Patterns
Type patterns are primarily used to check and/or cast the type of certain variable. The syntax of type
patterns is as follows.
typePattern
: (wildcardPattern | varBindingPattern) ':' type
;
For the type pattern varBindingPattern: type (orwildcardPattern : type ). A type pattern is successfully
matched only if the variable to be matched is of type typeor its subtype. In the latter case, the variable
is casted into type type. Afterwards, the variable is bound with the varBindingPattern on the left of :(no
bound exists for wildcardPattern : type ).
Examples of type pattern is shown below.
open class Point {
var x:Int32 =1
var y:Int32 =2
init (x:Int32 ,y:Int32 ){
this .x=x
this .y=y
}
}
class ColoredPoint <:Point {
var color :String ="green"
init (x:Int32 ,y:Int32 ,color :String) {
super(x, y)
this .color =color
}
}
let normalPt =Point( 5,10)
let colorPt =ColoredPoint( 8,24,"red" )
var rectangleArea1 :Int32 =match (normalPt) {
case _:Point =>normalPt.x *normalPt.y // matched
case _=>0
}
var rectangleArea2 :Int32 =match (colorPt) {
case cpt:Point =>cpt.x *cpt.y // matched
case _=>0
}
4.4.1.6 Enum Patterns
Enum patterns are often used together with enum types.
enum pattern is used to match an enum constructor in the format constructorName (without parameters)
orconstructorName(pattern_1,pattern_2,... , pattern_k) (with parameters), with a number of comma-
separated patterns (which can be any other type of pattern, and nesting is allowed) within parentheses to
match each parameter in turn.
The syntax of enum patterns is as follows.
enumPattern
: (userType '.')? identifier enumPatternParameters?
;
enumPatternParameters
: '(' pattern (',' pattern)* ')'
;
The following shows an example of enum pattern.
enum TimeUnit {
|Year( Float32 )
|Month( Float32 ,Float32 )
|Day( Float32 ,Float32 ,Float32 )
|Hour( Float32 ,Float32 ,Float32 ,Float32 )
}
let oneYear =TimeUnit.Year( 1.0)
var howManyHours :Float32 =match (oneYear) {
case Year(y) =>y*365 *24// matched
case Month(y, m)=>y*365 *24+m*30*24
case Day(y, m,d)=>y*365 *24+m*30*24+d*24
case Hour(y, m,d,h)=>y*365 *24+m*30*24+d*24+h
}
let twoYear =TimeUnit.Year( 2.0)
var howManyYears :Float32 =match (twoYear) {
case Year(y) |Month(y, m)=>y// error: variable cannot be introduced in patterns connected
by '|' ↪
case Year(y) |Month(x, _)=>y// error: variable cannot be introduced in patterns connected
by '|' ↪
case Year(y) |Month(y, _)=>y// error: variable cannot be introduced in patterns connected
by '|' ↪
...
}
If the identifier in a pattern is an enum constructor in the scope where the pattern matches, the identifier
will always be matched as an enum pattern, otherwise it will be matched as a binding pattern.
enum Foo {
A|B|C
}
func f(){
let x=Foo.A
match (x) {
case A=>0// enum pattern
case B=>1// enum pattern
case C=>2// enum pattern
case D=>3// binding pattern
}
}
Note that matching enum requires that the type of the enum pattern is the same as the type of the
selector, and that the compiler checks to see if each constructor of the enum type (including the value of the
constructor’s argument) is fully covered, otherwise the compiler will report an error.
enum TimeUnit {
|Year( Float32 )
|Month( Float32 ,Float32 )
|Day( Float32 ,Float32 ,Float32 )
|Hour( Float32 ,Float32 ,Float32 ,Float32 )
}
let oneYear =TimeUnit.Year( 1.0)
var howManyHours :Float32 =match (oneYear) {// error: match must be exhaustive
case Year(y) =>y*365 *24
case Month(y, m)=>y*365 *24+m*30*24
}
4.4.2 Classification of Patterns
A pattern is said to be refutable when it is possible for the pattern not to match the value it is intended
to match. On the other hand, a pattern is said to be irrefutable when it can always match the value it is
intended to match. For each kinds of pattern described above, we have the following rules.
•The constant pattern is always refutable pattern.
•The wildcard pattern is always irrefutable pattern.
•The binding pattern is always irrefutable pattern.
•A tuple pattern is irrefutable if and only if each pattern it contains is an irrefutable pattern.
•The type pattern is always refutable pattern.
•An enum pattern is irrefutable if and only if the corresponding enum type has only one parameterized
constructor, and all other patterns contained in the enum pattern (if present) are irrefutable patterns.
4.4.3 Pattern Guards
To make further judgements on the matched values, Cangjie supports the use of pattern guard .pattern
guardcan be used in match expressions as well as in for-in expressions. This section focuses on the use of
pattern guard in match expressions, see [for-in expressions] for its use in for in expressions.
In the match expression, pattern guards are supported to provide a powerful and flexible matching
mechanism, i.e., adding an expression of Boolean type where boolExpression between patternand =>. If a
pattern guard is present, a match is successful if and only if the value is matched with the patternand the
boolExpression istrue.
The syntax of pattern guard is as follows.
patternGuard
: 'where' expression
;
The following shows an example pattern guard.
let oneYear =Year( 1.0)
var howManyHours :Float32 =match (oneYear) {
case Year(y) where y>0=>y*365 *24// matched
case Year(y) where y<=0=>0.0
case Month(y, m)where y>0&&m>0=>y*365 *24+m*30*24
case Day(y, m,d)where y>0&&m>0&&d>0=>y*365 *24+m*30*24+d*24
case Hour(y, m,d,h)where y>0&&m>0&&d>0&&h>0=>y*365 *24+m*30*24+d
*24+h ↪
case _=>0.0
}
4.5 Loop Expressions
There are three kinds of loop expressions in the Cangjie programming language, i.e., the for-inexpression,
thewhileexpression and the do-while expression. Note that the value of a loop expression is Unit.
The syntax of loop expressions is defined as follows.
loopExpression
: forInExpression
| whileExpression
| doWhileExpression
;
4.5.1 The for-in Expression
A complete for-in expression has the following form:
for (pinewhere c){
s
}
The if (c)is not required, so a simpler for-in expression has the following form:
for (pine){
s
}
The syntax of the for-in expression is defined as follows.
forInExpression
: 'for' '(' patternsMaybeIrrefutable 'in' expression patternGuard? ')' block
;
patternsMaybeIrrefutable
: wildcardPattern
| varBindingPattern
| tuplePattern
| enumPattern
;
patternGuard
: 'where' expression
;
In the above syntax definition, the keyword forcan only be followed by patterns that must or may be
irrefutable (seeClassification of Patterns ). At the semantic check stage, it is checked whether the pattern
after foris actually irrefutable , if not, it is a compile-time error. By the way, if binding patterns exist in the
pattern after for, it means declaring one (or more) new letvariables, and the scope of each variable is from
its first occurrence to the end of the loop body.
With for-insyntax, Cangjie evaluates the expression first and then calls the iterator() function on
the evaluated value to get a value of type Iterator<T> . The program starts the loop by calling the next()
function of Iterator<T> . We can use patternto match the elements of the iteration, and if the match is
successful (if patternGuard exists, the condition of patternGuard must also be satisfied), then execute the
loop body block, and then recall next()at the beginning to continue the loop, the loop terminates when
next()returns None.
Iterable<T> and Iterator<T> are available in the standard library.
main() :Int64 {
let intArray :Array <Int32 >=[0,1,2,3,4]
for (item inintArray) {
print(item) // output: 01234
}
let intRange =0..5
for (number inintRange where number >2){
print(number) // output: 34
}
return 0
}
4.5.2 The while Expression
The syntax of the while expression is defined as follows.
whileExpression
: 'while' '(' ('let' deconstructPattern '=')? expression ')' block
;
where whileisthekeyword, whileisfollowedbyaparenthesis, whichcanbeanexpressionoralet-declared
variable definition, followed by a block.
An example of a basic whileexpression.
main() :Int64 {
var hundred =0
while (hundred <100){// until hundred = 100
hundred ++
}
return 0
}
The whileexpression first evaluates the expression after while(which is required to be of type Bool),
and if the value of the expression is equal to true, the block after it is executed, then the value of the
expression is recalculated and the loop is re-executed; if the value of the expression is equal to false, the
loop is terminated.
For whileexpressions that contain let, we call them while-let expressions. We can use while-let
expressions to do some simple deconstruction operations.
An example of a basic while-let expression.
main() :Int64 {
var x:Option <Int64 >=Option <Int64 >.Some( 100)
// while-let expression
while (let Some(v) <-x){
print( "x has value" )
x=...
}
return 0
}
The while-let expression first evaluates the expression after <-(the type of the expression can be any
type), and if the value of the expression matches the pattern after let, it executes the block after it, then
recalculates the value of the expression and matches it again and determines whether to execute the loop
again; if the match fails, it terminates the current whileloop.
The pattern after letsupports constant pattern, wildcard pattern, variable binding pattern, Tuple pat-
tern, and enum pattern.
4.5.3 The do-while Expression
The syntax of the do-while expression is defined as follows.
doWhileExpression
: 'do' block 'while' '(' expression ')'
;
Thedifferencebetweena whileexpressionanda do-while expressionistheloopbodyina whileexpression
maynotbeevaluated(whenthe expression isinitially false), whereastheloopbodyina do-while expression
is at least evaluated once, i.e., blockis evaluated before evaluating the expression written after the keyword
while.
main() :Int64 {
var hundred =0
do{
hundred ++
}while (hundred <100)
return 0
}
4.5.4 Summary of Loop Expressions
The expressiveness of the for-inexpression, the whileexpression and the do-while expression are the same.
In general, for-inexpressions are used when the number of iterations is known, or all elements in a sequence
need to be visited. whileordo-while expressions used when the loop keeps iterating until a condition is
satisfied.
Note that the type of the three loop expressions is Unit.
Since the breakand continue expressions require their enclosing loop bodies, therefore the breakand
continue expressions, if appeared in any of the three loop expressions, are bound to the nearest outer loop;
if there is no such outer loop, then an error is raised:
while (true ){
println( "outer" )// printed once
do{
println( "inner" )// printed once
}while (break )// stop the execution of the outer loop
println( "unreached" )// not printed
}
4.6 The try Expressions
Therearetwokindsof tryexpressionsintheCangjieprogramminglanguage. Oneisordinary tryexpressions
thatdonotprovideautomaticresourcemanagement. Theotheristry-with-resourcesexpressionsthatprovide
automatic resource management.
The syntax of the try expression is defined as:
tryExpression
: 'try' block 'finally' block
| 'try' block ('catch' '(' catchPattern ')' block)+ ('finally' block)?
| 'try' '(' resourceSpecifications ')' block ('catch' '(' catchPattern ')' block)* ('finally'
block)? ↪
;
The primary use of ordinary tryexpression is error handling, see Chapter Exceptions for details.
The primary use of try-with-resources is to automatically release non-memory resources, see Chapter
Exceptions for details.
4.7 Control T ransfer Expressions
Control transfer expressions change the execution order of the program, by transferring control from one
place to another. Control transfer expressions have type Nothing, which is the subtype of all types. The
control transfer expressions are:
•break
•continue
•return
•throw
Control transfer expressions can become part of a more complex expression, but unreachable codes may
be generated (reporting a warning at the unreachable code):
main() :Int64 {
return return 1// warning: the left return expression is unreachable
}
As for the control transfer expressions, breakand continue must have their enclosing loop bodies; return
must has its enclosing function body; however, there is no similar rules for throw.
The enclosing loops cannot cross function boundaries . As for the example blow, the breakexpression
appears inside the function fand hence is not within the loop body of the outer while loop; similarly, the
continue expression appears inside a lambda expression and hence is not within the loop body of the outer
while loop.
while (true ){
func f(){
break // Error: break must be used directly inside a loop
}
let g={=>
continue // Error: continue must be used directly inside a loop
}
}
The syntax of control transfer expressions is defined as follows.
jumpExpression
: 'break'
| 'continue'
| 'return' expression?
| 'throw' expression
;
4.7.1 The break Expression
Abreakexpression can only be used in loop bodies. It immediately ends the evaluation of the loop and
transfers the control to the end of the loop expression. In the following example, a breakexpression is used
in a whileexpression which computes the lowest common multiple of 4and 6(i.e., 12) .
main() :Int64 {
var index :Int32 =0
while (index <50){
index =index +1
if((index %4==0)&&(index %6==0)){
print( "${index }is divisible by both 4 and 6" )// output: 12
break
}
}
return 0
}
Note that when a breakexpression appears in a nested loop expression, only the immediate containing
loop expression is terminated, and the other loop expressions are not affected. For example, the following
program outputs 12 is divisible by both 4 and 6 five times, along with the value of ieach time.
main() :Int64 {
var index :Int64 =0
for (iin0..5){
index =i
while (index <20){
index =index +1
if((index %4==0)&&(index %6==0)){
print( "${index }is divisible by both 4 and 6" )
break
}
}
print( "${i}th test" )
}
return 0
}
4.7.2 The continue Expression
Acontinue expression can only be used in loop bodies. It stops the current iteration of the nearest loop
expression and then starts a new iteration from the beginning of the loop expression. Note that it does
not end the loop expression. In the following example, all the numbers between 1and 49that can be
simultaneously divided by 4and 6(i.e., 12,24,36and 48) are printed in one message and the remaining
numbers are printed in a different message.
main() :Int64 {
var index :Int32 =0
while (index <50){
index =index +1
if((index %4==0)&&(index %6==0)){
print( "${index }is divisible by both 4 and 6" )
continue
}
print( "${index }is not what we want" )
}
return 0
}
4.7.3 The return expression
Areturnexpression is composed of the keyword returnand an optional expression. It can only used in a
function body. It terminates the execution of the function immediately. It provides a flexible control transfer
from the callee to the function caller, i.e., the callee can terminate the function and return the value in the
middle of the function body rather than always at the end.
•If a function contains a returnexpression return expr , the value of expris the return value of the
function. Therefore, the type of exprmust be the same as the return type of the function.
// return expression
func larger (a:Int32 ,b:Int32 ):Int32 {
if(a>=b){
return a
}else {
return b
}
}
•Areturnexpression of the form returnis regarded as the syntactic sugar of return () . Thus the return
type in the containing function must be Unit￿ otherwise, an error is reported.
// return expression
func equal (a:Int32 ,b:Int32 ):Unit {
if(a==b){
print( "a is equal to b" )
return
}else {
print( "a is not equal to b" )
}
}
It should be noted that, the type of return e is not the type of exprorUnitifexpris missing. Rather it
isNothingtype.
4.7.4 The throw expression
throwexpressions are used for throwing exceptions. When a throwexpression is evaluated, the corresponding
exception is thrown, which is caught and processed by the exception handling mechanism. In this way, the
control flow of the program can be changed.
In the following example, an ArithmeticException is thrown when the divisor is 0.
func div(a:Int32 ,b:Int32 ):Int32 {
if(b!=0){
return a/b
}else {
throw ArithmeticException()
}
}
More detailed elaboration on the usage of returnand throwexpressions can be referred to in Chapter 5
Functions and Chapter 12 Exceptions.
4.8 Numeric Type Conversion Expressions
Numeric type conversion expressions are used to implement conversions between numeric types, whose value
and type are the converted ones respectively. (The type of the expression being converted is not affected by
the target type.) See Type Conversion for more details.
The syntax of numeric type conversion expressions are defined as:
numericTypeConvExpr
: numericTypes '(' expression ')'
;
numericTypes
: 'Int8'
| 'Int16'
| 'Int32'
| 'Int64'
| 'UInt8'
| 'UInt16'
| 'UInt32'
| 'UInt64'
| 'Float16'
| 'Float32'
| 'Float64'
;
4.9 The this and super Expressions
thisand superexpressions are represented by thisand super, respectively. thiscan appear in all instance
members and constructors to represent the current instance, and supercan only appear in class type defi-
nitions to represent instances of the direct parent class (see Chapter 6 Classes for details). Using separate
superexpression is not allowed.
The syntax of this and super expressions is defined as:
thisSuperExpression
: 'this'
| 'super'
;
4.10 spawn Expressions
The spawn expression is used to create and start a thread, see theConcurrent section for details.
4.11 synchronized Expressions
Thesynchronizedexpressionisusedinsynchronizationmechanisms, seethe Concurrency sectionfordetails.
4.12 Parenthesized Expressions
Parenthesized expressions are expressions that are enclosed in parentheses. Subexpressions in parentheses
are considered as a separate evaluation Unit.
The syntax of a parenthesized expression is defined as.
parenthesizedExpression
: '(' expression ')'
;
Examples of parenthesized expressions:
1+2*3-4 // The result is 3.
(1+2)*3-4// The result is 5.
4.13 Postfix Expressions
Postfix expressions consist of an expression plus suﬀix operators. Depending on the suﬀix operator, they
are classified as member access expressions, function call expressions, index expressions and !destructure
expressions. The classified as member access expressions, function call expressions, index expressions can be
preceded by an optional ?operator, in order to make Option types support the above postfix operators. For
the?operator, see below for details.
The syntax of the postfix expression is defined as.
postfixExpression
: atomicExpression
| type '.' identifier
| postfixExpression '.' identifier typeArguments?
| postfixExpression callSuffix
| postfixExpression indexAccess
| postfixExpression '.' identifier callSuffix? trailingLambdaExpression
| identifier callSuffix? trailingLambdaExpression
| postfixExpression ('?' questSeperatedItems)+
;
4.13.1 Member Access Expressions
The syntax of a member access expression is defined as the rule 3 of the syntax of the postfix expression
above.
postfixExpression '.' identifier typeArguments?
A member access expression can be used to access the members of a class, interface, struct, etc.
For the member-access expression is T.a,Tcan be represented as a specific instance or type name, which
we called as the subject of a member access expression, and adenotes the name of the member.
•IfTis an object of a class, a non-static member of the class or interface can be accessed in this way.
•IfTis an instance of struct, accessing to non-static members of struct by instance name is allowed.
•IfTis a class name, interface name, or structname, allow access to its static members directly by type
name.
Note that static members of classes, interfaces, and structs can only have type names as their access
subjects.
•Tisthis: within the scope of a class or interface, non-static members can be accessed using the this
keyword.
•–Tissuper: within a class or interface scope, non-static members of the direct superclass of the
current class can be accessed by the superkeyword.
When eis a type name, we have the following rules.
•e.aismutable when ais amutable static member variable of e, otherwise e.aisimmutable .
When eis an expression (assuming the type of eisT), we have the following rules.
•When Tis a reference type, e.aismutable ifais amutable instance member variable of T, otherwise
e.aisimmutable .
•When Tis a value type, e.aismutable ifemutable and ais amutable instance member variable
ofT, otherwise e.aisimmutable .
4.13.2 F unction Invocation Expressions
The syntax of a function invocation expression is defined as the rule 4 of the syntax of the postfix expression
above, where the syntax of callSuffix and valueArgument is defined as.
callSuffix
: '(' (valueArgument (',' valueArgument)*)? ')'
;
valueArgument
: identifier ':' expression
| expression
| refTransferExpression
;
refTransferExpression
: 'inout' (expression '.')? identifier
;
A function invocation expression is used to call a function. See Chapter 5 Functions for more details
about functions.
For a function invocation expression f(x)(assuming that fis of type T), if Tis a function type, f(x)
should call the function named f. Otherwise, if Toverloads the operator (),f(x)should try to call the
overloaded function (see Operators that can be Overloaded ).
4.13.3 Index Access Expressions
The syntax of a index access expression is defined as the rule 5 of the syntax of the postfix expression above,
where the syntax of indexAccess is defined as follows:
indexAccess
: '[' (expression | rangeElement) ']'
;
rangeElement
: '..'
| ('..=' | '..' ) expression
| expression '..'
;
Index access expressions are used for types that support index access (including Arraytypes and Tuple
types) to access elements at their specific locations, as detailed in Chapter 2 for Arraytypes and Tupletypes.
For the index access expression e[a](assuming that eis of type T), we have the following rules.
•When Tis a tuple type, e[a]isimmutable .
•When Tisnotatupletype, e[a]ismutable ifToverloadsthesetformoftheoperator [](seeOperators
that can be Overloaded ), otherwise e[a]isimmutable .
For the index expression e1[e2], Cangjie will always evaluate e1tov1first and then e2tov2, and
finally pick the corresponding value according to the index v2or call the corresponding operator []that is
overloaded.
4.13.4 The Question Mark Operator
The question mark operator ?is a postfix unary operator. The ?must be used with the postfix operators,
including .,()and [](appearing before postfix operators), to make Optiontypes support for these postfix
operators, e.g., a?.b,a?(b),a?[b]. Here ()is a function call, when the last argument of the function call is
a lambda, the tail closure syntax can be used, e.g., a?{b}. An expression at least containing one of ?.,?(),
?{}or?[]is called an optional chaining expression.
The syntax of an optional chaining is defined as the last rule of the syntax of the postfix expression above,
where the syntax of questSeperatedItems is defined as follows:
questSeperatedItems
:questSeperatedItem +
;
questSeperatedItem
:itemAfterQuest (callSuffix |callSuffix ?trailingLambdaExpression |indexAccess )?
;
itemAfterQuest
:'.' identifier typeArguments ?
|callSuffix
|indexAccess
|trailingLambdaExpression
;
For optional chaining expressions, we have the following rules.
1.For the expression e, delete all ?ineand replace the type of the expression immediately before ?(i.e.,
Option<T> ) by Tto give the expression e1. If the type of e1is an option type, then you need to add a
?after ewhen use .,(),{}or[]on it. Otherwise, you should not add ?after ewhen use .,(),{}or
[]on it.
2.The type of an optional chaining expression is Option<T> (i.e., no matter how many ?it contains, its
type only has one level of option), in which Tis the type of the last expression (i.e., variable or function
name, function call expression, or subscript access expression) in the optional chaining.
3.Once the value of any expression with an option type in the optional chaining is None, the value of the
entire optional chaining expression is None. Only when all expressions with option types in the optional
chaining have Somevalues, the value of the entire expression is Some(v)(the type of vis the type of the
last expression).
Using the expressions a?.b,c?(d)and e?[f]as examples.
1.The type of expression aneeds to be some Option<T1> and T1contains an instance member b. The
type of expression cneeds to be some Option<(T2)->U2> and dis of type T2. The type of expression e
needs to be some Option<T3> and T3supports subscript operator.
2.The expressions a?.b,c?(d)and e?[f]are of type Option<U1> ,Option<U2> and Option<U3> respectively.
In above, U1is the type of the instance member binT1,U2is the type of the return value of the function
type (T2)->U2 and U3is the type of the return value of execution the subscript operation on T3.
3.When the values of a,cand eare equal to Some(v1) ,Some(v2) and Some(v3) respectively, the val-
ues of a?.b,c?(d)and e?[f]are equal to Option<U1>.Some(v1.b) ,Option<U2>.Some(v2(d)) and Op-
tion<U3>.Some(v3[f]) respectively. When the values of a,cand eare equal to Nonerespectively, the
values of a?.b,c?(d)and e?[f]are equal to Option<U1>.None ,Option<U2>.None and Option<U3>.None
respectively (note that here b,dand fwill not be evaluated).
In fact, the expressions a?.b,c?(d)and e?[f]are equivalent to the following matchexpressions, respec-
tively.
// a?.b is equivalent to the following match expression.
match (a) {
case Some(v) =>Some(v.b)
case None =>None
}
// a?(b) is equivalent to the following match expression.
match (a) {
case Some(v) =>Some(v(b))
case None =>None
}
// a?[b] is equivalent to the following match expression.
match (a) {
case Some(v) =>Some(v[b])
case None =>None
}
Let’s look at another example containing multiple ?for a multi-layer access a?.b.c?.d (just take ?.as
an example, other operators are similar and will not be repeated), it can be found that:
1.The type of the expression aneeds to be some Option<Ta> and Tacontains the instance member b. The
type of bcontains the instance member variable cand the type of cis some Option<Tc> and Tccontains
the instance member d.
2.The expression a?.b.c?.d is of type Option<Td> , where Tdis the type of the instance member dofTc.
3.When the value of ais equal to Some(va) and the value of va.b.cis equal to Some(vc) , the value of
a?.b.c?.d is equal to Option<Td>.Some(vc.d) . When the value of ais equal to Some(va) and the value
ofva.b.cis equal to None, the value of a?.b.c? d is equal to Option<Td>.None (dwill not be evaluated).
When the value of ais equal to None, the value of a?.b.c?.d is equal to Option<Td>.None (neither b,c
nor dwill be evaluated).
The expression a?.b.c?.d is equivalent to the following matchexpression.
// a?.b.c?.d is equivalent to the following match expression.
match (a) {
case Some(va) =>
let x=va.b.c
match (x) {
case Some(vc) =>Some(vc.d)
case None =>None
}
case None =>
None
}
Optional chaining expressions can also be used as left value expressions (seeAssignment Expressions ), as
ina?.b = e1 ,a?[b] = e2 , and a?.b.c?.d = e3 etc.
When the left-hand side of an assignment expression is an optional chaining expression, it is required
that the optional chaining expression be mutable (seeAssignment Expressions ). Since function types are
immutable, only ?.and ?[]should be considered, and they can both reduce to the basic scenarios of a?.b
= cand a?[b] = c (assuming that ais of type Option<T> ). Moreover, we have the following rules.
•For a?.b,a?.bismutable only if Tis a reference type and bmutable , otherwise a?.bisimmutable .
•For a?[b],a?[b]ismutable only if Tis a reference type and Toverloads the set form of the operator
[], otherwise a?[b]isimmutable .
When a?.b(ora?[b]) isimmutable , assign the value of ctov.b(or to v[b]) if the value of ais
Option<T>.Some(v) , and do nothing ( band cwill not be evaluated) if the value of aisOption<T>.None .
Similarly, the expressions a?.b = e1 ,a?[b] = e2 and a?.b.c?.d = e3 are equivalent to the following match
expressions, respectively.
// a?.b = e1 is equivalent to the following match expression.
match (a) {
case Some(v) =>v.b =e1
case None =>()
}
// a?[b] = e2 is equivalent to the following match expression.
match (a) {
case Some(v) =>v[b] =e2
case None =>()
}
// a?.b.c?.d = e3 is equivalent to the following match expression.
match (a) {
case Some(va) =>
match (va.b.c) {
case Some(vc) =>vc.d =e3
case None =>()
}
case None =>
()
}
The following example shows the usage of the operator ?.
// The usuage of ?.
class C{
var item :Int64 =100
}
let c=C()
let c1=Option <C>.Some(c)
let c2=Option <C>.None
let r1=c1?.item // r1 = Option<Int64>.Some(100)
let r2=c2?.item // r2 = Option<Int64>.None
func test1 (){
c1?.item =200 // c.item = 200
c2?.item =300 // no effect
}
// The usuage of ?()
let foo ={i:Int64 =>i+1}
let f1=Option <(Int64 )->Int64 >.Some(foo)
let f2=Option <(Int64 )->Int64 >.None
let r3=f1?(1) // r3 = Option<Int64>.Some(2)
let r4=f2?(1) // r4 = Option<Int64>.None
// The usuage of ?[] for tuple access
let tuple =(1,2,3)
let t1=Option <(Int64 ,Int64 ,Int64 )>.Some(tuple)
let t2=Option <(Int64 ,Int64 ,Int64 )>.None
let r7=t1?[0] // r7 = Option<Int64>.Some(1)
let r8=t2?[0] // r8 = Option<Int64>.None
func test3 (){
t1?[0]=10 // error: 't1?[0]' is immutable
t2?[1]=20 // error: 't2?[0]' is immutable
}
4.14 Increment and Decrement Expressions
Increment and decrement expressions are expressions that contain the postfix increment operator ( ++) or
postfix decrement operator ( --);a++and a--are syntactic sugar of a+=1and a-=1respectively. Note that
++and --can only be used as postfix operators, i.e., prefix increment (e.g., ++x) and prefix decrement (e.g.,
--x) are not supported. Furthermore, the postfix increment/decrement operator is non-associative, and thus
an expression containing multiple ++or--without parentheses are syntactically invalid.
The syntax of the increment and decrement expression is defined as follows:
incAndDecExpression
: postfixExpression ('++' | '--' )?
;
For the expression expr++(orexpr--), the following is specified:
1.The type of exprmust be one of integer types.
2.Since expr++(orexpr--) is syntactic sugar of expr += 1 (orexpr -= 1 ), the exprmust also be assignable.
3.The type of expr++(orexpr--) isUnit.
Examples for using increment and decrement expressions:
var i:Int32 =5
i++ // i = 6
i-- // i = 5
i--++ // syntax error
let j=0
j=i--// semantics error
4.15 Arithmetic Expressions
Arithmetic expressions are expressions that contain arithmetic operators. Arithmetic operators include:
unary negative ( - ), add ( +), subtract( -), multiply( *), divide( /), remainder( %), power ( **). Except for the
unary negative operator which is a unary prefix operator, all other operators are binary infix operators. See
the last section for their precedence and associativity.
The syntax of arithmetic expressions are defined as:
prefixUnaryExpression
: prefixUnaryOperator* incAndDecExpression
;
prefixUnaryOperator
: '-'
| ...
;
additiveExpression
: multiplicativeExpression (additiveOperator multiplicativeExpression)*
;
multiplicativeExpression
: exponentExpression (multiplicativeOperator exponentExpression)*
;
exponentExpression
: prefixUnaryExpression (exponentOperator prefixUnaryExpression)*
;
additiveOperator
: '+' | '-'
;
multiplicativeOperator
: '*' | '/' | '%'
;
exponentOperator
: '**'
;
The operand of -can only be an expression with one kind of numeric type. The value of -expris equal
to the value of the operand taking a negative value. The type of -expris the type of expr.
let num1 :Int64 =8
let num2 =-num1 // num2 = -8, with 'Int64' type
let num3 =-(-num1) // num3 = 8, with 'Int64' type
For binary operators *,/,%,+and -, the types of operands supported by them are all numeric types,
except %, which only supports integer types.
let a=2+3 // add￿ 5
let b=3-1 // sub￿ 2
let c=3*4 // multi￿ 12
let d=6.6 /1.1 // division￿ 6
let e=4%3 // mod￿ 1
In particular, the behavior of the division operator( /) on integer types is rounding non-integral values
towards 0. The value of the remainder expression on integer types a % bis defined as a - b * (a / b) .
let q1=7/3 // integer division: 2
let q2=-7/3 // integer division: -2
let q3=7/-3 // integer division: -2
let q4=-7/-3 // integer division: 2
let r1=7%3 // integer remainder: 1
let r2=-7%3 // integer remainder: -1
let r3=7%-3 // integer remainder: 1
let r4=-7%-3 // integer remainder: -1
**is the power operator, e.g., the result of the x**yis the yth power of the base x. The left operand of
**can only be of type Int64orFloat64.
1.When the type of the left operand is Int64, the type of the right operand can only be UInt64, and the
expression is of type Int64.
2.When the type of the left operand is Float64, the type of the right operand can only be Int64or
Float64, and the expression is of type Float64.
let p1=2**3 // p1 = 8
let p2=2**UInt64 (3**2)// p2 = 512
let p3=2.0 **3.0 // p3 = 8.0
let p4=2.0 **3**2 // p4 = 512.0
let p5=2.0 **3.0 // p5 = 8.0
let p6=2.0 **3.0 **2.0 // p6 = 512.0
When the type of the left operand is Float64and the type of the right operand is Int64, there are some
special cases need to be specified, as listed below.
x**0=1.0 // for any x
0.0 **n=POSITIVE_INFINITY // for odd n < 0
-0.0 **n=NEGATIVE_INFINITY // for odd n < 0
0.0 **n=POSITIVE_INFINITY // for even n < 0
-0.0 **n=POSITIVE_INFINITY // for even n < 0
0.0 **n=0.0 // for even n > 0
-0.0 **n=0.0 // for even n > 0
0.0 **n=0.0 // for odd n > 0
-0.0 **n=-0.0 // for odd n > 0
POSITIVE_INFINITY **n=POSITIVE_INFINITY // for n > 0
NEGATIVE_INFINITY **n=NEGATIVE_INFINITY // for odd n > 0
NEGATIVE_INFINITY **n=POSITIVE_INFINITY // for even n > 0
POSITIVE_INFINITY **n=0.0 // for n < 0
NEGATIVE_INFINITY **n=-0.0 // for odd n < 0
NEGATIVE_INFINITY **n=0.0 // for even n < 0.
Note: When the left operand has the value NaN, the value of the power expression is NaNregardless
of the value of the right operand, except in the cases listed above.
When the type of the left operand is Float64and the type of the right operand is Float64, there are also
some special cases need to be specified, as listed below.
x**0.0 =1.0 // for any x
x**-0.0 =1.0 // for any x
0.0 **y=POSITIVE_INFINITY // for the value of y is equal to an odd integer < 0
-0.0 **y=NEGATIVE_INFINITY // for the value of y is equal to an odd integer < 0
0.0 **NEGATIVE_INFINITY =POSITIVE_INFINITY
-0.0 **NEGATIVE_INFINITY =POSITIVE_INFINITY
0.0 **POSITIVE_INFINITY =0.0
-0.0 **POSITIVE_INFINITY =0.0
0.0 **y=0.0 // for finite y > 0.0 and its value is equal to an odd
integer ↪
-0.0 **y=-0.0 // for finite y > 0.0 and its value is equal to an odd
integer ↪
-1.0 **POSITIVE_INFINITY =1.0
-1.0 **NEGATIVE_INFINITY =1.0
1.0 **y=1.0 // for any y
x**POSITIVE_INFINITY =0.0 // for -1.0 < x < 1.0
x**POSITIVE_INFINITY =POSITIVE_INFINITY // for any x < -1.0 or for any x > 1.0
x**NEGATIVE_INFINITY =POSITIVE_INFINITY // for -1.0 < x < 1.0
x**NEGATIVE_INFINITY =0.0 // for any x < -1.0 or for any x > 1.0
POSITIVE_INFINITY **y=0.0 // for y < 0.0
POSITIVE_INFINITY **y=POSITIVE_INFINITY // for y > 0.0
NEGATIVE_INFINITY **y=-0.0 // for finite y < 0.0 and its value is equal to an odd
integer ↪
NEGATIVE_INFINITY **y=NEGATIVE_INFINITY // for finite y > 0.0 and its value is equal to an odd
integer ↪
NEGATIVE_INFINITY **y=0.0 // for finite y < 0.0 and its value is not equal to an
odd integer ↪
NEGATIVE_INFINITY **y=POSITIVE_INFINITY // for finite y > 0.0 and its value is not equal to an
odd integer ↪
0.0 **y=POSITIVE_INFINITY // for finite y < 0.0 and its value is not equal to an
odd integer ↪
-0.0 **y=POSITIVE_INFINITY // for finite y < 0.0 and its value is not equal to an
odd integer ↪
0.0 **y=0.0 // for finite y > 0.0 and its value is not equal to an
odd integer ↪
-0.0 **y=0.0 // for finite y > 0.0 and its value is not equal to an
odd integer ↪
x**y=NaN // for finite x < 0.0 and finite y whose value is not
equal to an integer ↪
Note: the result of the power expression is NaNif there is a NaNamong the operands of **, except
in the cases listed above.
Arithmetic operators introduced above are safe in the Cangjie programming language. That is, if an
overflow (i.e., the value of an expression is beyond the range of its type) is detected at compile time, then a
compilation error will be reported; otherwise an ArithmeticException is thrown at runtime.
let a:Int32 =2147483647 // int_MAX
let b:Int32 =1
let c:Int32 =b+a// throw an ArithmeticException
Cangjiealsoprovidesattributedmacrotocustomizetheoperators’overflowstrategy. Thereare3overflow
strategies can be used: throwing exceptions, wrapping and saturating. The corresponding attributed macros
are: @OverflowThrowing ,@OverflowWrapping and @OverflowSaturating . The default strategy is the same with
@OverflowThrowing .
attributes strategy
@OverflowThrowing If overflow occurs, throwing an exception
@OverflowWrapping If overflow occurs, wrapping around at the numeric bounds of the type, instead of
throwing exception
@OverflowSaturating If overflow occurs, saturating at the numeric bounds of the type, instead of throwing
exception
@OverflowWrapping
func test (x:Int8 ,y:Int8 ){
let z1=x*y// No exception will be thrown when overflow occurs
}
Especially, for these cases INT_MIN * -1 ,INT_MIN / -1 and INT_MIN % -1 , the results are defined as below.
expression @OverflowThrowing @OverflowWrapping @OverflowSaturating
INT_MIN * -1 or -1 *
INT_MINthrow an OverflowException INT_MIN INT_MAX
INT_MIN / -1 throw an OverflowException INT_MIN INT_MAX
INT_MIN % -1 0 0 0
@OverflowWrapping
func test (x:Int8 ,y:Int8 ){// If x equals -128 and y equals -1
let z1=x*y// z1 would be -128
let z2=x/y// z2 would be -128
let z3=x%y// z3 would be 0
}
4.16 Relational Expressions
Relational expressions are expressions that contain relational operators. Threre are six kinds of relational
operators, i.e., equal ( ==), not equal ( !=), less than ( <), less than or equal ( <=), greater than ( >), and greater
than or equal ( >=). All relational operators are binary operators which requires two operands have the same
type. The value of a relational expression has a Booltype, i.e., it can either be trueorfalse. See the last
section for their precedence and associativity.
The syntax of relational expressions are defined as:
equalityComparisonExpression
: comparisonExpression (equalityOperator comparisonExpression)?
;
comparisonOrTypeExpression
: shiftingExpression (comparisonOperator shiftingExpression)?
| ...
;
equalityOperator
: '!=' | '=='
;
comparisonOperator
: '<' | '>' | '<=' | '>='
;
Examples for relational expressions:
main() :Int64 {
3<4 // return true
3<=3 // return true
3>4 // return false
3>=3 // return true
3.14 ==3.15 // return false
3.14 !=3.15 // return true
return 0
}
Note that the relational operators are non-associative, i.e., an expression like a < b < c is invalid.
main() :Int64 {
3<4<5 // error: `<` is non-associative
3==3!=4 // error: `==` and `!=` are non-associative
return 0
}
4.17 Type Check and Type Cast Expressions
Type check and type test expressions are expressions that contain the isoperator and the asoperator,
respectively. Refer to the last section for the precedence and associativity of the isoperator and the as
operator.
The syntax of type test and type cast expressions is defined as:
comparisonOrTypeExpression
: ...
| shiftingExpression ('is' type)?
| shiftingExpression ('as' userType)?
;
4.17.1 The is Operator
e is Tis an expression for type checking, and e is Tis of type Bool. where e can be an expression of any
type and T can be any type.
When the runtime type R of e is a subtype of T, the value of e is Tistrue, otherwise the value is false.
Examples of using the isoperator:
open class Base {
var name :String ="Alice"
}
class Derived1 <:Base {
var age:UInt8 =18
}
class Derived2 <:Base {
var gender :String ="female"
}
main() :Int64 {
var testVT =1isInt64 // testVT = true
testVT =1isString // testVT = false
testVT =true isInt64 // testVT = false
testVT =[1,2,3]isArray <Int64 >// testVT = true
let base1 :Base =Base()
let base2 :Base =Derived1()
let base3 :Base =Derived2()
let derived1 :Derived1 =Derived1()
let derived2 :Derived2 =Derived2()
var test =base1 isBase // test = true
test =base1 isDerived1 // test = false
test =base1 isDerived2 // test = false
test =base2 isBase // test = true
test =base2 isDerived1 // test = true
test =base2 isDerived2 // test = false
test =base3 isBase // test = true
test =base3 isDerived1 // test = false
test =base3 isDerived2 // test = true
test =derived1 isBase // test = true
test =derived1 isDerived1 // test = true
test =derived1 isDerived2 // test = false
test =derived2 isBase // test = true
test =derived2 isDerived1 // test = false
test =derived2 isDerived2 // test = true
return 0
}
4.17.2 The as Operator
e as Tis an expression for type conversion, and the type of e as TisOption<T> . where e can be an expression
of any type and T can be any concrete type.
When the runtime type R of e is a subtype of T, the value of e as TisSome(e), otherwise the value is
None.
Examples of using the asoperator:
open class Base {
var name :String ="Alice"
}
class Derived1 <:Base {
var age:UInt8 =18
}
class Derived2 <:Base {
var gender :String ="female"
}
main() :Int64 {
let base1 :Base =Base()
let base2 :Base =Derived1()
let base3 :Base =Derived2()
let derived1 :Derived1 =Derived1()
let derived2 :Derived2 =Derived2()
let castOP1 =base1 asBase // castOP = Option<Base>.Some(base1)
let castOP2 =base1 asDerived1 // castOP = Option<Derived1>.None
let castOP3 =base1 asDerived2 // castOP = Option<Derived2>.None
let castOP4 =base2 asBase // castOP = Option<Base>.Some(base2)
let castOP5 =base2 asDerived1 // castOP = Option<Derived1>.Some(base2)
let castOP6 =base2 asDerived2 // castOP = Option<Derived2>.None
let castOP7 =base3 asBase // castOP = Option<Base>.Some(base3)
let castOP8 =base3 asDerived1 // castOP = Option<Derived1>.None
let castOP9 =base3 asDerived2 // castOP = Option<Derived2>.Some(base3)
let castOP10 =derived1 asBase // castOP = Option<Base>.Some(derived1)
let castOP11 =derived1 asDerived1 // castOP = Option<Derived1>.Some(derived1)
let castOP12 =derived1 asDerived2 // castOP = Option<Derived2>.None
let castOP13 =derived2 asBase // castOP = Option<Base>.Some(derived2)
let castOP14 =derived2 asDerived1 // castOP = Option<Derived1>.None
let castOP15 =derived2 asDerived2 // castOP = Option<Derived2>.Some(derived2)
return 0
}
4.18 Bitwise Expressions
Bitwise expressions are expressions that contain bitwise operators. There are one unary bitwise operator,
i.e., bitwise NOT ( !), and five binary bitwise operators, i.e., bitwise left shift ( <<), bitwise right shift ( >>),
bitwise AND ( &), bitwise XOR ( ^) and bitwise OR ( |). Bitwise operators can only be applied to operands
of integer types. The operand is regarded as a bit vector and the bitwise operator is applied bit-by-bit (for
logic operations, regarding 0asfalseand 1astrue). For &,^and |, the value of the operation is a bit
vector such that each bit is the value of applying the respective logical operations (i.e., logic AND and logic
OR) on the bits of the corresponding operands. See the Logical Expressions for the semantics of each logic
operation. Refer to the last section for the precedence and associativity of bitwise operators.
The syntax of bitwise expressions are defined as:
prefixUnaryExpression
: prefixUnaryOperator* incAndDecExpression
;
prefixUnaryOperator
: '!'
| ...
;
bitwiseDisjunctionExpression
: bitwiseXorExpression ( '|' bitwiseXorExpression)*
;
bitwiseXorExpression
: bitwiseConjunctionExpression ( '^' bitwiseConjunctionExpression)*
;
bitwiseConjunctionExpression
: equalityComparisonExpression ( '&' equalityComparisonExpression)*
;
shiftingExpression
: additiveExpression (shiftingOperator additiveExpression)*
;
shiftingOperator
: '<<' | '>>'
;
Examples for bitwise expressions:
func foo():Unit {
!10 // The result is -11
!20 // The result is -21
10<<1 // The result is 20
10<<1<<1 // The result is 40
10>>1 // The result is 5
10&15 // The result is 10
10^15 // The result is 5
10|15 // The result is 15
1^8&15|24// The result is 25
}
The operands of bitwise left/right shift operator must be of type integer. Note that the type of two
operands may be different. Furthermore, the operand right of the operator must not be a negative number.
Otherwise, a compilation error will be reported if it is detected at compile time, or an ArithmeticException
is thrown at run-time.
If the operand to the left of the operator is an unsigned integer or a positive integer, the bits are shifted
to the left or right accordingly and zeros are used to fill the trailing positions after the shift (on the left if
it is the right shift operator, or on the right if it is the left shift operator). Otherwise (i.e., the operand to
the left of the operator is a signed negative integer), 1 is used to fill the trailing positions after the shift (on
the left it is the right shift operator or on the right if it is the left shift operator). The following are some
examples of bitwise left/right shift operators:
let p:Int8 =-30
let q=p<<2 // q = -120
let r=p>>2 // r = -8
let r=p>>-2 // error
let x:UInt8 =30
let b=x<<3 // b = 240
let b=x>>1 // b = 15
If the value of the right operand of the bitwise left/right shift operator is equal to or greater than the
length of the left operand, overshift occurs and a compilation error is reported if it is detected at compile
time or a run-time exception is thrown.
let x1:UInt8 =30// 0b00011110
let y1=x1>>11 // compilation error
4.19 Range Expressions
Range expressions are expressions that contain range operators. Range expressions are used to create Range
instances. The syntax of an range expression is defined as:
rangeExpression
: bitwiseDisjunctionExpression ('..=' | '..') bitwiseDisjunctionExpression (':'
bitwiseDisjunctionExpression)? ↪
| bitwiseDisjunctionExpression
;
There are two kinds of range operators: ..and ..=, which are used to create Rangeinstances that are
half-open and closed, respectively. See Range Type for more details.
4.20 Logical Expressions
Logical expressions are expressions that contain logical operators. The operands of the logical operators can
only be of Bool types. There are three logical operators: logic NOT ( !), logic AND ( &&) and logic OR ( ||).
See the last section for their precedence and associativity.
The syntax of logic expressions are defined as:
prefixUnaryExpression
: prefixUnaryOperator* incAndDecExpression
;
prefixUnaryOperator
: '!'
| ...
;
logicDisjunctionExpression
: logicConjunctionExpression ( '||' logicConjunctionExpression)*
;
logicConjunctionExpression
: rangeExpression ( '&&' rangeExpression)*
;
Logic NOT ( !)is a prefix-unary operator. It is used to negateits operand, i.e., the result of !false
istrueand the result of !trueisfalse.
Logic AND and OR are binary operators. For the expression expr1 && expr2 , its value is equal to
trueonly if both expr1and expr2are equal to true. For the expression expr1 || expr2 , its value is equal to
falseonly if both expr1and expr2are equal to false.
The short-circuit evaluation strategy is adopted for &&and ||, i.e., given an expression expr1 && expr2 ,
ifexpr1evaluates to false,expr2is not evaluated. Analogously, given an expression expr1 || expr2 ,expr2
is not evaluated if expr1evaluates to true.
main() :Int64 {
let expr1 =false
let expr2 =true
!true // Logical NOT, return false.
1>2&&expr1 // Logical AND, return false without computing the value of
expr1. ↪
1<2||expr2 // Logical OR, return true without computing the value of expr2.
return 0
}
4.21 Coalescing Expressions
The coalescing expression is the expression containing the coalescing operator. The coalescing operator is
represented by ??, and it is an infix binary operator. See below for the precedence and associativity of ??.
The syntax of the coalescing expression is defined as:
coalescingExpression
: logicDisjunctionExpression ('??' logicDisjunctionExpression)*
;
The coalescing operatorisusedforunwrappingvaluesof Optiontypes. Supposethetypeoftheexpression
e1isOption<T> , then we have following rules about the expression e1 ?? e2 .
1.The type of the expression e2must be T.
2.The type of the expression e1 ?? e2 isT.
3.When the value of e1isOption<T>.Some(v) , the value of e1 ?? e2 is equal to the value of v(e2will not
be evaluated, i.e., ??is short-circuit). When the value of e1isOption<T>.None , the value of e1 ?? e2
is equal to the value of e2.
The expression e1 ?? e2 is the syntactic sugar of the following matchexpression:
// when e1 is Option<T>
match (e1) {
case Some(v) =>v
case None =>e2
}
The following example shows the usuage of the coalescing expression:
main() :Int64 {
let v1=Option <Int64 >.Some( 100)
let v2=Option <Int64 >.None
let r1=v1??0
let r2=v2??0
print( "${r1}")// output: 100
print( "${r2}")// output: 0
return 0
}
4.22 Flow Expressions
Flow expressions are expressions that contain flow operators. There are two flow operators: infix operator |>
(called pipeline ) which indicates the data flow and infix operator ~>(called composition ) which indicates the
function combination. The precedence of |>and ~>is the same, and is between ||and assignment operator
=.|>and ~>are both left-associative￿ see the last section for more details. The syntax of flow expression is
defined as follows:
flowExpression
: logicDisjunctionExpression (flowOperator logicDisjunctionExpression)*
;
flowOperator
: '|>' | '~>'
;
4.22.1 The pipeline operator
In fact, the pipeline expression is the syntactic sugar of a single parameter function call, that is, e1 |>
e2is the syntactic sugar of let v = e1; e2(v) (i.e. evaluate e1firstly). Here, e2is the expression of the
function type. The type of e1matches the parameter type of e2. Or the type of e2implements the operator
()overloading, (see Operators that can be Overloaded ), i.e. e1 |> e2 is the syntactic sugar of let v = e1;
e2(v)and e2(v)is the function call overloading. See section 4.13.2 for details.
Note that the fhere does not support the initand superconstructors.
func f(x:Int32 ):Int32 {x+1}
let a:Int32 =1
var res =a|>f// ok
var res1 =a|>{x:Int32 =>x+1}// ok
func h(b:Bool ){b}
let res3 =a<0||a>10 |>h// Equivalence￿(a < 0 || a > 10) |> h
func g<T>(x:T):T{x}
var res4 =a|>g<Int32 >// ok
class A{
let a:Int32
let b:Int32
init (x:Int32 ){
a=x
b=0
}
init (x:Int32 ,y:Int32 ){
x|>init // error: `init` is not a valid expression
b=y
}
}
// PIPELINE with operator `()` overloading
class A{
operator func ()(x :Int32 ){
x
}
}
let obj =A()
let a:Int32 =1
let res =a|>obj // Equivalence￿obj(a)
4.22.2 The composition operator
Acomposition expression represents a combination of two single-parameter functions. That is, the result of
the composition expression e1 ~> e2 is the syntactic sugar of let v = e1; \{x => e2(v(x))} . If fand g
are expressions of the function type or their type implements the single-parameter operator ()overloading
function, (see Operators that can be Overloaded ), the following situations may occur:
e1 ~> e2 The lambdaexpression
e1and e2are function types, and the return value
type of e1is a subtype of the argument type of e2let f = e1; let g = e2; {x => g(f(x))}
The type fimplements the single-parameter
operator ()overloading function, and gis a function
type, and the return value type of f.operator() is a
subtype of the argument type of glet f = e1; let g = e2; {x => g(f.operator()(x))}
e1 ~> e2 The lambdaexpression
fis a function type, and the type of gimplements
the the single-parameter operator ()overloading
function, and the return value type of fis a subtype
of the argument type of g.operator() .let f = e1; let g = e2; {x => g.operator()(f(x))}
The types of fand gboth implement the
single-parameter operator ()overloading function,
and the return value type of f.operator() is a
subtype of the argument type of g.operator()let f = e1; let g = e2; {x =>
g.operator()(f.operator()(x))}
Note that the fand ghere do not support the initand superconstructors.
func f(x:Int32 ):Float32 {Float32 (x) }
func g(x:Float32 ):Int32 {Int32 (x) }
var fg=f~>g// Equivalence: {x: Int32 => g(f(x))}
let lambdaComp ={x:Int32 =>x}~>f// ok
func h1<T>(x:T):T{x}
func h2<T>(x:T):T{x}
var hh=h1<Int32 >~>h2<Int32 >// ok
// COMPOSITION with operator `()` overloading
class A{
operator func ()(x :Int32 ):Int32 {
x
}
}
class B{
operator func ()(x :Float32 ):Float32 {
x
}
}
let objA =A()
let objB =B()
let af=objA ~>f// ok
let fb=f~>objB // ok
let aa=objA ~>objA // ok
4.23 Assignment Expressions
Assignment expressions are expressions that contain assignment operators. An assignment expression can
update the value of the left operand to the value of the right operand. Note that the type of the right value
must be the subtype of the type of the left value. When evaluating an assignment expression, the expression
to the left of =is always evaluated first, then the expression to the right of =, and finally the assignment.
For compound assignment expressions, the left value of the expression to the left of =is always computed
first, then the right value is taken from this left value, then the right value is computed with the expression
to the right of =(if there is a short-circuit rule, it will continue to follow the short-circuit rule), and finally
the value is assigned.
Assignment operators are divided into ordinary and compound assignment operators, and the syntax of
an assignment expression is defined as follows.
assignmentExpression
: leftValueExpressionWithoutWildCard assignmentOperator flowExpression
| leftValueExpression '=' flowExpression
| tupleLeftValueExpression `=` flowExpression
| flowExpression
;
tupleLeftValueExpression
: `(` (leftValueExpression | tupleLeftValueExpression) (`,` (leftValueExpression |
tupleLeftValueExpression))+ `,`? `)` ↪
;
leftValueExpression
: leftValueExpressionWithoutWildCard
| '_'
;
leftValueExpressionWithoutWildCard
: identifier
| leftAuxExpression '?'? assignableSuffix
;
leftAuxExpression
: identifier typeArguments?
| type
| thisSuperExpression
| leftAuxExpression ('?')? '.' identifier typeArguments?
| leftAuxExpression ('?')? callSuffix
| leftAuxExpression ('?')? indexAccess
;
assignableSuffix
: fieldAccess
| indexAccess
;
fieldAccess
: '.' identifier
;
assignmentOperator
: '=' | '+=' | '-=' | '**=' | '*=' | '/=' | '%=' | '&&=' | '||='
| '&=' | '|=' | '^=' | '<<=' | '>>='
;
Anexpressionthatappearstotheleftofa(compound)assignmentoperatoriscalleda left value expression
(i.e., leftValueExpression in the above definition).
Syntactically, a left value expression can be an identifier or_, or a leftAuxExpression followed by an
assignableSuffix (containing fieldAccess and indexAccess ). An optional ?operator can be existed between
leftAuxExpression and assignableSuffix , which is the syntactic sugar for assigning values to instances of
option types. The leftAuxExpression can be one of the following forms: 1. An identifier followed by an
optional type argument list (i.e., typeArguments ); 2. thisorsuper; 3. A leftAuxExpression followed by a .
(before which there may be an optional ?operator) and an identifier with an optional type argument list;
4. A leftAuxExpression followed by a function call suﬀix callSuffix or an index access suﬀix indexAccess
(callSuffix orindexAccess may be preceded by an optional ?operator).
Semantically, a left value expression can only be an expression of the following forms.
1.Variables represented by identifier (seeVariable Names and Function Names ).
2._expression ignores the result of the right expression of =expressions(Wildcards are prohibited for
compound assignment expressions).
3.Member access expression e1.aore2?.a(seeMember Access Expressions ).
4.Index access expression e1[a]ore2?[a](seeIndex Access Expressions ).
In above, e1and e2must be expressions that satisfy the syntax of leftAuxExpression .
A left value expression is legal only if it is mutable. For the mutability of the above expressions, see the
corresponding sections.
The type and the value of an assignment expression is Unitand (), respectively. This design helps to
avoid mistakes where an assignment expression is mistakenly used as an equal expression. For instance,
given the expression a = b = 0 , the expression (a = b) is firstly evaluated and the value is (). Next, the
expression () = 0is evaluated. Since ()cannot be an assigned to, an error is reported. Similarly, if an
assignment expression is mistakenly used in the conditional expression, because the conditional expression
is expected to have a value of type Boolwhereas the assignment values in (), an error is generated. Note
that =is non-associative, which implies that expression like a = b = 0 that contains more than one =is a
syntactic error.
main() :Int64 {
var a=1
var b=1
a=(b=0)// semantics error
if(a=5){// semantics error
}
a=b=0 // syntax error
return 0
}
The compound assignment expression a op= bcannot be seen simply as a combination of an assignment
expression and other binary operators a = a op b (where opcan be any binary operator among arithmetic,
logical and bitwise operators, and the operands aand bare of the type required by the operator op). In
Cangjie, aina op= b is evaluated only once (and the side effect occurs only once), whereas aina = a op
bis evaluated twice (and the side effect occurs twice). Since a compound assignment expression is also an
assignment expression, the compound assignment operator is also non-combining. A compound assignment
expression also requires that the two operands be of the same type.
The following examples show the usage of compound assignment expressions.
a**= b
a*=b
a/=b
a%=b
a+=b
a-=b
a<<= b
a>>= b
a&&= b
a||= b
a&=b
a^=b
a|=b
Finally, if the user overloads the **,*,/,%,+,-,<<,>>,&,^, and |operators, then Cangjie will provide
default implementation of their corresponding compound assignment operators **=,*=,/=,%=,+=,-=,<<=,
>>=,&=,^=, and |=.
3.The return type of the overloaded operator needs to be the same as or a subtype of the left operand,
i.e., as for a,b,opin the expression a op=b, they need to pass the type check of a = a op b . For
example, when there is a subtype relation A <: B <: C , if the user overloads +with type (B, Int64) ->
Bor(B, Int64) -> A , Cangjie will provide a default implementation; if the user overloads +with type
(Int64, Int64) -> A , Cangjie will not provide a default implementation.
4.We requires that the aina op= bmust be assignable, e.g., a variable.
Multi-assignment expressions are a special kind of assignment expressions. The left side of the equals
sign of a multi-assignment expression must be a tuple, the elements inside this tuple must be left-valued,
the expression on the right side of the equals sign must also be of tuple type, and the type of each element
of the right tuple must be a subtype of the left-valued type of the corresponding position. Note that when
_appears in the left tuple, it means that the result at the corresponding position of the tuple on the right
of the =is ignored (it means that the type check at this position will always pass).
Multi-assignment expressions can assign the value of the right tuple type to the corresponding left value
in the left tuple at once, eliminating the need to assign the value one by one.
main() :Int64 {
var a:Int64
var b:Int64
(a, b)=(1,2)// a == 1, b == 2
(a, b)=(b, a)// swap, a == 2, b == 1
(a, _)=(3,4)// a == 3
(_,_)=(5,6)// no assignment
return 0
}
Multi-assignment expressions can be thought of as syntactic sugar of the following form. The expressions
on the right side of the assignment expression are evaluated first, and then the left-valued parts are assigned
one by one from left to right.
main() :Int64 {
var a:Int64
var b:Int64
(a, b)=(1,2)
// desugar
let temp =(1,2)
a=temp[ 0]
b=temp[ 1]
return 0
}
4.24 Lambda Expressions
A lambda expression is a value of a function type. See the Chapter 5 Functions for more details.
4.25 Quote Expressions
A quote expression is used to reference code and represent it as an operable data object. It is mainly used
for metaprogramming. For details, see chapter 14.
4.26 Macro Call Expressions
The macro call expression is used to invoke the macro defined by Cang Jie. It is mainly used for metapro-
gramming. For details, see chapter 14.
4.27 Pass-by-reference Expression
A pass-by-reference expression can only be used in the scenario where CFuncis invoked in C interop. For
details, see the inoutparameter section in Chapter 13.
4.28 Precedence and Associativity of Operators
The value of an expression containing two or more operators is determined by the grouping rules of operators.
The grouping rules are decided by the precedence and associativity of operators. Specifically, precedence
defines the order of evaluation when there are multiple operators with different precedence in an expression,
and associativity determines how operators of the same precedence are grouped in the absence of parentheses.
If an expression contains multiple operators with different precedences, the evaluation order is: the sub-
expression containing the higher precedence operators is evaluated firstly, after which the sub-expression
containing the lower precedence operator is evaluated. In addition, for expressions containing multiple
operators with the same precedence, the evaluation order is determined by the associativity of the operator.
The following table shows the precedence, associativity, description, usage and the type of the expression
for each operator. The closer an operator is to the top of the table, the higher precedence it has.
Operator AssociativityDescription Usage Expression type
@Right as-
sociativemacro call
expression@expr1
@expr2Unit
.Left asso-
ciativeMember
accessName.name The type of name
[] Index access varName[expr] The type of the element of varName
() Function
callfuncName(expr) Return type of funcName
++None Postfix
incrementvarName++ Unit
-- Postfix
decrementvarName-- Unit
? Question
markexpr1?.expr2
etc.Option<T> (T is the type of expr2)
!Right as-
sociativeBitwise
Logic NOT!expr The type of expr
- Unary
negative-expr
**Right as-
sociativePower expr1 **
expr2The type of expr1
*Left asso-
ciativeMultiply expr1 *
expr2The type of expr1orexpr2, since expr1and expr2have
the same type
/ Divide expr1 /
expr2
Operator AssociativityDescription Usage Expression type
% Remainder expr1 %
expr2
+Left asso-
ciativeAdd expr1 +
expr2The type of expr1orexpr2, since expr1and expr2have
the same type
- Subtract expr1 -
expr2
<<Left asso-
ciativeBitwise left
shiftexpr1 <<
expr2The type of expr1, where expr1and expr2can have
different types
>> Bitwise
right shiftexpr1 >>
expr2
<None Less than expr1 <
expr2Except the type of ‘expr as userType’ is
Option<userType> , other expressions have Bool type
<= Less than or
equalexpr1 <=
expr2
> Greater
thanexpr1 >
expr2
>= Greater
than or
equalexpr1 >=
expr2
is Type check expr is
type
as Type cast expr as
userType
==None Equal expr1 ==
expr2Bool
!= Not equal expr1 !=
expr2
&Left asso-
ciativeBitwise
ANDexpr1 &
expr2The type of expr1orexpr2, since expr1and expr2have
the same type
^Left asso-
ciativeBitwise
XORexpr1 ^
expr2The type of expr1orexpr2, since expr1and expr2have
the same type
|Left asso-
ciativeBitwise OR expr1 |
expr2The type of expr1orexpr2, since expr1and expr2have
the same type
..None Range
operatorexpr1..expr2:expr3 Range type
..= expr1..=expr2:expr3
&&Left asso-
ciativeLogic AND expr1 &&
expr2Bool
||Left asso-
ciativeLogic OR expr1 ||
expr2Bool
Operator AssociativityDescription Usage Expression type
??Right as-
sociativecoalescing expr1 ??
expr2The type of expr2
|>Left asso-
ciativePipeline expr1 |>
expr2The type of expr1 |> expr2 is the type of expr2(expr1)
~> Composition expr1 ~>
expr2The type of expr1 ~> expr2 is the type of the lambda
expression {x=>expr2(expr1(x))}
=None Assignment leftValue =
exprUnit
**= Compound
assignmentleftValue
**= expr
*= leftValue
*= expr
/= leftValue
/= expr
%= leftValue
%= expr
+= leftValue
+= expr
-= leftValue
-= expr
<<= leftValue
<<= expr
>>= leftValue
>>= expr
&= leftValue
&= expr
^= leftValue
^= expr
|= leftValue
|= expr
&&= leftValue
&&= expr
||= leftValue
||= expr
Note: When ?is used together with .,(),{}or[], the evaluation order is not strictly according
to their precedence and associativity described in the table, as it is a form of syntactic sugar. See
the question mark operator for details.
## Evaluation Order of Expressions
The evaluation order of the expression specifies the order in which the operands are evaluated. Evaluation
orders are naturally only defined for expressions that contains binary operators. The evaluation orders are
defined as follows in the Cangjie programming language.
1.For expressions that contains logic AND ( &&), logic OR ( ||), and coalescing (??), the evaluation order
of is left to right. Furthermore, for eﬀiciency, the right operand is only evaluated when its value is
relevant to the value of the whole expression.
2.Foroptionalchainingexpressions,the ?separatestheexpressionintoanumberofsubexpressions,which
are evaluated in left-to-right order (the subexpression is evaluated in the order decided by operators it
used).
3.For all other expressions, such as arithmetic expressions, relational expressions and bitwise expressions
etc., the evaluation order is from left to right.Chapter 5
F unction
A function is a block of program code that deals with a specific task. A function can be identified and
invoked through a name. In the Cangjie programming language, a function is a first-class citizen, that is, a
function can be assigned to a variable, passed as a parameter, or returned as a value.
5.1 F unction Definition
In the Cangjie programming language , a function is defined with the following syntax.
functionDefinition
: functionModifierList? 'func'
identifier
typeParameters?
functionParameters
(':' type)?
(genericConstraints)?
block
;
The syntax can be summarized as follows.
•A function is declared with the keyword func.
•A function declaration may start with function modifiers that precede the keyword func.
•Following the keyword func, a function name is required.
•List of optional type parameters following the function name. The type parameter list is enclosed by
<>. Multiple type parameters are separated by comma.
•The function name is followed by one or more parameters of the function. Each parameter is enclosed
by(). For details, see Parameters
•The parameters of a function are enclosed by (). Multiple parameters are separated by comma. The
type of each parameter needs to be specified.
•The return type of the function can be declared explicitly using the syntax of : typefollowing the
parameters. Alternatively, it can be omitted and inferred by the compiler.
•A function definition must have a block (excluding the parameters) as its function body, which cannot
be omitted.
The following is an example of function definition. It does not use the access modifier to indicate that
the function can be accessible inside the package. The function name is foo. It has a parameter named aof
theInt64type, and has the return type of Int64. The function body simply returns a.
func foo(a:Int64 ):Int64 {a}
The function name cannot be assigned. That is, the function name cannot appear in the program as an
expression lvalue.
The operations in the following example are forbidden.
func f(a:Int64 ):Int64 {a}
// f = {a: Int64 => a + 1} // compile-time error
5.1.1 F unction Modifiers
5.1.1.1 Modifier of global functions
Global functions can be associated with the following modifier. Note that the default accessibility is internal.
•public: The function can be accessed in other packages.
If no accessible modifier is provided, the function can only be accessed within the current package.
public func f1():Unit {}
func f12():Unit {} // can be accessed in the current package.
5.1.1.2 Modifier of local functions
No modifiers available for local functions.
5.1.1.3 Modifier of member functions
Class member functions can have the following modifiers: public,protected ,private,static,open,override
and redef. For details, see Class Members .
Interface member functions can have the following modifiers: staticand mut. For details, see Interface
Members .
The modifiers of the struct member function include mut,public,private, and static. For details, see
Struct Type .
The modifiers of the enum member function include public,private, and static. For details, see Enum
Type.
If no accessibility modifier is provided, member functions other than interface member functions can only
be accessed within the current package, and interface member functions are public semantically by default.
5.1.2 Parameters
The sequence of parameters in the parameter list is as follows: non-named parameters, named parame-
ter(including named parameter but no default values, and parameters with default values). The syntax of
the parameter list is as follows:
functionParameters
: ('(' (unnamedParameterList (',' namedParameterList)? )? ')')
| ('(' (namedParameterList)? ')')
;
nondefaultParameterList
: unnamedParameter (',' unnamedParameter)* (',' namedParameter)*
| namedParameter (',' namedParameter)*
;
namedParameterList
: (namedParameter | defaultParameter) (',' (namedParameter | defaultParameter))*
;
namedParameter
: identifier '!' ':' type
;
defaultParameter
: identifier '!' ':' type '=' expression
;
unnamedParameterList
: unnamedParameter (',' unnamedParameter)*
;
unnamedParameter
: (identifier | '_') ':' type
;
func bar(a:Int64 ,b!:Float64 =1.0,s!:String) {} // OK
func bar2 (a:Int64 =1,b!:Float64 =1.0,s:String ="Hello" ){} // Error
func foo(a:Int64 ,b:Float64 )(s:String ="Hello" ){} // Error
func f1(a:Int64 ,_:Int64 ):Int64 {
return a+1
}
func f2(_:String) :Unit {
print( "Hello Cangjie" )
}
Parameters defined in the parameter list are all immutable variables, i.e. they are defined with letand
cannot be assigned within the function definition.
func foo(a:Int64 ,b:Float64 ){
a=1 // Error: the parameter 'a' is immutable, and cannot be assigned.
b=1.0 // Error: the parameter 'b' is immutable, and cannot be assigned.
}
It is worth noting that parameter types are not affected by whether they are named parameters or have
default values (see the following sections) and when it comes to parameter types, a type and its aliases are
regarded the same (parameter type).
5.1.2.1 Named parameters
When defining a function, add !to the end of a parameter name to define the named parameter.
namedParameter
: identifier '!' ':' type
;
•When the function is declared, non-named parameters must precede all named parameters.
func add1 (a:Int32 ,b!:Int32 ):Int32 {a+b}// ok
func add2 (a!:Int32 ,b:Int32 ):Int32 {a+b}// error
•If a parameter is a named parameter, you need to specify the parameter name with the prefix parameter
name:before the argument value when calling the function. Otherwise, an error is reported during
compilation.
func add(a:Int32 ,b!:Int32 ):Int32 {a+b}
add( 1,b:2)// ok
add( 1,2) // error
•If an abstract function or open-modified function has named formal parameters, then an implementa-
tion function or override-modified function needs to keep the same named formal parameters.
open class A{
open func f(a!:Int32 ):Int32 {
return a+1
}
}
class B<:A {
override func f(a!:Int32 ):Int32 {// ok
return a+1
}
}
class C<:A {
override func f(b!:Int32 ):Int32 {// error
return b+1
}
}
5.1.2.2 Default Values of Parameters
Function parameters may have default values. Default values are declared with =as shown in the example
below. If a default value is defined for a parameter, the function can be invoked without providing that
parameter value. Such parameters are referred to as optional parameters .
When defining a function, you must add !to the end of the optional parameter name because optional
parameters are a kind of named parameters. Otherwise, an error is reported during compilation.
defaultParameter
: identifier '!' ':' type '=' expression
;
In the following example, the parameter list of function addis(Int32,Int32) . The default value of bis
set to be 1. When addis invoked and only one value 3is provided as the parameter value, 3is assigned to
the parameter aand the default value 1is assigned to the parameter b. As a result, 4is returned.
If two parameter values 3and 2are provided, bis assigned to 2.
func add(a:Int32 ,b!:Int32 =1):Int32 {a+b}
add( 3) // invoke add(3, 1), return 4
add( 3,b:2) // return 5
•Only the first parameter list of a currying function may have optional parameters.
•Functions explicitly or implicitly modified by the openkeyword in a class or interface cannot have
optional parameters.
•Operator functions cannot have optional parameters.
•Anonymous function￿lambda expression￿ cannot have optional parameters.
•The name introduced in the default value of a function parameter is obtained from the static scope,
that is, the names introduced by default value is the names that can be accessed when the function is
defined.
•Parameters and their default values of a function do not belong to the function’s body.
•The names introduced in the default value, does not need to have the same or least restrictive accessi-
bility of the function.
•The default value of the parameter is evaluated when the function is called, not when the function is
defined.
•When a function is called, the parameter values are evaluated from left to right according to the
sequence of definition. The default value of a function parameter can reference the formal parameter
defined before the parameter.
•When a function is called, can use the default value. When a function is called by using a variable
name, arguments cannot be optional.
// Compile-time error.
// func f(a: Int32, b!: Int32 = 2, c: Int32): Int32 { ... }
// OK.
func f1(a:Int32 ,b:Int32 ,c!:Int32 =3,d!:Int32 =4):Int32 {
a+b+c+d
}
func test (){
f1(1,2) // 10, f1(1, 2, 3, 4)
f1(1,2,c:5) // 12, f1(1, 2, 5, 4)
}
/* The names introduced in the default value, does not need to have the same or least
restrictive accessibility of the function. */ ↪
var x=10
var y=10
func g(){}
public func f2(a!:Int64 =x*2+y,b!:()->Unit =g){} // OK.
class AAA {
static private var x=10
func f(a!:Int64 =x){// OK, public method can use private static field.
print( "${a}")
x=x+10
print( "${x}")
}
}
/* Only the first parameter list of a currying function may have optional parameters. */
func f3(x:Int32 ,y!:Int32 =x){x}// OK.
func f4(x:Int32 )(y!:Int32 =x){x} // Error.
/*
When a function is called, the name in the function declaration can use the default value. When
a function is called by using a variable name, arguments cannot be optional. ↪
*/
func f1():(Int64 )->Unit {g1}
func g1(a!:Int64 =42){
print( "g1: ${a}")
}
let gg1 =f1()
let x=gg1() // Error, cannot ommit the argument.
let gg3 =g1
let a=gg3() // Error, cannot ommit the argument.
Since parameters and their default values of a function do not belong to the function’s body, the return
expression in the following example lacksits enclosing function body—it belongs to neither the outer function
f(because the definition of the inner function ghas started) nor the inner function g’s body:
func f(){
func g(x!:Int64 =return ){// Error: return must be used inside a function body
0
}
1
}
5.1.3 F unction Body
The body of a function consists of a block.
5.1.3.1 Local Variables
In the Cangjie programming language , variables declared in a function body are called local variables. Local
variables can be similarly declared with varorlet. In the latter case, the variables are immutable.
func foo():Unit {
var a=1
let b=1
}
5.1.3.2 Nested Function
Functions can be declared in a function body. Such functions are referred to as nested functions. Nested
functions can capture variables and other nested functions, which are defined in the function body. Nested
functions support recursion.
func foo():Unit {
func add(a:Int32 ,b:Int32 ){a+b}
let c=1
func nest ():Unit {
print( "${c}") // 1
var b=add( 1,2) // b = 3
}
}
5.1.4 Return Type
The return type of a function can be either
•Any type described in Chapter 2
•a tuple type , in which case multiple values can be returned at the same time in the form of a tuple.
In the following example, the function returns a tuple (a, b)and the return type is (Int32, Int32)
func returnAB (a:Int32 ,b:Int32 ):(Int32 ,Int32 ){(a, b)}
•a function type , in which case the return value is a function. In the following example, the return
value is a function of type (Int32, Int32) -> Int32 .
func returnAdd (a:Int32 ,b:Int32 ):(Int32 ,Int32 )->Int32 {
return {a, b=>a+b} // Return a lambda expression.
}
The return type of a function can be specified using the :Typesyntax after the parameter lists of the
function definition. In this case, the type of the function body and the type of einreturn e expressions
in the function body are required to be subtypes of the annotated type (i.e., Type), otherwise a compilation
error is raised.
class A{}
class B<:A {}
// Return is not written.
func add(a:Int32 ,b:Int32 ):B{
var c=a+b
if(c>100){
return B()
}else {
return A() // Compilation error since A is not a subtype of B.
}
}
Specifically, if the return type of a function is specified as Unit(such as func f(x:Bool):Unit { x } ), the
compilier compiler will automatically insert return () at all possible places where the function could return
in the function body, so that the return type of the function is always Unit. Examples are as follows.
func Column (c:(Data) ->Unit ):Unit {2}// return () is automatically inserted
func Column (c:(Data) ->Unit ){2} // return type is Int64
If the return type of a function is not specified, the compiler will jointly derive the return type of the
function based on the type of the function body and all returnexpressions in the function body. This process
is not complete; for example, the compiler will raise an error if asked to infer the return types of (mutually)
recursive functions. (Note: It is not possible to derive the return type for a function that does not have a
function body.)
The rules for deriving the return type of a function are as follows: the function body is a sequence of
expressions and declarations; we denote the type of the last item of the sequence as T0(if the last item of
the block is an expression, it is the type of the expression; if the last item is a declaration, then T0 = Unit ).
Then we find all the return e expressions in the function body (including the ones in all sub-expressions)
and denote the type of easT1 ... Tn . The return type of the function is the least common super type of
T0, T1, ..., Tn . If the least common super type does not exist, a compilation error is reported. Here is an
example:
class Base {}
class Child <:Base { }
func f(a:char) {
if(false ){
return Base()
}
return Child()
}
•The type of the function body is the type of the last item of the block, i.e. the type of return Child() ,
which is of type Nothing.
•The type of ein the first return e expression, i.e. return Base() , isBase.
•The type of ein the second return e expression, i.e. return Child() , isChild.
•Since the lease common super type of Nothing,Base,ChildisBase, the return type of the function is
Base.
Note that the return value of a function has the semantics that defined by let.
5.1.5 F unction Declaration
In Cangjie programming language, the difference between function declaration and function definition is that
the former has no function body. The syntax of the function declaration is as follows:
functionDefinition
: functionModifierList? 'func'
identifier
typeParameters?
functionParameters
(':' type)?
genericConstraints?
;
Function declarations can appear in abstract classes and interfaces.
5.1.6 F unction Redefinitions
Non-generic functions of the same name with the same parameter types in the same scope are considered to
be redefined and a compilation error will be raised. Extra care should be taken in the following cases.
•Functions of the same name constitute redefinitions even if their return types differ.
•Generic and non-generic functions of the same name never constitute redefinition.
•Regarding inheritance, for a function in a subclass with the same name and exactly the same parameter
type as the parent class, if its return type is a subtype of the version in the parent class, it constitutes
an override and does not constitute a redefinition. (This is because the subclass has a scope different
from the parent class.)
Two generic functions constitute redefinitions if the following holds: there exists a renaming such that
after we rename one function’s generictype parameters, the two functions’ non-generic parts constitute
redefinitions. Examples:
1.The following two functions constitute redefinitions because there exists a renaming [T1 |-> T2] (onto
the first function) such that the non-generic parts of the two functions constitute redefinitions.
func f<T1>(a:T1) {}
func f<T2>(b:T2) {}
2.The following two functions do not constitute redefinitions because there does notexist any renaming
such that the non-generic parts of the two functions constitute redefinitions.
func f<X,Y>(a:X,b:Y){}
func f<Y,X>(a:X,b:Y){}
3.The following two functions constitute redefinitions because there exists a renaming [X |-> Y, Y |->
X]such that the non-generic parts of the two functions constitute redefinitions.
func f<X,Y>(a:X,b:Y){}
func f<Y,X>(a:Y,b:X){}
5.2 F unction Types
Each function has a specific type, which is determined by the types of its parameters (hereafter parameter
type) and its return type, written in the form of parameterType -> returnType .
functionType:
: '(' (type (, type)*)? ')' '->' type
The following illustrates the types of some example functions.
•Example 1: No parameter and the return type is Unit.
func hello ():Unit {print( "Hello!" )}
// function type: () -> Unit
•Example 2: The parameter type is Int32and the return type is Unit.
func display (a:Int32 ):Unit {print( "${a}")}
// function type: (Int32) -> Unit
•Example 3: The parameters’ types are both Int32and the return type is Int32.
func add(a:Int32 ,b:Int32 ):Int32 {a+b}
// function type: (Int32, Int32) -> Int32
•Example 4: The parameters’ types are ((Int32, Int32) -> Int32 ,Int32, and Int32and the return
type is Unit.
func printAdd (add :(Int32 ,Int32 )->Int32 ,a:Int32 ,b:Int32 ):Unit {
print( "${add(a, b)}")
}
// function type: ((Int32, Int32) -> Int32, Int32, Int32) -> Unit
•Example 5: The parameters’ types are both Int32and the return type is (Int32, Int32) -> Int32 .
func returnAdd (a:Int32 ,b:Int32 ):(Int32 ,Int32 )->Int32 {
{a, b=>a+b}
}
// function type: (Int32, Int32) -> (Int32, Int32) -> Int32
•Example 6: The parameters’ types are both Int32and the return type is (Int32, Int32) .
func returnAB (a:Int32 ,b:Int32 ):(Int32 ,Int32 ){(a, b)}
// function type: (Int32, Int32) -> (Int32, Int32)
5.3 F unction Invocation
For details about the syntax of function invocation expressions, see Function Invocation Expres-
sions](#Function Invocation Expressions).
5.3.1 Named arguments
Named arguments are arguments with argument-name : prefix. Unnamed arguments must precede all named
arguments.
The syntax of named arguments can only be used when the name of corresponding parameters are
followed by the symbol !in the function definition, otherwise the syntax of named arguments cannot be
used.
When a function is invoked, all named parameters must be forwarded using named arguments. Otherwise,
an error is reported.
When a function is invoked, positional arguments are not allowed after the named arguments. Otherwise,
a compile error is reported.
Named arguments free you from matching the order of parameters in the parameter lists of called func-
tions.
func add(a!:Int32 ,b!:Int32 ):Int32 {
a+b
}
var sum1 =add( 1,2) // error
var sum2 =add(a :1,b:2)// OK, 3
var sum3 =add(b :2,a:1)// OK, 3
5.3.2 Type Checking of F unction Invocation
This section describes the type checking required for a given call expression. If the invoked function involves
overloading, then the overload resolution rules are applied according to Function Overloading .
1￿If type arguments are specified in the function call expression, only functions whose type parameters
quantity is the same as specified type arguments may pass the type checking. For example, assuming that
function call expression is f<T1, ..., Tm>(A1, ..., An) , and m type arguments are specified, the function
who pass the type checking must have m type parameters.
open class Base {}
class Sub <:Base {}
func f<X,Y>(a:X,b:Y){} // f1
func f<X>(a:Base, b:X){} // f2
f<Base >(Base(), Sub()) // f2 may pass the type checking
2￿Type checking based on the arguments in the call expression and the return type Trspecified in the
context of the call expression.
Assume that the function is defined as:
𝑓𝑖< 𝑇𝑖1, ..., 𝑇𝑖𝑝> (𝐴𝑖1, ..., 𝐴𝑖𝑘) ∶ 𝑅𝑖𝑤ℎ𝑒𝑟𝑒 𝐶𝑖1, ..., 𝐶𝑖𝑞𝑖
1) If the invoking expression contains the type argument fi<T1, ..., Tp>(A1, ..., Ak) , the
rule for checking the type of the fifunction is as follows:
a) First, check constraints of the type parameters: the type arguments `<T1, ..., Tp>` must meet
the type constraints of the `fi` function. ↪
𝜎 = [𝑇1↦ 𝑇𝑖1, ..., 𝑇𝑝↦ 𝑇𝑖𝑝]
Δ ⊢ 𝜎 𝑠𝑜𝑙𝑣𝑒𝑠 𝐶𝑖1, ..., 𝐶𝑖𝑞𝑖
b) Parameter type checking: after the type arguments are substituted into the parameters of the function
fi, the argument types (A1, ..., Ak) is the subtype of the type after the type arguments are substituted
into the parameters.
𝜎 = [𝑇1↦ 𝑇𝑖1, ..., 𝑇𝑝↦ 𝑇𝑖𝑝]
Δ ⊢ (𝐴1, ..., 𝐴𝑘) <∶ 𝜎(𝐴𝑖1, ..., 𝐴𝑖𝑘)
c) Check the type of the return type : If the context of the calling expression has a specific type requirement
R, after the type arguments are substituted into the return type Riof the function fi, the return type after
substituted is the subtype of R.
𝜎 = [𝑇1↦ 𝑇𝑖1, ..., 𝑇𝑝↦ 𝑇𝑖𝑝]
Δ ⊢ 𝜎𝑅𝑖<∶ 𝑅
2) If the calling expression does not contain any type argument f(A1, ..., An) , the type
checking rules for the function fiare as follows:
a) If `fi` is a non-generic function, check the type according to the following rules:
i. Parameter type checking: The argument type `(A1, ..., Ak)` is the subtype of the
parameter type. ↪
Δ ⊢ (𝐴1, ..., 𝐴𝑘) <∶ (𝐴𝑖1, ..., 𝐴𝑖𝑘)
ii. Check the type of the return type: If the context of the calling expression has a specific type requirement
R, check whether the return type Riof the function fiis a subtype of R.
Δ ⊢ 𝑅𝑖<∶ 𝑅
open class Base {}
class Sub <:Base {}
func f(a:Sub) {1}// f1
func f(a:Base) {Base()} // f2
let x:Base =f(Sub()) // f2 can pass the type checking
b) If `fi` is a generic function, check the type according to the following rules:
i. Parameter type check: there is substitution exists so that argument type `(A1, ...,
Ak)` is the subtype of the type after the parameter type is replaced substituted. ↪
𝜎 = [𝑇1↦ 𝑇𝑖1, ..., 𝑇𝑝↦ 𝑇𝑖𝑝]
Δ ⊢ (𝐴1, ..., 𝐴𝑘) <∶ 𝜎(𝐴𝑖1, ..., 𝐴𝑖𝑘)
ii. Check the type of the return type: If the context of the calling expression has a specific type requirement
R. Replace i) with the return type Riof the function fi, the return type after substitution is a subtype of R.
𝜎 = [𝑇1↦ 𝑇𝑖1, ..., 𝑇𝑝↦ 𝑇𝑖𝑝]
Δ ⊢ 𝜎𝑅𝑖<∶ 𝑅
Note the following:
1.If the function has a default value, parameters whose default values are not specified are not involved
in the overload resolution.
2.If a function has named arguments, the sequence of the named arguments may be different from that of
the parameters. During type checking, the named argument must correspond to the named parameter
that matches the name.
5.3.3 T railing Lambda
When the last real parameter of a function call is a lambda, we can use the trailing closure syntax to place
the lambda at the end of the function call, outside of brackets.
func f(a:Int64 ,fn:(Int64 )->Int64 ){fn(a) }
f(1,{i=>i*i})// normal function call
f(1){i=>i*i}// trailing lambda
We can also omit ()and just write lambda when the function call has one and only one lambda real
parameter.
func f(fn:(Int64 )->Int64 ){fn(1)}
f{i=>i*i}
If trailing lambda does not contain parameters, =>can be omitted.
func f(fn:()->Int64 ){fn() }
f{i*i}
Note that the trailing closure syntax can only be used on function calls with function/variable names,
and that the lambda expression of a trailing closure will only be interpreted as the last argument of the
function corresponding to the function/variable name. This means that the following two call examples are
not legal.
func f():(()->Unit )->Unit {
{a=>}
}
f() {}// error, the lambda expression is not argument for f.
func g(a:()->Unit ){}
if(true ){g}else {g}(){}// error, illegal trailing closure syntax
The above expression must be assigned to the variable first, and the trailing closure syntax can only be
used when called with the variable name. As shown in the following code.
let f2=f()
f2{}// ok
let g2=if(true ){g}else {g}
g2() {}// ok
Both normal function calls and constructor calls can use this syntax, containing this()and super().
this (1,{i=>i*i})
this (1){i=>i*i}
super( 1,{i=>i*i})
super( 1){i=>i*i}
5.3.4 V ariable-Length Arguments
Variable-length arguments are a special kind of function call syntactic sugar. When the last non-named
parameter is of Arraytype, the corresponding position in the arguments can be passed directly using a
sequence of arguments instead of an Arrayliteral.
1.There is no special declaration syntax for variable-length argument, as long as the last non-named
parameter at the function declaration is of type Array.
2.Variable-length arguments can be used to pass elements of an array one by one in the form of a normal
argument list when the function is called.
3.Only the last position of the non-named parameter can use variable-length argument. Named param-
eters cannot use this syntactic sugar.
4.Variable-length arguments are available for calls to global functions, static member functions, instance
member functions, local functions, constructors, function variables, lambda, function call operator
overloads, and indexing operator overloads. Other operator overloads, compose, and pipeline calls are
not supported.
5.The number of variable-length arguments can be 0 or more.
6.Variable-length arguments only determine whether the syntactic sugar can be applied if all cases of
function overloading do not match, with the lowest priority.
func f1(arr :Array <Int64 >){}
func f2(a:Int64 ,arr:Array <Int64 >){}
func f3(arr :Array <Int64 >,a:Int64 ){}
func f4(arr1 !:Array <Int64 >,a!:Int64 ,arr2 !:Array <Int64 >){}
func g(){
let li=[1,2,3]
f1(li)
f1(1,2,3)// using variable length argument
f1() // using variable length argument
f2(4,li)
f2(4,1,2,3)// using variable length argument
f3(1,2,3)// error, Array is not the last parameter
f4(arr1 :1,2,3,a:2,arr2 :1,2,3)// error, named parameters cannot use variable length
argument ↪
}
The function overloading resolution will always give preference to functions that can be matched without
using variable-length arguments, and will only try to use variable-length argument resolution if all functions
cannot be matched.
The compiler will report an error when it cannot resolve.
open class A{
func f(v:Int64 ):Unit {// f1
}
}
class B<:A {
func f(v:Array <Int64 >):Unit {// f2
}
}
func p1(){
let x=B()
x.f( 1)// call the f1
}
func g<T>(arg :T):Unit {// g1
}
func g(arg :Array <Int64 >):Unit {// g2
}
func p2(){
g(1)// call the g1
}
func h(arg :Any) :Unit {// h1
}
func h(arg :Array <Int64 >):Unit {// h2
}
func p3(){
h(1)// call the h1
}
5.4 F unction Scope
Functions can be declared at the top level or within other functions.
•Global functions
A function that is declared at the top level is called a global function. Its scope is global, i.e., it is
accessible globally. In the following example, the function globalFunction is a global function.
func globalFunction (){}
•Nested functions
A function declared in a function body is a nested function. Its scope is local, for details, see Scopes.
i.e., it is accessible only with the function body. As shown in the following example, the function
nestedFunction is a nested function and Its scope starts from the definition and ends at the end of the
globalFunction function body.
func globalFunction (){
func nestedFunction (){}
}
•Member functions
Member functions can be declared or defined in the type definition. The scope of a member function
is the entire type and its extensions.
interface Myinterface {
func foo():Unit
static func bar():Unit
}
class MyClass {
func foo(){}
static func bar(){}
}
•Extension member functions
Additional member functions can be declared in the extension. Its scope is all extensions of the type
being extended, while being limited by access modifiers.
extend MyType {
func foo():Unit
}
5.5 Lambda Expressions
A Lambda expression is an expression that represents an anonymous function.
The syntax of a Lambda expression is as follows.
lambdaExpression
: '{' NL* lambdaParameters? '=>' NL* expressionOrDeclarations '}'
;
lambdaParameters
: lambdaParameter (',' lambdaParameter)* ','?
;
lambdaParameter
: (identifier | '_') (':' type)?
;
There are two forms of lambda expressions, {a: Int64 => e1; e2 } with a formal parameter and { =>
e1; e2 } without a formal parameter (e1 and e2 are expressions or sequences of declarations).
let f1:(Int64 ,Int64 )->Int64 ={a:Int64 ,b:Int64 =>a+b}
var f2:()->Int32 ={=>123 }
let f2={n:Int64 ,_:Int64 =>return n*n}
let f3:(Int32 ,Int32 )->Int32 ={n, _=>return n*n}
let f4:(String) ->String ={_=>return "Hello" }
Lambda expressions cannot be marked with a return type; the compiler will perform type inference on
the Lambda to determine the return type.
•If the context explicitly specifies a return type for the lambda expression, then the return type of the
lambda expression is the one specified by the context. If the specified return type is Unit, the Cangjie
compiler will also insert return () (in the lambda body) properly at all possible places where the
lambda could return so that its return type will always be Unit. The following is an example in which
theUnitreturn type is specified:
func Column (c:(Data) ->Unit ){...}
func Row(r:(Data) ->Unit ){...}
func Build ():Unit {
Column {
Row {
BuildDetail()
BuildCalendar()
}// OK. Well typed since 'return' is inserted.
width( 750)
height( 700)
backgroundColor( "#ff41444b" )
}// OK. Well typed since 'return' is inserted.
}
•If no such context exists, the type of the expression on the right side of =>is treated as the return type.
The type annotation of parameters in Lambda expressions can be defaulted, and the compiler will try to
infer the type from the context, and will report an error when the compiler cannot infer the type.
var sum1 :(Int32 ,Int32 )->Int32 ={a, b=>a+b}
var sum2 :(Int32 ,Int32 )->Int32 ={a:Int32 ,b=>a+b}
var display ={=>print( "Hello" )}
var a={=>return 1}
The content on the right side of =>is the same as the rules for normal function bodies, and again return
can be omitted. If the right-hand side of =>is empty, the return value is ().
sum1 ={a, b=>a+b}
sum2 ={a, b=>return a+b} // Same as that in the previous line.
Lambda expressions can be invoked in place. Here are some examples.
let r1={a:Int64 ,b:Int64 =>a+b}(1,2)// r1 = 3
let r2={=>123 }() // r2 = 123
5.6 Closures
A closure is a self-contained function or lambda. A closure can capture variables from the static scope that
defines it. You can access the variables, even if the original scope that defined the variables no longer exists.
Variable capture occurs when the closure is defined.
The following scenarios are not variable captures:
•Access to local variables defined in the function or the lambda;
•Access to parameters of the function or the lambda;
•Access of global variables and static member variables in a function or lambda;
•Access of instance member variables in instance member functions. Since the instance member function
passes thisas a parameter, all instance member variables are accessed through thiswithin the instance
member function.
Variables can be captured in the following scenarios:
•Capturing variables declared by let: The values of these variables cannot be modified in closures. If
the captured variable is of reference type, you can modify the value of its variable instance member
variable. A function or lambda that only captures immutable local variables can be used as a first-class
citizen, that is, can be assigned to a variable, can be used as an argument or a return value, and can
be used as an expression.
•Capturing variables declared by var: The function or lambda that captures mutable variables can only
be invoked and cannot be used as a first-class citizen, including cannot be assigned to a variable, cannot
be used as an argument or return value, cannot be used as an expression.
Note that capture is transitive. If function gcaptures any mutable variable, and function f
invokes the function g, and some of the varvariables captured by gare not defined in the f
function, then falso captured mutable variables.
In the following example, honly captures the variable ydeclared by let, then hcan be used as a first-class
citizen:
func f(){
let y=2
func h(){
print(y) // OK, captured an immutable variable.
}
let d=h // OK, h can be assigned to variable
return h // OK, h can be a return value
}
In the following example, gcaptures the variable xdeclared by var, then gcannot be used as a first-class
citizen and can only be invoked.
func f(){
var x=1
func g(){
print(x) // OK, captured a mutable variable.
}
let b=g// Error, g cannot be assigned to a variable
g// Error, g cannot be used as an expression
g() // OK, g can be invoked
// Lambda captured a mutable variable, cannot be assigned to a variable
let e={=>print( "${x}")}// Error
let i={=>x*x}() // OK, lambda captured a mutable variable, can be invoked.
return g// Error, g cannot be used as a return value.
}
In the following example, gcaptures the variable xdeclared by var,finvokes g, and xcaptured by gis
not defined in f, then fcannot be used as a first-class citizen:
func h(){
var x=1
func g(){x} // captured a mutable variable
func f(){
g() // invoked g
}
return f// error
}
In the following example, gcaptures the variable xdeclared by var, and fcalls g. However, xcaptured
bygis defined within f, and fdoes not capture other variables declared by var. Thus, fcan be used as a
first-class citizen:
func h(){
func f(){
var x=1
func g(){x} // captured a mutable variable
g()
}
return f// ok
}
Therefore, a function or lambda that accesses a global variable, static member variable, instance member
variable modified by varcan still be used as a first-class citizen.
class C{
static var a:Int32 =0
static func foo(){
a++ // OK
return a
}
}
var globalV1 =0
func countGlobalV1 (){
globalV1 ++
C.a =99
let g=C.foo // OK
}
func g(){
let f=countGlobalV1 // OK
f()
}
The following rules must be met for captured variables:
•The captured variable must be visible in the closure definition. Otherwise, an error is reported during
compilation.
•The variable must be initialized before being captured. Otherwise, an error will be reported during
compilation.
•If there is a variable outside a function has the same name as a local variable within the function, the
variable outside the function is captured because the scope of the local variable does not start when
the closure is defined. A warning is reported.
// 1. The captured variable must be defined before the closure.
let x=4
func f(){
print( "${x}") // Print 4.
let x=99
func f1(){
print( "${x}")
}
let f2={=>
print( "${x}")
}
f1() // Print 99.
f2() // Print 99.
}
// 2. The variable must be initialized before being captured.
let x=4
func f(){
print( "${x}") // Print 4.
let x:Int64
func f1(){
print( "${x}") // Error: x is not initialized yet.
}
x=99
f1()
}
// 3. If there is a local variable in a block, closures capture variables of the same name in
the outer scope will report a warning. ↪
let x=4
func f(){
print( "${x}") // Print 4.
func f1(){
print( "${x}") // warning
}
let f2={=>
print( "${x}") // warning
}
let x=99
f1() // print 4
f2() // print 4
}
5.7 F unction Overloading
5.7.1 F unction Overloading Definition
In the Cangjie programming language, overloading occurs when function definitions corresponding to the
same function name in a scope do not constitute function redefinition. When an overload exists, it is
necessary to identify which function definition is used when making a function call based on the contextual
information and the argument types of the function call.
Overloaded functions must comply with the following rules:
•The function name must be the same and one of the following conditions must be met:
–Function names introduced by the keyword func.
–Constructors defined within a class or struct, including primary constructor and initconstructors.
•The parameter type must be different and one of the following conditions must be satisfied:
–The number of function parameters are different.
–The number of functions parameters are the same, but the parameter types at the corresponding
positions are different.
–Must be visible in a scope.
It is worth noting that parameter types are not affected by whether they are named parameters or have
default values and when it comes to parameter types, a type and its aliases are regarded the same (parameter
type). The parameter types of the four functions in the following example are the same:
type Boolean =Bool
func f(a:Bool ){}
func f(a!:Bool ){}
func f(a!:Bool =false ){}
func f(a!:Boolean) {}
Note that
•overloading occurs only between functions of the same name declared by funcdeclaration, or between
constructors within a type.
In the following example, function overloading occurs at the top level since there are two functions named
fbut with different parameter types.
// f overloading
func f(){...}
func f(a:Int32 ){...}
In the following example, functions f1in interface I, class C1and C2are overloading.
interface I{
func f1(){...}
}
open class C1{
func f1(a:Int32 ){...}
}
class C2<:C1&I{
// f1 overloading
func f1(a:Int32 ,b:String) {...}
}
In the following example, constructors in class Care overloading.
class C{
let name :String ="abc"
// constructor overloading
init (){
print(name)
}
init (name :String){
this .name =name
}
}
In the following example, the number of function parameters is the same, and the types in the same
position are the same. Only the constraints of the type parameters contained in the parameter types are
different, which are not overloaded functions.
interface I1{}
interface I2{}
func f<T>(a:T)where T <: I1 {}
func f<T>(a:T)where T <: I2 {} // Error, not overloading
5.8 Mut functions
The mut function is a special kind of instance member function. Inside the mut function, the semantics
ofthisis special, and this thishas the ability to modify the field in-place, with the changes taking effect
immediately. We can use this feature to give struct type instance functions the ability to modify themselves
for special scenarios.
5.8.1 Definition
Mut functions are modified with the mutkeyword, are only allowed to be defined in the interface, struct
and struct extensions, and can only act on instance member functions (static member functions are not
supported).
struct A{
mut func f():Unit {}// ok
mut static func g():Unit {}// error
mut operator func +(rhs :A):A{// error
return A()
}
}
extend A{
mut func h():Unit {}// ok
}
class B{
mut func f():Unit {}// error
}
interface I{
mut func f():Unit // ok
}
The mut function allows you to assign values to the fields of a struct instance, and these assignments
modify the instance and take effect immediately. As with the instance member functions, thisis not required
and can be inferred by the compiler.
struct Foo {
var i=0
mut func f(){
this .i+=1// ok
i+=1// ok
}
}
main() {
var a=Foo()
print(a.i) // 0
a.f()
print(a.i) // 2
a.f()
print(a.i) // 4
return 0
}
thisin a mut function cannot be captured (meaning the fields of the current instance cannot be captured
either), nor can it be used as an expression.
struct Foo {
var i=0
mut func f():Foo {
let f1={=>this }// error
let f2={=>this .i=2}// error
let f3={=>this .i}// error
let f4={=>i}// error
return this // error
}
}
5.8.2 The mut function in the interface
struct types must maintain the same mutmodifier when implementing functions of the interface. Types other
than struct are prohibited from using the mutmodifier when implementing functions of the interface.
interface I{
mut func f1():Unit
func f2():Unit
}
struct A<:I{
mut func f1():Unit {}// ok
func f2():Unit {}// ok
}
struct B<:I{
func f1():Unit {}// error
mut func f2():Unit {}// error
}
class C<:I {
func f1():Unit {}// ok
func f2():Unit {}// ok
}
Notethatwhenaninstanceofstructisassignedtoaninterfacetype, itiscopysemantics, sotheinterface’s
mut function does not modify the value of the original struct instance.
interface I{
mut func f():Unit
}
struct Foo <:I{
var v=0
mut func f():Unit {
v+=1
}
}
main() {
var a=Foo()
var b:I=a
b.f()
print(a.v) // 0
return 0
}
5.8.3 Access Rules
If a variable is declared with letand may be of type struct (including static types that are of type struct,
or type variants that may be of type struct), then the variable cannot access functions of that type that are
modified with mut. In all other cases, access is allowed.
interface I{
mut func f():Unit
}
struct Foo <:I{
var i=0
mut func f():Unit {
i+=1
}
}
class Bar <:I {
var i=0
func f():Unit {
i+=1
}
}
main() {
let a=Foo()
a.f() // error
var b=Foo()
b.f() // ok
let c:I=Foo()
c.f() // ok
return 0
}
func g1<T>(v:T):Unit where T <: I {
v.f() // error
}
func g2<T>(v:T):Unit where T <: Bar &I{
v.f() // ok
}
If a variable may be of type struct (including static types that are of type struct, or type variants that
may be of type struct), then the variable cannot use functions of that type modified with mutas higher-order
functions, and only these mut functions can be called.
interface I{
mut func f():Unit
}
struct Foo <:I{
var i=0
mut func f():Unit {
i+=1
}
}
class Bar <:I {
var i=0
func f():Unit {
i+=1
}
}
main() {
var a=Foo()
var fn=a.f // error
var b:I=Foo()
fn=b.f // ok
return 0
}
func g1<T>(v:T):Unit where T <: I {
let fn=v.f // error
}
func g2<T>(v:T):Unit where T <: Bar &I{
let fn=v.f // ok
}
Non-mut instance member functions (including lambda expressions) cannot access mut functions of this,
and vice versa.
struct Foo {
var i=0
mut func f():Unit {
i+=1
g() // ok
}
func g():Unit {
f() // error
}
}
interface I{
mut func f():Unit {
g() // ok
}
func g():Unit {
f() // error
}
}Chapter 6
Class and Interface
6.1 Class
6.1.1 Class Definition
In the Cangjie programming language , a class is defined using the classkeyword. A class definition consists
of the following parts.
•optional modifiers
•theclasskeyword
•class name
•optional type parameters
•optional superclass or a list of super interfaces (listed after <:, and seperated by &). Superclass should
be listed at the beginging if there is one.
•optional generic constraints using keyword where
•class body
Classes can be only defined at the top level of a file. The syntax of a class definition is as follows.
classDefinition
: classModifierList ?'class ' identifier
typeParameters ?
('<:' superClassOrInterfaces) ?
genericConstraints ?
classBody
;
superClassOrInterfaces
: classType ( '&' superInterfaces) ?
|superInterfaces
;
The following example defines a class.
interface I1<X>{}
interface I2{}
open class A{}
// The following class B inherits class A and implements interface I2.
open class B<:A&I2{}
/* The following class C declares 1 type parameters U. It inherits B and implements interfaces
I1<U> and I2. Also, its type parameters have constraints U <: A */ ↪
class C<U><:B&I1<U>&I2where U <: A {}
6.1.1.1 Class Modifiers
In the following, we introduce the modifiers for classes.
Access Modifier
•Access modifier: If no access modifier is used when defining a class, then the class can only be accessed
inside the package. Also, class can be declared with modifier public, then it can be accessed outside
the package.
public class C1{} // can be accessed outside the package
class C2{} // can only be accessed inside the package
Inheritance modifiers
•open: A class modified with opencan be inherited.
/* The following class is declared with modifier `open`, indicating that it can be inherited.
*/ ↪
open class C1{
func foo():Unit {
return
}
}
class C2<:C1 {}
Non-abstract classes without openmodifiers cannot be inherited.
–sealed: You can use the sealedmodifier to indicate that the class can be inherited only in the
package which the class is defined.
–The publicmodifier is optional when defining a sealed class because the semantics of publicare
already implied by sealed.
–Subclasses of a sealed class may be modified by open/sealed, or may not use any inherited mod-
ifiers. If a subclass of a sealedclass is modified by public open , its subclass can be inherited
outside the package.
–Subclasses of sealed may not be modified by public.
// package A
package A
public sealed class C1{} // OK
sealed class C2{} // OK, 'public' is optional when 'sealed' is used
class S1<:C1 {} // OK
public open class S2<:C1 {} // OK
public sealed class S3<:C1 {} // OK
open class S4<:C1 {} // OK
// package B
package B
import A.*
class SS1 <:S2 {} // OK
class SS2 <:S3 {} // Error, S3 is sealed class, cannot be inherited here.
Note that:
Non-abstract classes without openorsealedmodifiers cannot be inherited.
Abstract class modifier
•abstract : This class is an abstract class. Unlike a common class, an abstract class can define common
functions and declare abstract functions. Only the class modified by this modifier is an abstract class.
If a function has no body, we call it an abstract function.
Note that:
–An abstract class can always be inherited, so the modifier openis optional when defining
abstract classes. Also, you can use sealedmodifier.
–Private abstract functions cannot be declared in abstract classes.
–An abstract class cannot be instantiated.
–An abstract subclass of an abstract class is not required to implement abstract functions
in its superclass.
–A non-abstract subclass of an abstract class must implement all abstract functions in its
superclass.
6.1.1.2 Class Inheritance
Only single inheritance between classes are supported. The superclass is declared by <: superClass after the
class name. Note that the superclass must be a different class.
In the following example, C2is declared to be a sub-class of class C1, i.e., C2inherits C1.
open class C1{}
class C2<:C1 {}
A super class can be a generic class. Legal type arguments should be provided when the generic class is
inherited. For example, a non-generic class C2and a generic class C3inherit a generic class C1:
open class C1<T>{}
class C2<:C1<Int32 >{}
class C3<U><:C1<U >{}
All classes except class Objecthave a super class. If a super class is not defined explicitly, the super class
isObjectby default.
class Empty {} // Inherit from Object implicitly: class Empty <: Object {}
It is not allowed to inherit multiple classes, as shown in the following example.
open class C1{}
open class C2{}
class C3<:C1&C2{} // Error: Multiple inheritance is not supported.
When a class extends another class, the class being extended is called the superclass, and the extended
class is called a subclass.
open class C1{} // C1 is superclass
class C2<:C1 {} // C2 is subclass
A child class inherits all the members of its super class, except private members and constructors.
Subclasses can access the members of the parent class directly, but when overriding, it will not be possible
to access the members of the overridden instance of the parent class directly by name, which can be specified
bysuper(superpoints to the direct parent of the current class object) or by creating an object and accessing
it through the object.
6.1.1.3 Implementation Interface
A class can implement one or more interfaces. The interfaces implemented by the class are declared by <: I1
& I2 & ... & Ik after the class name or the superclass name if there is one. Multiple interfaces are separated
by&. If there is a superclass, interface names should be placed after the superclass name. For example:
interface I1{}
interface I2{}
// Class C1 implementation interface I1
open class C1<:I1 {}
// Class C2 inherits class C1 and implements interface I1, I2.
class C2<:C1&I1&I2{}
Also, interfaces can be generically defined and legal type arguments need to be provided when a generic
interface is implemented. For example:
interface I1<T>{}
interface I2<U>{}
class C1<:I1<Int32 >&I2<Bool >{}
class C2<K, V ><:I1<V >&I2<K>{}
When implementing a non-generic interface, it cannot be directly implemented multiple times. When
implementing a generic interface, it cannot be directly implemented multiple times with the same type
arguments. For example:
interface I1{}
class C1<:I1&I1{}// error
interface I2<T>{}
class C2<:I2<Int32 >&I2<Int32 >{}// error
class C3<T><:I2<T >&I2<Int32 >{} // ok
when generic class C3defined above is applied to a type argument Int32, as a result, the two implemented
interfaces are actually of the same type, Cangjie compiler will emit an error:
interface I1<T>{}
open class C3<T><:I1<T >&I1<Int32 >{} // ok
var a:C3<Int32 >// error
var b=C3<Int32 >()// error
class C4<:C3<Int32 >{}// error
For details about interfaces, see Section Interfaces .
6.1.1.4 Class Body
The class body is consisted of zero or more member declarations which are enclosed in a pair of curly brackets.
A class body consists of the following parts.
•optional static initializer
•optional primary constructor definition
•optional constructors definition
•optional member variables definition
•optional member functions and member operator functions definition or declaration
•optional member properties definition or declaration
•optional macro expression
The syntax of a class body is as the following:
classBody
:'{'
classMemberDeclaration *
classPrimaryInit ?
classMemberDeclaration *
'}'
;
classMemberDeclaration
:classInit
|staticInit
|variableDeclaration
|functionDefinition
|operatorFunctionDefinition
|macroExpression
|propertyDefinition
;
The syntax definition of the preceding class body contains the following content:
staticInit indicates the definition of the static initializer. A class can define only one static initializer.
primaryInit indicates the definition of the primary constructor. A class can define only one primary
constructor or not.
initindicates the definition of the initconstructor.
variableDeclaration indicates the declaration of a member variable.
operatorFunctionDefinition indicates the definition of an operator overloading member function.
macroExpression indicates the macro invocation expression. After macro expanded, the macros must
comply with the syntax definition of classMemberDeclaration .
propertyDefinition indicates the definition of an properties.
All the preceding are members of a class, for details, see section Class Members .
6.1.2 Class Members
A class consists of the following members:
•members inherited from its superclass (if there is);
•members of the interfaces that are implemented by the class, if there are;
•membersdeclaredordefinedintheclass, includingstaticinitializer, primaryconstructor, initconstruc-
tors, static member variables, instance member variables, static member functions, instance member
functions, static member properties or instance member properties.
Members of a class can be classified into static members and instance members based on whether they
are modified by static. A static member is a member that can be accessed without instantiating a class
object. A instance member is a member that can be accessed through an object only after the class object
is instantiated.
Members are classified into static initializer, constructors, member functions, member variables, and
member properties based on the member type.
Note the following: - All static members are not accessible by instance name.
6.1.2.1 Constructors
In CangJie programming language, there are two types of class constructors: primary constructor and init
constructor.
Primary Constructors The syntax of the primary constructor is as follows:
classPrimaryInit
: classNonStaticMemberModifier? className '(' classPrimaryInitParamLists? ')'
'{'
superCallExression?
( expression
| variableDeclaration
| functionDefinition)*
'}'
;
className
: identifier
;
classPrimaryInitParamLists
: unnamedParameterList (',' namedParameterList)? (',' classNamedInitParamList)?
| unnamedParameterList (',' classUnnamedInitParamList)?
(',' classNamedInitParamList)?
| classUnnamedInitParamList (',' classNamedInitParamList)?
| namedParameterList (',' classNamedInitParamList)?
| classNamedInitParamList
;
classUnnamedInitParamList
: classUnnamedInitParam (',' classUnnamedInitParam)*
;
classNamedInitParamList
: classNamedInitParam (',' classNamedInitParam)*
;
classUnnamedInitParam
: classNonStaticMemberModifier? ('let'|'var') identifier ':' type
;
classNamedInitParam
: classNonStaticMemberModifier? ('let'|'var') identifier'!' ':' type ('=' expression)?
;
classNonStaticMemberModifier
: 'public'
| 'protected'
| 'private'
;
A primary constructor definition including the following:
1. Modifier: optional. Primary constructors can be modified with one of public,protected , orprivate,
none of which are visible within the package. See Access Modifiers for details
2. The primary constructor name is the same as the type name. The keyword funcis not allowed
before the primary constructor name.
3. Parameter list: The primary constructor name is followed by a parameter list. The parameter
list contains two types of parameters: regular parameters and instance member variable parameters. The
syntax and semantics of regular parameters are consistent with those in the function definition. The member
variable parameter is introduced to reduce code redundancy. Defines a member variable parmeter, including
the definitions of both a parameter and a member variable. In addition, it indicates the semantics of
assigning value to member variable through the parameter. The definitions and expressions of the omissions
are automatically generated by the compiler.
•The syntax of the member variable parameter is the same as that defined outside the primary construc-
tor. In addition, it is supported by using !indicates whether the parameter is a named parameter.
-The members in the primary constructor can also be modified by using private,public, and protected .
For details about the semantics, see the modifiers of member variables. See Access Modifiers for details
•In the primary constructor, only instance member variable declarations can be written.
•The member variable defined in the primary constructor cannot have the same name as those outside
the primary constructor.
•The initial values of the member variables defined by the primary constructor can be set through pa-
rameters when the object is initialized. This is because the primary constructor generates a constructor
by the compiler and assigns values to the member variables in the primary constructor.
•A member variable parameter defined by the primary constructor can have an optional initial value.
The initial value expression can refer to other parameters that have been defined before the parameter
(excluding instance member variables defined outside the primary constructor), but the values of these
referred parameters and member variables cannot be modified. Note that the initial values of member
variable form parameters are only valid in the main constructor and are not included in the member
variable definition.
•Regular parameters must precede all member variable parameters. The sequence of the parameters of
the primary constructor must follow the parameter sequence when the function is defined. Non-named
parameters must precede all named parameters.
4. Primary constructor body: If the super class’s constructor is explicit invoked, calling to it must
be the first expression in the primary constructor body. The primary constructor does not allow calls to
other constructors in this class. After calling super, expressions, local variable declarations and local function
definitions are allowed in the primary constructor body. The declarations, definitions and expressions must
comply with the rules for using thisand superin the initconstructors. For details, see the section init
Constructors .
The following example defines a class with a primary constructor.
class Test {
static let counter :Int64 =3
let name :String ="afdoaidfad"
private Test(
name :String, // regular parameter
annotation !:String ="nnn" , // regular parameter
var width !:Int64 =1, // member variable parameter with initial value
private var length !:Int64 , // member variable parameter
private var height !:Int64 =3 // member variable parameter
){
}
}
When defining a primary constructor, regular parameters cannot be followed by member variable param-
eters. The following is an example:
class Test {
static let counter :Int64 =3
let name :String ="afdoaidfad"
private Test(
name :String, // regular parameter
annotation !:String ="nnn" , // regular parameter
var width !:Int64 =1, // member variable parameter with initial value
length !:Int64 , // Error: regular parameters cannot be after member variable parameters
){
}
}
A primary constructor is a syntax sugar of regular constructor. The compiler automatically generates a
definition of the constructor and member variables corresponding to the main constructor, the form of the
automatically generated constructor is as follows:
•The modifier is the same as that of the primary constructor.
•The sequence of parameters from left to right is the same as that of parameters declared in the primary
constructor parameter list.
•The constructor body is in the following format:
–Assign values to member variables in sequence. The syntax format is this.x = x , where xindicates
the member variable name.
–The code in the primary constructor body.
open class A<X>{
A(protected var x:Int64 ,protected var y:X){
this .x=x
this .y=y
}
}
class B<X><:A<X>{
B( // primary constructor, it's name is the same as the class
x:Int64 , // regular parameter
y:X, // regular parameter
v!:Int64 =1, // regular parameter
private var z!:Int64 =v// member variable parameter
){
super(x, y)
}
/* The corresponding init constructor with primary constructor auto-generated
by compiler.
private var z: Int64 // auto generated member variable definition
init( x: Int64,
y: X,
v!: Int64 = 1,
z!: Int64 = v) { // auto generated named parameter definition
super(x, y)
this.z = z // auto generated assign expression of member variable
}
*/
}
A class can define one primary constructor. In addition to the primary constructor, other constructors
can be defined as usual, but the other constructors must form an overload with the corresponding constructor
of the primary constructor.
initConstructors A constructor has the following dedicated syntax.
Init
: nonSMemberModifier? 'init' '(' InitParamLists? ')'
'{'
(superCallExression | initCallExpression)?
( expression
| variableDeclaration
| functionDefinition)*
'}'
;
InitParamLists
: unnamedParameterList (',' namedParameterList)?
| namedParameterList
;
The constructor is specified using the initkeyword and cannot contain the funckeyword. The return
type cannot be explicitly defined for the constructor, and the constructor must have a function body. You
can add an access modifier before initto restrict the access scope of the constructor. See Access Modifiers
for details
•public: default modifier of a constructor, indicating that the constructor can be accessed outside the
class.
•private: indicates that the constructor can be accessed only within the class.
•protected : indicates that the constructor can only be accessed in the current package or in subclasses
outside the current package.
•default: no modifier means that it can only be accessed within the current package
A constructor is invoked to create an instance object of the containing class. Like any function, If no
constructor of the corresponding parameter type is matched or no accessible constructor exists, the compiler
reports an error .
A class may contain multiple constructors as long as the constructors satisfy the requirements of function
overloading. For details about function overloading, see Function Overloading .
class C{
init (){}
init (name :String, age:Int32 ){}
}
When creating an instance of a class, the declarations and expressions in the class will be executed in
the following order:
1.Run the declaration of member variables except primary constructor.
2.If the constructor body does not explicitly invoke another constructor of this class or the superclass’s
constructor, invoke the superclass’s parameterless constructor super(). If the superclass does not have
a parameterless constructor, an error will be reported.
3.Execute the code in the constructor body.
If neither the primary constructor nor the initconstructor is defined for a class, the compiler attempts
to generate a ( publicmodified) parameterless constructor. If the super class does not have a parameterless
constructor or one of the instance member variables of the class have no initial value, an error is reported
during compilation.
The rules for using constructors, this, and superare as follows:
•Not allowed to use the instance member variable this.variableName and its syntax sugar variableName
orsuper.variableName as the default value of constructor parameters.
•Init constructors in the class can call other constructors (via this call expression) in the class or
superclass‘s constructor(via super call expression), but only one of them can be called. If called, it
must be at the first expression in the constructor body, without any expression or declaration before
it.
•If the constructor does not explicitly calling other constructors or calling the superclass’s constructor,
the compiler inserts the parameterless constructor of the super class into the constructor. If the super
class does not have a parameterless constructor, an error will be reported during compilation.
•After another constructor in the class or a superclass’s constructor is called, the instance member
variables of the superclass can be accessed using super.f.
•If a constructor does not explicitly call other constructors, ensure that all instance member variables
declared in this class have been initialized before returned from the constructor. Otherwise, an error
will be reported during compilation.
•Calling instance member functions or properties is forbidden in constructors of openclasses.
•thisvariable can not escape out of constructors of openclasses.
•Before all of the instance member variables are initialized, the constructor cannot use functions or
lambda that capture thisor use super functions by super.for use separate thisexpression, but can
usethis.variableName (the syntax sugar variableName ) to access initialized member variables.
•Outside the constructor, it is not allowed to call the constructor of this class through the this.
•The compiler analyzes the dependency between all constructors. If a cyclic invoking is performed, an
error is reported.
var b:Int64 =1
class A{
var a:Int64 =1
var b:()->Int64 ={3} // OK
/* Cannot use lambda which captured `this` before all of the instance member
variables are initialized. */
var c:()->Int64 ={a} // Error
/* Cannot use function which captured `this` before all of the instance member
variables are initialized. */ ↪
var d:()->Int64 =f // Error
var e:Int64 =a+1 // OK
func f():Int64 {
return a
}
}
class B{
var a:Int64 =1
var b:()->Int64
init (){
b={3}
}
init (p:Int64 ){
this ()
b={this .a}// OK
b=f // OK
}
func f():Int64 {
return a
}
}
var globalVar :C=C()
open class C{
init (){
globalVar =this // Error, `this` cannot escape out of constructors of `open` class
f(this )// Error, `this` cannot escape out of constructors of `open` class
m() // Error: calling instance function is forbidden in constructors of `open` class
}
func m(){}
}
6.1.2.2 Static initializers
Static variables in a class or struct can also be initialized in a static initializer by assignment expression.
Static initializers for enum and interface aren’t supported.
The syntax of the static initializer is as follows.
staticInit
: 'static' 'init' '(' ')'
'{'
expressionOrDeclarations?
'}'
;
There are following rules for a static initializer: - A static initializer is called automatically and couldn’t
be called explicitly; - A static initializer is called when the package it belongs to is loading, like an initializer
expression for a static variable on the right hand side; - There can be at most one static initializer in a class
or struct; - For a non-generic class or struct, a static initializer is called guaranteed once; - For a generic
class or struct, a static initializer is called guaranteed once per different type instantiation; - Note that
if there are no type instantiations of that class or struct, a static initializer wouldn’t be called at all; - A
static initializer is called after all direct initializations of static member variables in this class or struct, like
instance constructor is called after all direct initializations of fields; - That means it’s possible to refer to
further declared static member variables in a static initializer; - That also means that a static initializer
may be located in a class or struct in any place, the order doesn’t matter; - Within a file, across classes,
static initializers are called in a top-down way despite inheritance; - That means there is no guarantee that
all static member variables of a parent class must be initialized before the initialization of the current class:
“‘cangjie class Foo <: Bar { static let y: Int64
static init() { // called first
y = x // error: not yet initialized variable
}
}
open class Bar {
static let x: Int64
static init() { // called second
x = 2
}
}
```
•Static member variables must be initialized in only one way, either directly, by the right hand side
expression, or in a static initializer;
–Despite the fact that mutable static variables may be assigned both directly and in a static
initializer, the variable initialization in this case would be only direct assignment, while the as-
signment in a static initializer is considered as a simple reassignment. That means before the
static initializer is called, that variable would have a value assigned directly.
–If an immutable static variable is initialized both directly and in a static initializer, the compiler
reports an error about reassignment.
∗That error is also reported if an immutable static variable is assigned in a static initializer
several times.
–If a static variable isn’t initialized neither directly nor in a static initializer, the compiler reports
an error about not initialized variable;
–The facts above are detected by a special initialization analysis which depends on the implemen-
tation.
•A static initializer cannot have any parameters;
•Return expressions aren’t allowed in a static initializer;
•Throwing an exception in a static initializer leads to terminating the program, like throwing an excep-
tion on the right hand side expression of a static variable;
•Neither instance member variables nor static member variables that have not been initialized can be
used in a static initializer;
•The code of a static initializer is synchronized to protect against leaking of partially initialized classes
or structs;
•Static properties still should be declared in a full way, including getterand setter;
•Unlike static functions, static initializers couldn’t be declared as an extension (inside an extendsection);
•Due to a static initializer is called automatically and there is no way to call it explicitly, the visibility
modifier isn’t applicable to a static initializer, and it couldn’t be specified
Initialization analysis rules is demonstrated by the following example:
class Foo {
static let a:Int64
static var c:Int64
static var d:Int64 // error: uninitialized variable
static var e:Int64 =2
static let f:Int64 // error: uninitialized variable
static let g:Int64 =1
let x=c
static init (){
a=1
b=2
Foo.c // error: not yet initialized variable
let anotherFoo =Foo()
anotherFoo.x // error: not yet initialized variable
c=3
e=4
g=2// error: reassignment
}
static let b:Int64
}
6.1.2.3 Variables in the Class
Variable declaration in classes A variable that is declared in a class or interface is called a member
variable. Member variables can be declared as immutable by the keyword let, or mutable by the keyword
var.
In the class, instance member variables outside the primary constructor may have initial values. The
initial value expression can use the previously declared instance member variables. In this case, the execution
sequence of the variable initialization is before the call of the super class’s constructor￿it is prohibited to use
qualified names with superto access the member variables of the superclass in the initial value expression
of the instance member variables.
The following shows an example of member variable declaration.
open class A{
var m1:Int32 =1
}
class C{
var a:Int32 =10
let b:Int32 =super.m1 // Error
}
Modifiers of variables Variables in class can be declared with the following modifiers. See Access Modi-
fiers for details
•public: A variable declared with modifier publiccan be accessed outside the class.
class C{
public var a=1
}
•private: A variable declared with modifier privatecan only be accessed in this class. A getter function
can be declared through which a private variable can be accessed outside the class. Private variables
cannot be accessed outside of a class through a class instance and cannot be inherited.
class C{
private var a=1
func getA (){a}
func setA (value :Int64 ){
this .a=value
}
}
•protected : The variable can only be accessed within this package or in a subclass.
open class C1{
protected var a=1
}
class C2<:C1 {
var newB =a// protected modified variables can be accessed in subclasses.
}
•If a variable in a class is modified with static, it is a static variable of the class. staticcan be used
together with private,protected orpublic. Static variables are inherited by subclasses, and the static
variables of subclasses and parent classes are the same.
class C{
static var a=1
}
var r1=C.a // ok
6.1.2.4 Member functions in the class
Function Declaration and Definition in a Class Functions may be defined in classes, and may be
declared in classes or interfaces. Note that functions declared in interfaces must be abstract, i.e., without a
function body. The difference between the definition and declaration is whether the function has a function
body.
Functions in classes are classified into instance member functions, static member functions.
The syntax of function definitions and declarations in classes is as follow:
functionDefinition
: modifiers 'func' identifier typeParameters ?functionParameters ( ':' returnType) ?
genericConstraints ?(('=' expression) |block) ? ↪
;
instance Member Functions The first implicit parameter of a instance member function is this. When-
ever a instance member function is called, it means that a complete object needs to be passed in first, so the
instance member function is called before the object is created is forbidden, but the type of the function will
not include the implicit parameter. The basis for judging the completion of class object creation is that the
constructor of the class has been called.
instance member functions can be categorized into abstract member functions and non-abstract member
functions.
Abstract Member Functions
Abstract memeber functions are functions without a body. They can only be declared in abstract classes
or interfaces.
abstract class A{
func foo():Unit // abstract member function
}
Non-abstract Member Functions
Non-abstract member functions are functions with a function body.
class Test {
func foo():Unit {// non-abstract member function
return
}
}
Abstract instance member functions have the semantics of openby default. The openmodifier is optional
when defining an abstract instance member function in an abstract class.
Static Member Functions Static member functions are declared with the statickeyword, it does not
belong to an instance, but to the type it is in. They are independent of objects. Meanwhile, a static function
must have a function body.
•Static member functions cannot access instance member variables, cannot invoke instance
member functions, and cannot reference the superorthiskeyword in its body.
•Static member functions can reference other static member functions or static member
variables.
•Static member functions can be modified by private,protected orpublic.See Access
Modifiers for details
•When a static member function is inherited by other subclasses, this static member function
will not be copied to the subclass.
•Static member functions in both abstract and non-abstract classes must have implementa-
tions.
For example:
class C<T>{
static let a:Int32 =0
static func foo(b:T):Int32 {
return a
}
}
main() :Int64 {
print( "${C<Int32 >.foo( 3)}")
print( "${C<Bool >.foo( true )}")
return 0
}
This program has their own static member variable aand static function fooforC<Int32> and C<Bool>
respectively.
Static functions in class can declare new generic type parameters and the parameters can have constraints.
A generic static function defined in a class can be invoked as long as legal type arguments are provided for
the generic class and generic static function of the class:
class C<T>{
static func foo<U>(a:U,b:T):U{a}
}
var a:Bool =C<Int32 >.foo <Bool >(true ,1)
var b:String =C<Bool >.foo <String >("hello" ,false )
func f<V>(a:V):V{C<Int32 >.foo <V>(a, 0)}
Modifiers of Class Member Functions Class member functions allow the following modifiers to be
modified: See Access Modifiers for details
•public: A function declared with modifier publiccan be accessed outside the package.
class C{
public func f():Unit {
return
}
}
•private: A function declared with modifier privatecan only be accessed in this class. This means that
private member functions cannot be called through this class instance and cannot be inherited.
class C{
private func f(){}
var a=f() // You can access f only in the current class.
}
•protected : A function declared with modifier protected can only be accessed in this package or in this
class and its subclasses.
open class C1{
protected func f(){}
var a=f() // f can be accessed in the current class.
}
class C2<:C1 {
var a=f() // You can access f in C2.
}
•open: A function declared with the modifier opencan be override. Note that a function cannot be
declared with both openand static. When an instance member with the openmodifier is inherited by
a class, the modifier for that openis also inherited. If there are open-modified members in the class, but
the current class is not open-modified, then these open-modified members still have no openeffect, and
the compiler will report a warning for this case (no warning is required for inherited open members or
override members). The compiler will report a warning for this case.
•Functions modified by openmust be modified by publicorprotected
// case 1
open class C1{ // In this case, the 'open' modifier before 'class C1' is required.
public open func f(){}
}
class C2<:C1 {
public override func f(){}
}
// case 2
open class A{
public open func f(){}
}
open class B<:A {}
class C<:B {
public override func f(){}// ok
}
// case 3
interface I{
func f(){}
}
open class Base <:I {} // The function f Inherits the open modifier.
class Sub <:Base {
public override func f(){}// ok
}
•override : Whenafunctionoverridesanotheropenfunction, itcanbedeclaredwithanoptionalmodifier
override (override does not have the opensemantic. If the function modified with override needs to
be override, use openmodifier it again.). The preceding example is used. For details about function
override, see section Overridding .
•static: The function modified with staticis a static member function and must have a function body.
Static member functions cannot be modified with open.
The instance members of the class cannot be accessed in the static member function. A
static member of a class that can be accessed in a instance member function.
class C{
static func f(){} // Cannot be overwritten and must have a function body.
}
•redef: When a static function redefines a static function that inherits from a parent type, it can be
declared with an optional modifier redef.
open class C1{
static func f1(){}
static func f2(){}
}
class C2<:C1 {
redef static func f1(){}
redef static func f2(){}
}
6.1.2.5 Finalizer
Class finalizer is an instance member function which gets invoked when an instance of a class is garbage
collected.
class C{
// below is a finalizer
~init (){}
}
A finalizer has the following dedicated syntax.
classFinalizer
: '~' 'init' '(' ')' block
;
1.Finalizer cannot have parameters, or return type, or generic type parameters, or any modifiers, and
they cannot be invoked explicitly.
2.The class with finalizer can not be qualified by open, only non-open class can have finalizer.
3.At most one Finalizer can be defined in a class.
4.Finalizer can not be defined in extensions.
5.The timing of finalizer invocations is not deterministic.
6.Finalizer may be executed on any thread.
7.The execution order of finalizers is not guaranteed.
8.It is an implementation-defined behavior if an exception is thrown out of finalizer.
9.It is an implementation-defined behavior that creating threads or using thread synchronization in the
finalizer.
10.Itisanimplementation-definedbehaviorthatanobjectisabletobevisitedafteritsfinalizerisexecuted.
Some examples are given below:
class SomeType0 {
~init (){}// OK
}
class SomeType1 {
~init (x:Int64 ){}// Error, finalizer cannot have parameters
}
class SomeType2 {
private ~init (){}// Error, finalizer cannot have accessibility modifiers
}
class SomeType3 {
open ~init (){}// Error, finalizer cannot have open modifier
}
open class SomeType4 {
~init (){}// Error, open class can't have a finalizer
}
var GlobalVar :SomeType5 =SomeType5()
class SomeType5 {
~init (){
GlobalVar =this // do not escape `this` out of finalizer, otherwise, unexpected behavior
may happen. ↪
}
}
6.1.2.6 Member Properties in Class
Properties can also be defined in class, see Property for the syntax of defining member properties.
6.1.2.7 Instances of class Types
When a classtype is defined, the corresponding instance of the classcan be instanced. The definition for
an instance of a classcan be divided into two kinds, according to whether the class is generic:
1.Using ClassName(arguments) for defining instances of classes that are not generic. In above, ClassName
is the name of the class, and arguments is the list of argument. ClassName(arguments) will invoke the
closest matching constructor (based on the rules in section Function Overloading ), and then generate
an instance of ClassName .
class C{
var a:Int32 =1
init (a:Int32 ){
this .a=a
}
init (a:Int32 ,b:Int32 ){
this .a=a+b
}
}
main() :Int64 {
var myC =C(2) // invoke the first constructor
var myC2 =C(3,4)// invoke the second constructor
return 0
}
2.Using ClassName<Type1, Type2, ... , TypeK>(arguments) for defining instances of generic classes.
The only difference from defining an instance of a non-generic class is that type variables need to be
instanced for generic classes, i.e., ‘Type1’ to ‘TypeN’ should be given or be inferred. Some examples
are given below:
class C<T, U >{
var a:T
var b:U
init (a:T,b:U){
this .a=a
this .b=b
}
}
main() :Int64 {
var myC =C<Int32 ,Int64 >(3,4)
var myC2 =C(3,4) // The type of myC2 is inferred to C<Int64, Int64>.
return 0
}
6.1.3 The Class Object
The class Objectis the superclass of all other classes (interface s are not included), and the class Object
does not contain any members, i.e. Objectis an “empty” class. The Objecttype has a publicconstructor
that has no parameter.
6.1.4 This Type
Within a class, we support a Thistype placeholder, which can only be used as the return type of an instance
member function and is replaced with the type of the class where the function is located at compile time.
8.A function whose return type is Thiscan only return an expression of type This, no other expression
is allowed.
9.Expressions of type Thiscontain this and calls to other functions that return This.
10. Thistype is a subtype of the current type, and Thiscan be automatically cast to the current type, but
not vice versa.
11.The Thistype cannot be used explicitly within a function. Any use of Thistype expressions outside
of the return value will be inferred as the current type.
12.If the instance member function does not declare a return type and only an expression of type Thisis
present, the return type of the current function is inferred to be This.
13.The return type of an open function containing Thismust remain of type Thiswhen it is overridden.
14.If the return type of the open function in the parent class is the parent class, the child class can use
Thisas the return type when overriding.
open class C1{
func f():This {// its type is `() -> C1`
return this
}
func f2(){// its type is `() -> C1`
return this
}
open func f3():C1{
return this
}
}
class C2<:C1 {
// member function f is inherited from C1, and its type is `() -> C2` now
override func f3():This {// ok
return this
}
}
var obj1 :C2=C2()
var obj2 :C1=C2()
var x=obj1.f() // During compilation, the type of x is C2
var y=obj2.f() // During compilation, the type of y is C1
6.1.5 Generic Class: Box
In the Cangjie programming language , a built-in generic class called Box is supported, which wraps all types
as reference types. The class is defined as follows. It has a unique variable value declared by varand a
unique constructor function init. The parameter type of the constructor function is T.
class Box<T>{
var value :T
init (value :T){
this .value =value
}
}
When the user invokes this wrapper class, the wrapped variable is passed to the constructor of the class.
Variablesdeclared by letare not allowed to change the value of the wrapped variablewhen wrapping through
them.
Once packaged, the packaged variable points to the instantiated object of the Boxclass. The object name
is the name of the packaged variable, and its member variable valuecan be accessed through the member
access expression.
The following is an example:
•When a1and b1are packaged in Box, the values assigned during initialization cannot be modified.
•The values of a2and b2can be changed when they are packed by Box.
•After being packaged, it can be accessed in a1.value mode and can be re-assigned a value to value.
main() :Int64 {
let a1=1
var a2=2
let b1=Box( 1)
var b2=Box( 2)
// a1 = Box(a1) // Compile-time error.
// a2 = Box(a2) // Compile-time error.
var a11 =Box(a1) // OK.
// b1 = Box(2) // Not allowed, compile-time error.
b2=Box( 3) // OK.
return 0
}
6.2 Interfaces
An interface is used to define an abstract type that contains no data, but can define the behavior of the type.
A type is said to implement an interface if it declares that it implements an interface and implements all the
members in that interface.
The members of an interface can contain instance member functions, static member functions, opera-
tor overloaded functions, instance member properties and static member properties that are abstract, but
functions and properties can be defined with default implementations.
6.2.1 Interface Declaration
6.2.1.1 Syntax of Interface Declaration
Interfaces are declared with the interface keyword. An interface declaration is compared of the following
elements from left to right: an optional modifier, the interface keyword, an interface name, an optional <:
together with the name of the super interface, and an interface bodies enclosed with {}.
The following is an example of interface declaration.
interface I1{}
interface I2<T>{}
interface I3<U>{}
public interface I4<V><:I2<V >&I3<Int32 >{}
The syntax of interface declaration is as follows.
interfaceDefinition
:interfaceModifierList ?'interface' identifier
typeParameters ?
('<:' superInterfaces )?
genericConstraints ?
interfaceBody
;
Interfaces only can be defined in the top level.
The {}enclosing the interface body can not be omitted.
interface I{} // {} not allowed to be omitted
6.2.1.2 Interface Modifiers
In the following, we introduce the modifiers for classes.
Access Modifiers
•Access modifier: If no access modifier is used when defining an interface, then the interface can only be
accessed inside the package. Also, interfaces can be declared with modifier public, then the interface
can be accessed outside the package.
public interface I{} // can be accessed outside the package
interface I2{} // can only be accessed inside the package
Inheritance modifier
•Inheritance modifier: By default, the interface has the semantics of the openmodifier without using
the inheritance modifier, indicating that the interface can be inherited, implemented, or extended
anywhere the interface can be accessed. Of course, it is allowed to explicitly use the openmodifier
before the interface definition. You can also use the sealedmodifier to indicate that the interface can
be inherited, implemented, or extended only in the package which the interface is defined.
•The publicmodifier is optional when defining a sealed class because the semantics of publicare already
implied by sealed.
•Sub-interfaces that inherit a sealedinterface or sub-classes that implement the sealedinterface may
still modified by sealed, or not. If the sub-interface of a sealedinterface is modified by publicbut not
bysealed, the sub-interface can be inherited, implemented, or extended outside the package.
•The type that inherits or implements the sealed interface does not need to be modified by public.
// package A
package A
public sealed interface I1{} // OK
sealed interface I2 {} // OK, 'public' is optional when 'sealed' is used
open interface I3{} // OK
interface I4 {} // OK, 'open' is optional
class C1<:I1 {} // OK
public open class C2<:I1 {} // OK
public sealed class C3<:I1 {} // OK
extend Int64 <:I1 {} // OK
// package B
package B
import A.*
class S1<:C2 {} // OK
class S2<:C3 {} // Error, C3 is sealed class, cannot be inherited here.
6.2.2 Interface Members
The members of an interface include
•members declared in the body of the interface which include static member functions, instance member
functions, operator overloading functions, static member properties and instance member properties.
•and members inherited from other interfaces. As shown in the following example, the members of I2
include the members that are allowed to be inherited in I1.
interface I1{
func f():Unit
}
interface I2<:I1 {}
The syntax of interface members is as follows.
interfaceMemberDeclaration
: (functionDefinition|macroExpression|propertyDefinition) end*
;
6.2.2.1 Functions in the Interface
Function Declaration in Interfaces Interfaces can contain instance member functions and static mem-
ber functions that are written in the same way as normal instance member functions and static member
functions, but can have no function implementation; these functions are called abstract functions .
For an abstract function that has an implementation, we say that the function has a default implemen-
tation.
The following are examples containing abstract functions.
interface MyInterface {
func f1():Unit // Default implementation not included
static func f2():Unit // Default implementation not included
func f3():Unit {// Default implementation included
return
}
static func f4():Unit {// Default implementation included
return
}
}
Abstract functions can have named parameters, but cannot have parameter default values.
interface MyInterface {
func f1(a!:Int64 ):Unit // OK
func f2(a!:Int64 =1):Unit // Error, cannot have parameter default values
}
Interface Function Modifiers Functions defined in the interface can be accessed outside the interface,
with the same effect as public, no access modifiers are allowed.
The following are examples of errors.
interface MyInterface {
public func f1():Unit // Access modifiers cannot be used
private static func f2():Unit // Access modifiers cannot be used
}
Functions modified with staticare called static member functions and can have no function body. A
staticfunction without a function body cannot be called directly using the interface type. A staticfunction
with a function body can be called directly using the interface type. When a static member function is called
directly using the interface type name, it will be compiled with an error if the function contains a direct
or indirect call to another static function that is not implemented in the interface (by itself or by another
interface).
interface I{
static func f1():Unit
static func f2():Unit {}
static func f3():Unit {
f1()
}
}
I.f1() // Error, cannot directly call
I.f2() // OK
I.f3() // Error, f1 not implemented
The openmodifier is optional when defining instance member functions in interfaces, as they have the
semantics of openby default.
interface I{
open func foo1 (){}// ok
func foo2 (){} // ok
}
Functions modified with mutare a special kind of instance member function that can be used to abstract
the mutable behavior of struct types.
interface I{
mut func f():Unit
}
6.2.2.2 Member Properties in the Interface
Properties can also be defined in interface, see Chapter 7 for the syntax of defining member properties.
The abstract functions and abstract properties in an interface can have default implementations.
When an interface is inherited or implemented by other interfaces or types, the default implementations
of the interface are copied into the subtype if they have not been reimplemented.
1.thiscan be used in the default implementation of an instance member function, and the type of this
is the current interface.
2.The default implementation, like the non-abstract member functions, has access to all accessible ele-
ments in the current scope.
3.The default implementation is a syntactic sugar that provides default behavior to the implementation
type, and the child interface can follow the default implementation of the parent interface.
4.The default implementation is not part of the inheritance semantics, so override redef super cannot
be used.
interface I{
func f(){// f: () -> I
let a=this // a: I
return this
}
}
6.2.3 Interface Inheritance
An interface can inherit one or more interfaces.
interface I1<T>{}
interface I2{}
interface I3<U><:I1<U >{}// inherit a generic interface.
interface I4<V><:I1<Int32 >&I2{}// inherit multiple interfaces.
When a sub-interface inherits the super interface, it inherits the abstract functions, default functions of
the super interface.
When inheriting a non-generic interface, it cannot be directly inherited multiple times. When inheriting a
generic interface, it cannot be directly inherited multiple times with the same type arguments. For example:
interface I1{}
interface I2<:I1&I1{}// error
interface I3<T>{}
interface I4<:I3<Int32 >&I3<Int32 >{}// error
interface I5<T><:I3<T >&I3<Int32 >{} // ok
When generic interface I3is given a type argument Int32, compiler will emit an error:
interface I1<T>{}
interface I2<T><:I1<T >&I1<Int32 >{} // ok
var a:I2<Int32 >// error
interface I3<:I2<Int32 >// error
6.2.3.1 Default implemention in Child Interfaces
If a subinterface inherits a function or property that does not have a default implementation in the superin-
terface, only the declaration of this function or property is allowed in the subinterface (and of course give a
default implementation is allowed) , and the override orredefmodifier preceding the function declaration
or definition is optional. Examples are as follows.
interface I1{
func f1():Unit
static func f2():Unit
}
interface I2<:I1 {
func f1():Unit // ok
static func f2():Unit // ok
}
interface I3<:I1 {
override func f1():Unit // ok
redef static func f2():Unit // ok
}
interface I4<:I1 {
func f1():Unit {} // ok
static func f2():Unit {}// ok
}
interface I5<:I1 {
override func f1():Unit {} // ok
redef static func f2():Unit {}// ok
}
If a subinterface inherits a function or property that has a default implementation in the superinterface,
it is not allowed to give only the declaration of this function or property but without definition in the
subinterface. If a new default implementation is given, the override orredefmodifier before the function
definition is optional. Examples are as follows.
interface I1{
func f1():Unit {}
static func f2():Unit {}
}
interface I2<:I1 {
func f1():Unit // error, 'f1' must has a new implementation
static func f2():Unit // error, 'f2' must has a new implementation
}
interface I3<:I1 {
override func f1():Unit {} // ok
redef static func f2():Unit {}// ok
}
interface I4<:I1 {
func f1():Unit {} // ok
static func f2():Unit {}// ok
}
If a child interface inherits multiple parent interfaces that have default implementations of the same
signature member, the child interface must provide its own version of the new default implementation or it
will compile with an error.
interface I1{
func f(){}
}
interface I2{
func f(){}
}
interface I3<:I1&I2{}// error, I3 must implement f: () -> Unit
The default implemention in the child interface can no longer access the default implemention in the
parent interface.
6.2.4 Implementation of Interfaces
6.2.4.1 Overriding and Overloading When a Class Implements Interfaces
When a type implements one or more interfaces, the rules as follows:
1.When implementing an interface for a type other than an abstract class, you must implement all the
functions.
2.When an abstract class implements an interface, it is allowed not to implement the functions and
properties in the interface.
3.The function name and parameter list of the implemented function must be the same as the corre-
sponding function in the interface.
4.The return type of the implemented function should be the same as or a subtype of the return type of
the corresponding function in the interface.
5.If there is any generic function in the interface, the constraints of the type parameters of the imple-
mented function must be looser than or the same as the corresponding function in the interface.
6.The mutmodifier of the implemented property must be the same as the corresponding property in the
interface.
7.The type of the implemented property must be the same as the corresponding property in the interface.
8.If there is only one default implementation of the same function or property in multiple interfaces, the
implementation type can leave the function or property unimplemented and use the default implemen-
tation.
9.If multiple interfaces contain multiple default implementations of the same function or property, the
implementation type must implement the function or property and cannot inherit from the default
implementation.
10.If the implementation type already has (inherited from the super class or defined by the type) an
implementation of the same function or property in an interface, the default implementation in any
interface is not used.
11.The override modifier (or redefmodifier) before the definition of a function or property is optional
when implementing an interface for a type, regardless of whether there is a default implementation of
the function or property in the interface.
When implementing an interface for a type other than an abstract class, the abstract functions and the
abstract properties in the interfaces must be implemented, as the f1in the following example. Allows not to
use the default implementation of functions in the interface, as the f2in the following example. The abstract
class do not need to implement all instance member functions in interfaces. In the following example, the
abstract class C1does not implement f1in the Iinterface.
interface I{
type Item
func f1():Unit
func f2():Unit {
return
}
static func f3():Item
}
class C<:I {
public type Item =C
public func f1():Unit {}
public func f2():Unit {
return
}
public static func f3():C{
return C()
}
}
abstract class C1<:I {
public type Item =C1
public static func f3():C1{
return C1()
}
}
For example: Functions fand gin the interface Iare generic functions. Since classes Eand Fmeet the
requirement that the type parameters of the implemented function are looser than or the same as those
functions in the interface, compilation is successful. But class Ddoes not meet requirements, an error is
reported during compilation.
// C <: B <: A
interface I{
static func f<T>(a:T):Twhere T <: B
static func g <T>():Twhere T <: B
}
class D<:I {
public static func f<T>(a:T):Twhere T <: C {} // Error￿stricter constraint
public static func g<T>():Twhere T <: C {} // Error￿stricter constraint
}
class E<:I {
public static func f<T>(a:T):Twhere T <: A {} // OK, looser constraint
public static func g<T>():Twhere T <: A {} // OK, looser constraint
}
class F<:I {
public static func f<T>(a:T):Twhere T <: B {} // OK￿same constraint
public static func g<T>():Twhere T <: B {} // OK￿same constraint
}
More examples:
// case 1
interface I1{
func f():Unit
}
interface I2{
func f():Unit
}
class A<:I1&I2{
public func f():Unit {}// ok
}
// case 2
interface I1{
func f():Unit
}
interface I2{
func f():Unit {}
}
open class A{
public open func f():Unit {}// ok
}
class B<:A&I1&I2{
public override func f():Unit {}// ok
}
// case 3
interface I1{
func f():Unit
}
interface I2{
func f():Unit {}
}
class A<:I1&I2{}// ok, f from I2
// case 4
interface I1{
func f():Unit {}
}
interface I2{
func f():Unit {}
}
class A<:I1&I2{}// error
class B<:I1&I2{// ok,
func f():Unit {}
}
// case 5
interface I1{
func f(a:Int) :Unit {}
}
interface I2 {
func f(a:Int) :Unit {}
}
open class A{
public open func f(a:Int) :Unit {}
}
open class B<:A&I1&I2{// ok, f from A
}
Rules for overloading functions when implements an interface: Parent and child scope functions
must have the same function name but different parameter lists.
The following examples show some of the situations that constitute a function overloading when a class
implements an interface. Note that when a class implements an interface, it needs to provide an implemen-
tation for the overloaded function declaration.
Example 1: In the following example, functions with the same name fbut different parameter types are
declared in I1and I2. One function named fwith parameter type Unitand one with parameter type Int32
must be implemented in class C.
interface I1{
func f():Unit
}
interface I2{
func f(a:Int32 ):Unit
}
class C<:I1&I2{
public func f():Unit {} // The f in I1 needs to be implemented.
public func f(a:Int32 ):Unit {} // The f in I2 needs to be implemented.
}
Example 2: In the following example, two default functions fwith different parameter types are declared
inI1and I2. No implementation of finCis required.
interface I1{
func f(){}
}
interface I2{
func f(a:Int32 ){}
}
class C<:I1&I2{
}
Example3: Inthefollowingexample, afunctionnamed fwithparametertype Unitisdeclaredininterface
I1. A default function named fwith parameter type Int32is declared in interface I2. A function named f
with parameter type Unitmust be implemented in class C.
interface I1{
func f():Unit
}
interface I2{
func f(a:Int32 ):Unit {
return
}
}
class C<:I1&I2{
public func f():Unit {
return
}
}
6.2.5 Any Interface
The Anyinterface is a language built-in empty interface, which is by default inherited by all interface types
and implemented by all non-interface types, so all types can be used as subtypes of the Anytype.
class A{}
struct B{}
enum C{D}
main() {
var i:Any =A() // ok
i=B() // ok
i=C.D // ok
i=(1,2)// ok
i={=>123 }// ok
return 0
}
The Any interface can be explicitly declared at the type definition, or implicitly implemented by the
compiler if it is not, but cannot be reimplemented using extensions.
class A<:Any {} // ok
class B{}// Implicit implement Any
extend B<:Any {} // error
6.3 Overridding, Overloading, Shadowing, Redefinition
6.3.1 Overridding
6.3.1.1 Override Definition
If a non-abstract and instance function with a name same as a function in the superclass is declared, the
function can be declared with an optional modifier override (indicating that it overwrites the existing one).
Such function overriding must comply with the following rules.
•The name of the function must be the same as the overridden function .
•The parameter type of the function must be the same as the overridden function.
The same parameter list indicates that the number and types of parameters of a function
are the same.
•The return type of the function must be the same as or be a subtype of the return type
of the overridden function.
•Samefunctionoverridesseveralfunctionsinthesuperclasses, eachfollowstheaboverules.
Example:
•In the following example, Function finC2overwrites finIand C1since they have the same parameter
type and return type.
•Function f1inC2overwrites f1in the C2since the return type of f1inC1isFather, and the return
type of f1inC2isChild.
open class Father {}
class Child <:Father {}
open class C1{
public open func f(){}
public open func f1():Father {Father() }
}
interface I{
func f(){}
}
class C2<:C1&I{
public override func f(){} // OK.
public override func f1():Child {Child() }// OK.
}
Pay attention to the following details:
1.Functions modified with privatein a class are not inherited and cannot be accessed in subclasses.
2.Static functions cannot cover instance functions.
6.3.1.2 Invoking of Overridden Functions
If a subtype overrides a function in the parent type and the function is invoked in the program, the compiler
selects the version of the function to be executed based on the type of the object at run time.
In the following example, the function fis defined in the C1,fis overridden in the subclass C2, and
the variables aand bof the C1type are defined, assign the instance of C1(myC1) to aand the instance of C2
(myC2) to b. When aand bare used to call the function f, the corresponding function is selected based on
their actual types at run time.
open class C1{
open func f():Unit {
return
}
}
class C2<:C1 {
override func f():Unit {
return
}
}
var myC1 =C1()
var myC2 =C2()
// Assign the object of the superclass C1 to the variable of the C1 type.
var a:C1=myC1
// Assign the object of the superclass C2 to the variable of the C1 type.
var b:C1=myC2
// Invokes f of C1 based on the object type of at runtime
var c=a.f()
// Invokes f of C2 based on the object type of at runtime
var d=b.f()
6.3.2 Overloading
For details about function overloading, see SectionFunction Overloading .
Class/Interface does not allow overload between static and instance member functions. If the names
of static member functions and instance member functions (including those defined by the class/interface
and inherited from super class or super interface) of a class/interface are the same, a compilation error is
reported.
open class Base {}
class Sub <:Base {}
open class C{
static func foo(a:Base) {
}
}
open class B<:C {
func foo(a:Sub) { // Error
C.foo(Sub())
}
}
class A<:B {
// Static and instance functions cannot be overloaded.
static func foo(a:Sub) {} // Error
}
Functions defined in the super classes and sub classes are processed as the same scope priority when the
function is overloaded.
6.3.3 Shadowing
During inheritance, a member of a subtype must not shadow a member of the supertype. If the shadowing
occurs, an error will be compiled.
In the following example, the classes C1and C2both have the same name instance variable x, and the
compilation reports an error.
open class C1{
let x=1
}
class C2<:C1 {
let x=2// error
}
6.3.4 Redefinition
6.3.4.1 Definition of Redefined Functions
If a non-abstract static function with a name same as a non-abstract static function in the superclass is
declared, the function can be declared with an optional modifier redef(indicating that it redefines the
existing one). Such function redefinition must comply with the following rules.
•A function and its redefined versions must share the same name.
•The parameter type of the function must be the same as the redefined function.
The same parameter list indicates that the number and types of parameters of a function
are the same.
•The return type of the function must be the same as or a subtype of the return type of the redefined
function.
•If the redefined function is a generic function, the type argument constraints of the redefined function
are more loose or the same as those of the implemented function.
•Same function redefines several functions in the super classes, each follows the above rules.
Example:
•In the following example, Function finC2redefines finIand C1since they have the same parameter
type and return type.
•Function f1inC2redefines f1in the C2since the return type of f1inC1isFather, and the return type
off1inC2isChild.
open class Father {}
class Child <:Father {}
open class C1{
public static func f(){}
public static func f1():Father {Father() }
}
interface I{
static func f(){}
}
class C2<:C1&I{
public redef static func f(){} // OK.
public redef static func f1():Child {Child() }// OK.
}
For example: Functions fand gin the class Baseare generic functions. Since classes Eand Fmeet the
requirement that the type parameters of the redeffunction are looser than or the same as those functions
in the super class, compilation is successful. If class Ddoes not meet requirements then an error is reported
during compilation.
// C <: B <: A
open class Base {
static func f<T>(a:T):Twhere T <: B
static func g <T>():Twhere T <: B
}
class D<:Base {
redef static func f<T>(a:T):Twhere T <: C {} // Error￿stricter constraint
redef static func g<T>():Twhere T <: C {} // Error￿stricter constraint
}
class E<:Base {
redef static func f<T>(a:T):Twhere T <: A {} // OK, looser constraint
redef static func g<T>():Twhere T <: A {} // OK, looser constraint
}
class F<:Base {
redef static func f<T>(a:T):Twhere T <: B {} // OK￿same constraint
redef static func g<T>():Twhere T <: B {} // OK￿same constraint
}
redefmodifier cannot be used for a static initializer because it’s only called implicitly, the compiler
reports an error otherwise.
6.3.4.2 Invoking of Redefined Functions
If a subclass redefined a function in the superclass and the function is invoked in the program, the compiler
selects the version of the function to be executed based on the type.
In the following example, the function fis defined in class C1, and fis redefined in its subclass C2. When
the function fis called via C1and C2, the corresponding function is selected based on their types at compile
time.
open class C1{
static func f():Unit {
return
}
}
class C2<:C1 {
redef static func f():Unit {
return
}
}
// Invokes f of C1
var c=C1.f()
// Invokes f of C2
var d=C2.f()
6.3.5 Access Control Restriction
The access modifier level is specified as follows based on the allowed access scope of the access modifier:
•Access modifier level: public > protected > default > private.
Under this level, the behavior across access levels is defined as follows:
•When a subclass inherits a parent class, the access level of the override function or static function
redefinition cannot be changed to be lower than the overriden function or redefined static function in
the super type.
•When a type implements interface, the access level of the function which implements abstarct function
cannot be changed to be lower than the abstract function in the super type.
The following shows an example of access control restrictions.
open class A{
protected func f(){}
}
interface I{
func m(){}// public by default
}
class C<:A&I{
private override func f(){}// Error: the access control of override function is lower than
the overriden function ↪
protected func m(){}// Error: the access control of function which implements abstract
function is lower than the abstract function ↪
}
6.4 Limitations on the Use of Generics in Classes Interfaces
6.4.1 Duplicated F unction type signature caused by generic instantiation
When defining a generic class, the following class C1and functions in C1are legal since functions can be
overloaded.
open class C1<T>{
public func c1(a:Int32 ){} // ok
public func c1(a:T){} // ok
}
interface I1<T>{
func i1(a:Int32 ):Unit // ok
func i1(a:T):Unit // ok
}
var a=C1<Int32 >()// error
class C2<:C1<Int32 >{}// error
var b=I1<Int32 >()// error
class C2<:I1<Int32 >{}// error
However, when generic class C1<T>needs to be instantiated as C1<Int32> , it has two member functions
with exactly the same type signature. In such cases, the location where type C<Int32> is used will emit an
error.
6.4.2 Generic Member F unction in Class and Interface
In Cangjie programming language, nonstatic abstract functions and open functions in classes and interfaces
are not allowed to declare generic parameters. For example:
interface Bar {
func bar<T>(a:T)// error
}
abstract class Foo {
func foo<T>(a:T)// error
open func goo<T>(a:T){...}// error
}
class Boo {
open func Boo<T>(a:T){...}// error
}
See chapter 9 subsection 7.2.Chapter 7
Property
Properties are a special syntax that does not store values like fields, instead they provide a getter and an
optional setter to indirectly retrieve and set values.
By using properties you can encapsulate data operations into access functions, which are no different
from ordinary fields when used. We only need to operate on the data and are not aware of the internal
implementation, which makes it more convenient to implement mechanisms such as access control, data
monitoring, tracking and debugging, and data binding.
Properties are used with the same syntax as fields and can be used as expressions or be assigned values.
The following is a simple example where b is a typical property that encapsulates external access to a:
class Foo {
private var a=0
mut prop b:Int64 {
get() {
print( "get" )
a
}
set(value) {
print( "set" )
a=value
}
}
}
main() {
var x=Foo()
let y=x.b +1// get
x.b =y// set
}
7.1 Syntax of Properties
The syntax rule for the properties is :
propertyDefinition
: propertyModifier* 'prop' identifier ':' type propertyBody?
;
propertyBody
: '{' propertyMemberDeclaration+ '}'
;
propertyMemberDeclaration
: 'get' '(' ')' block end*
| 'set' '(' identifier ')' block end*
;
propertyModifier
: 'public'
| 'private'
| 'protected'
| 'static'
| 'open'
| 'override'
| 'redef'
| 'mut'
;
Properties declared without a mutmodifier need to define getter implementation. Properties declared
with a mutmodifier require both separate getter and setter implementations.
Numeric types, Bool, Unit, Nothing, Rune, String, Range, Function, Enum, Tuple type may not define
properties with mutmodifier.
As shown in the example below, ais a property declared without mutand bis a property declared using
mut.
class Foo {
prop a:Int64 {
get() {
0
}
}
mut prop b:Int64 {
get() {
0
}
set(v) {}
}
}
Properties declared without mutdo not have a setter, and like fields declared with let, they cannot be
assigned values.
class A{
prop i:Int64 {
get() {
0
}
}
}
main() {
var x=A()
x.i =1// error
}
Inparticular, propertiesinstruct, likefieldsdeclaredwith let, cannotbeassignedvalueswhenaninstance
of struct is declared using let.
struct A{
var i1=0
mut prop i2:Int64 {
get() {
i1
}
set(value) {
i1=value
}
}
}
main() {
let x=A()
x.i1 =2// error
x.i2 =2// error
}
Properties are different from fields in that they cannot be assigned initial values and must be declared
with types.
7.2 Definition of Properties
Properties can be defined in interface, class, struct, enum, extend.
class A{
prop i:Int64 {
get() {
0
}
}
}
struct B{
prop i:Int64 {
get() {
0
}
}
}
enum C{
prop i:Int64 {
get() {
0
}
}
}
extend A{
prop s:String {
get() {
""
}
}
}
Abstract properties can be declared in interfaces and abstract classes, and these abstract properties do
not require defined implementations. When implementing an abstract property for an implementation type,
it must maintain the same name, the same type, and the same mutmodifier.
interface I{
prop a:Int64
}
class A<:I {
public prop a:Int64 {
get() {
0
}
}
}
Justasanabstractfunctioninaninterfacecanhaveadefaultimplementation, socananabstractproperty
in an interface have a default implementation.
Having the abstract properties of the default implementation, the implementation type may not provide
its own implementation (which must conform to the rules for using the default implementation).
interface I{
prop a:Int64 {// ok
get() {
0
}
}
}
class A<:I {} // ok
Properties are divided into instance member properties and static member properties. Among them,
instance member properties can only be accessed by instances, and this, instance members and other static
members can be accessed in the getter or setter implementation. Static member properties can only be
accessed by static members.
class A{
var x=0
mut prop X:Int64 {
get() {
x+y
}
set(v) {
x=v+y
}
}
static var y=0
static mut prop Y:Int64 {
get() {
y
}
set(v) {
y=v
}
}
}
Properties do not support overloading or shadowing, and cannot be renamed with other members of the
same level.
open class A{
var i=0
prop i:Int64 {// error
get() {
0
}
}
}
class B<:A {
prop i:Int64 {// error
get() {
0
}
}
}
7.3 Implementation of Properties
The getter and setter of an properties correspond to two different functions, respectively.
1.The getter function type is ()->T, where T is the type of the property and the getter function will be
executed when the property is used as an expression.
2.The setter function is of type (T)->Unit , where T is the type of the property and the name of the
formal parameter needs to be explicitly specified, and the setter function will be executed when the
property is assigned a value.
The implementation of properties follows the same rules as functions, which can contain declarations and
expressions, can omit return, and must return a value that matches the return type.
class Foo {
mut prop a:Int64 {
get() {// () -> Int64
"123" // error
}
set(v) {// (Int64) -> Unit
123 // error
}
}
mut prop b:Int64 {
get() {
123 // ok, return 123
}
set(v) {
()// ok, return unit
}
}
}
The behavior of accessing properties is consistent whether inside or outside the property, so recursive
access to properties can cause the same dead loops as functions.
class Foo {
prop i:Int64 {
get() {
i// dead loop
}
}
}
Note that the setter of struct is a mut function, so you can also modify the values of other fields inside
the setter, and thisis subject to the restrictions of the mut function.
7.4 Modifiers for Properties
Properties, like functions, can be modified with modifiers, but only for the entire property, not for the getter
or setter independently.
class Foo {
public mut prop a:Int64 {// ok
get() {
0
}
set(v) {}
}
mut prop b:Int64 {
public get() {// error
0
}
public set(v) {}// error
}
}
Properties can use the access control modifiers private,protected , and public.
class Foo {
private prop a:Int64 {// ok
get() {0}
}
protected prop b:Int64 {// ok
get() {0}
}
public static prop c:Int64 {// ok
get() {0}
}
}
Instance properties, like instance functions, can be modified with openand override .
Forpropertiesmodifiedwith open, childtypescanuseanoptional override tooverridetheimplementation
of the parent type.
open class A{
open mut prop i:Int64 {
get() {0}
set(v) {}
}
}
class B<:A {
override mut prop i:Int64 {
get() {1}
set(v) {}
}
}
Static properties, like static functions, can be modified with an optional redef, and subtypes can reim-
plement the static functions of the parent type.
open class A{
static mut prop i:Int64 {
get() {0}
set(v) {}
}
}
class B<:A {
redef static mut prop i:Int64 {
get() {1}
set(v) {}
}
}
Subtype override/redef Instance properties declared using letmust be reimplemented as getters.
Subtype override/redef instance properties declared with mutmodifier are allowed to reimplement either
getter or setter separately, i.e. they can reimplement only setter without reimplementing getter or only getter
without reimplementing setter, but not both.
open class A{
mut prop i1:Int64 {
get() {0}
set(v) {}
}
static mut prop i2:Int64 {
get() {0}
set(v) {}
}
}
// case 1
class B<:A {
override mut prop i1:Int64 {
get() {1}// ok
}
redef static mut prop i2:Int64 {
get() {1}// ok
}
}
// case 2
class B<:A {
override mut prop i1:Int64 {
set(v) {}// ok
}
redef static mut prop i2:Int64 {
set(v) {}// ok
}
}
// case 3
class B<:A {
override mut prop i1:Int64 {}// error
redef static mut prop i2:Int64 {}// error
}
Properties override/redef by subtypes must maintain the same mutmodifier as the parent class, and
must also maintain the same type.
class P{}
class S{}
open class A{
open prop i1:P{
get() {P() }
}
static prop i2:P{
get() {P() }
}
}
// case 1
class B<:A {
override mut prop i1:P{// error
set(v) {}
}
redef static mut prop i2:P{// error
set(v) {}
}
}
// case 2
class B<:A {
override prop i1:S{// error
get() {S() }
}
redef static prop i2:S{// error
get() {S() }
}
}
Child types can use superto call the properties of the parent type.
open class A{
open prop v:Int64 {
get() {1}
}
}
class B<:A {
override prop v:Int64 {
get() {super.v +1}
}
}Chapter 8
Extension
Extensions can add new functionality to any type visible in the current package, except for functions, tuples,
and interfaces.
Features that can be added include:
•Adding Instance Member Functions
•Adding Static Member Functions
•Adding Operator Overloading
•Adding Instance Member Properties
•Adding Static Member Properties
•Implementing Interfaces
Extensions is a function that is appended after the type definition. Extensions cannot destroy the
encapsulation of the original type, so the following functions are forbidden.
1.Extensions cannot add fields.
2.Extensions cannot add abstract members.
3.Extensions cannot add openmembers.
4.Extensions cannot override/redef original members.
5.Extensions cannot access private members of the original type.
8.1 Extension Syntax
A simple example of an extension is as follows.
extend String {
func printSize (){
print( this .size)
}
}
"123" .printSize() // 3
The syntax of the extended definition is as follows.
extendDefinition
: 'extend' extendType
('<:' superInterfaces)? genericConstraints?
extendBody
;
extendType
: (identifier NL* DOT NL*)* identifier (NL* typeParameters)?
;
extendBody
: '{' extendMemberDeclaration* '}'
;
extendMemberDeclaration
: (functionDefinition
| operatorFunctionDefinition
| propertyDefinition
| macroExpression
) end*
;
Extensions are defined using the extendkeyword. Extensions are defined in the order of the extend
keyword, the type being extended, the optional implementation interface, the optional generic constraints,
and the definition of the extension body. The definition of the extension body does not allow the omission
of{}.
extension can only be defined at the top level.
Extensions are divided into two uses: direct extensions and interface extensions. Direct extensions do
not require declaring additional interfaces.
8.1.1 Direct Extensions
Direct extensions do not require declaring additional interfaces and can be used to add new functionality
directly to existing types.
class Foo {}
extend Foo {
func f(){}
}
main() {
let a=Foo()
a.f() // call extension function
}
8.1.2 Interface Extensions
Interface extensions can be used to add new functionality to existing types and implement interfaces, en-
hancing abstraction flexibility. When using interface extensions, the interface being implemented must be
declared.
interface I{
func f():Unit
}
class Foo {}
extend Foo <:I {
public func f(){}
}
Using interface extensions for a type to implement interface Iis equivalent to implementing interface I
at type definition time, but the scope of use is limited by the extension import and export, see Extension
Import and Export for details.
func g(i:I){
i.f()
}
main() {
let a=Foo()
g(a)
}
We can implement multiple interfaces in the same extension at the same time, with multiple interfaces
separated by &, and the order of the interfaces is not sequential.
interface I1{
func f1():Unit
}
interface I2{
func f2():Unit
}
interface I3{
func f3():Unit
}
class Foo {}
extend Foo <:I1&I2&I3{
public func f1(){}
public func f2(){}
public func f3(){}
}
If the type being extended has already implemented an interface, it is not possible to repeat the im-
plementation of the interface through the extension, including the use of the interface implemented by the
extension.
interface I{
func f():Unit
}
class Foo <:I {
func f():Unit {}
}
extend Foo <:I {} // error, can not repeat the implementation of the interface
class Bar {}
extend Bar <:I {
func f():Unit {}
}
extend Bar <:I {} // error, already implemented through the extension can not repeat the
implementation ↪
If the type being extended has already directly implemented a non-generic interface, the extension cannot
be used to re-implement the same interface. If the type being extended has already directly implemented
a generic interface, the extension cannot be used to re-implement the same interface with the same type
arguments.
interface I1{}
class Foo <:I1 {}
extend Foo <:I1 {} // error
interface I2<T>{}
class Goo<T><:I2<Int32 >{}
extend Goo<T><:I2<Int32 >{}// error
extend Goo<T><:I2<T >{}// ok
If the type being extended already contains the functions required by the interface, the interface extension
cannot re-implement these functions and does not use the default implementation in the interface.
class Foo {
public func f(){}
}
interface I{
func f():Unit
}
extend Foo <:I {} // ok
extend Foo {
public func g():Unit {
print( "In extend!" )
}
}
interface I2{
func g():Unit {
print( "In interface!" )
}
}
extend Foo <:I2 {} // ok, default implementation of g in I2 is no longer used
The definition of orphan extensions is prohibited. Orphan extensions refer to interface extensions that
are neither defined in the same package as the interface (containing all interfaces in the interface inheritance
chain) nor in the same package as the type being extended.
That is, interface extensions are only allowed in the following two cases:
3.The interface extension is in the same package as the type definition.
4.The interface extension is in the same package as the interface and its entire inheritance chain.
Interface extensions for all other cases are not allowed to be defined.
// package pkg1
public class Foo {}
// package pkg2
public interface Bar {}
// package pkg3
import pkg1 .Foo
import pkg2 .Bar
extend Foo <:Bar {} // error
interface Sub <:Bar {}
extend Foo <:Sub {} // error
8.2 Members of Extension
Extended members include: static member functions, instance member functions, static member properties,
instance member properties, and operator overloaded functions.
8.2.1 F unctions
Extensions can add functions to the type being extended. These functions can be generic functions, support
generic constraints, support overloading, and also support default parameters and named parameters. None
of these functions can be abstract functions.
For example:
interface I{}
extend Int64 {
func f<T>(a:T,b!:Int64 =0)where T <: I {}
func f(a:String, b:String) {}
}
8.2.1.1 Modifier
Function definitions within extensions support the private,protected (only can be used when the extended
type is a class type) or publicmodifier.
Functions modified with privatecan only be used inside this extension and are not visible outside.
A member function modified with protected is not only accessible within the package, but also to sub-
classes of the current class in other packages.
Functions that are not qualified with private,protected orpubliccan only be used within this package.
// file1 in package p1
package p1
public open class Foo {}
extend Foo {
private func f1(){} // ok
public func f2(){} // ok
protected func f3(){}// ok
func f4(){} // visible in the package
}
main() {
let a=Foo()
a.f1() // error, can not access private function
a.f2() // ok
a.f3() // ok
a.f4() // ok
}
// file2 in package p2
package p2
import p1.*
class Bar <:Foo {
func f(){
f1() // error, can not access private function
f2() // ok
f3() // ok
f4() // error, can not access default function
}
}
Functions within extensions support the use of the staticmodifier.
class Foo {}
extend Foo {
static func f(){}
}
An extension to the struct type can define the mutfunction.
struct Foo {
var i=0
}
extend Foo {
mut func f(){// ok
i+=1
}
}
Function definitions within extensions do not support the open,override ,redefmodifiers.
class Foo {
open func f(){}
static func h(){}
}
extend Foo {
override func f(){}// error
open func g(){}// error
redef static func h(){}// error
}
8.2.2 Properties
Extensions can add properties to the type being extended. None of these properties can be abstract proper-
ties.
For example:
extend Int64 {
mut prop i:Int64 {
get() {
0
}
set(value) {}
}
}
8.2.2.1 Modifier
Properties definitions within extensions support the private,protected (only can be used when the extended
type is a class type) or publicmodifier.
Properties modified with privatecan only be used inside this extension and are not visible outside.
A property modified with protected is not only accessible within the package, but also to subclasses of
the current class in other packages.
Properties that are not qualified with private,protected orpubliccan only be used within this package.
// file1 in package p1
package p1
public open class Foo {}
extend Foo {
private prop v1:Int64 { // ok
get() {0}
}
public prop v2:Int64 { // ok
get() {0}
}
protected prop v3:Int64 {// ok
get() {0}
}
prop v4:Int64 { // visible in the package
get() {0}
}
}
main() {
let a=Foo()
a.v1 // error, can not access private property
a.v2 // ok
a.v3 // ok
a.v4 // ok
}
// file2 in package p2
package p2
import p1.*
class Bar <:Foo {
func f(){
v1// error, can not access private function
v2// ok
v3// ok
v4// error, can not access default function
}
}
Properties within extensions support the use of the staticmodifier.
class Foo {}
extend Foo {
static prop i:Int64 {
get() {0}
}
}
Properties definitions within extensions do not support the open,override ,redefmodifiers.
class Foo {
open prop v1:Int64 {
get() {0}
}
static prop v2:Int64 {
get() {0}
}
}
extend Foo {
override prop v1:Int64 {// error
get() {0}
}
open prop v3:Int64 {// error
get() {0}
}
redef static prop v2:Int64 {// error
get() {0}
}
}
8.3 Extensions for generic types
If the type being extended is a generic type, the type variables at the type being extended does not need
to have the same name as the type variables at the original type definition. Type variables in an extended
type implicitly introduce generic constraints in the type definition.
interface I{}
open class C{}
class Foo<T>where T <: C {}
extend Foo<T>{}// ok, T <: C
extend Foo<R>{}// ok, R <: C
extend Foo<S><:I {} // ok, S <: C
extend Foo {}// error
We can use additional generic constraints in extensions, functions added in this way can only be used if
the instance of the type is in compliance with the generic constraints, otherwise an error will be reported.
class Foo<T>{
var item :T
init (it:T){
item =it
}
}
interface Eq<T>{
func equals (other :T):Bool
}
extend Foo<T>where T <: Eq<T >{
public func equals (other :Foo<T>){
item.equals(other.item)
}
}
class A{}
class B<:Eq<B >{
public func equals (other :B){true }
}
main() {
let a=Foo(A())
a.equals(a) // error, A has not implement Eq
let b=Foo(B())
b.equals(b) // ok, B has implement Eq
}
8.4 The Accessing and Shadowing of Extensions
Extended instance member can use thisin the same way as type definitions, and the function of thisremains
consistent. It is also possible to omit thisfrom accessing members.
Extended instance members cannot use super.
class A{
var v=0
}
extend A{
func f(){
print( this .v) // ok
print(v) // ok
}
}
Extensions cannot access privatemembers of the type being extended, other modifier-modified members
can be accessed.
class A{
private var v1=0
protected var v2=0
}
extend A{
func f(){
print(v1) // error
print(v2) // ok
}
}
Extensions are not allowed to shadow any member of the type being extended.
class A{
func f(){}
}
extend A{
func f(){}// error
}
Extensions are also not allowed to shadow any members added by other extensions.
class A{}
extend A{
func f(){}
}
extend A{
func f(){}// error
}
The same type can be extended any number of times within the same package.
The non-private–modified members in other extensions of the same type can be accessed directly in the
extension (without any prefix).
class Foo {}
extend Foo {// OK
private func f(){}
func g(){}
}
extend Foo {// OK
func h(){
g() // OK
f() // Error
}
}
When a generic type is extended, the generic constraints of different extensions can be different.
In addition to the preceding accessibility rules, whether members of other extensions of the same type
can be directly used in an extension of a generic type must meet the following rules:
•If the constraints of two extensions are the same, the members of each other can be directly used in
the two extensions.
•If the constraints of two extensions are different and the constraints of the two extensions have an
inclusive relationship, members in the extension with a looser constraint can be directly used in the
extension with a stricter constraint; otherwise, members in the extension with a stricter constraint can
not be directly used.
•When two extensions have different constraints and there is no inclusion relationship between the two
constraints, the two extensions cannot directly use members of each other.
Example: Assume that two extensions of the same type E<X>are the extension 1and the extension 2,
and the constraint of Xin the extension 1is stricter than that in the extension 2. In this case, members in
the extension 2can be directly used in the extension 1. Otherwise￿members in the extension 1cannot be
directly used in the extension 2
// B <: A
class E<X>{}
interface I1{
func f1():Unit
}
interface I2{
func f2():Unit
}
extend E<X><:I1where X <: B { // extension 1
public func f1():Unit {
f2() // OK
}
}
extend E<X><:I2where X <: A { // extension 2
public func f2():Unit {
f1() // Error
}
}
8.5 Inheritance of Extension
If the type being extended is class, then the extended members are inherited by the subclasses.
open class A{}
extend A{
func f(){}
}
class B<:A {
func g(){
f() // ok
}
}
main() {
let x=B()
x.f() // ok
}
Note that if a member is extended in the parent class, it cannot be defined again in the child class
with the same name due to inheritance rules, and it cannot be overridden or reimplemented(allow function
overloading).
open class A{}
extend A{
func f(){}
func g(){}
}
class B<:A {
func f(){}// error
override func g(){}// error
}
8.6 Import and Export of Extensions
The extension itself cannot be modified with public, and the extension can only be imported and exported
together with the type being extended or interface.
8.6.1 Export of Direct Extensions
When a direct extension is defined in the same package as the type being extended, the extension will
be exported together with the type being extended if the type being extended is exported, otherwise the
extension will not be exported.
package pkg1
public class Foo {}
extend Foo {
public func f(){}
}
///////
package pkg2
import pkg1 .*
main (){
let a=Foo()
a.f() // ok
}
When the direct extension is in a different packagefrom the definition of the type being extended, the
extension is never exported and can only be used in the current package.
package pkg1
public class Foo {}
///////
package pkg2
import pkg1 .*
extend Foo {
public func f(){}
}
func g(){
let a=Foo()
a.f() // ok
}
///////
package pkg3
import pkg1 .*
import pkg2 .*
main (){
let a=Foo()
a.f() // error
}
8.6.2 Export of Interface Extensions
When the interface extension is in the same package as the type being extended, the access level of the
extension is the same as the type being extended. If the corresponding interface is also in the same package,
an external type cannot extend any internal interface.
package pkg1
public class Foo {}
internal interface I1{
func f():Unit
}
extend Foo <:I1 { // error
public func f():Unit {}
}
public interface I2{
func g():Unit
}
extend Foo <:I2 { // ok
public func g():Unit {}
}
///////
package pkg2
import pkg1 .*
main (){
let a=Foo()
a.g() // ok
}
When the interface extension is not in the same package as the type being extended, the access level of
the extension is the same as the corresponding interface. If multiple interfaces are extended, the access level
of the extension is external if and only if all interfaces are external.
package pkg1
public class Foo {}
public class Bar {}
///////
package pkg2
interface I1{
func f():Unit
}
public interface I2{
func g():Unit
}
extend Foo <:I1&I2{// not external
public func f():Unit {}
public func g():Unit {}
}
extend Bar <:I2 { // external
public func g():Unit {}
}
8.6.3 Import of Extensions
Extensions are imported together with the type being extended and the interface implemented by the exten-
sion, and there is no need to specify the extension to be imported.
package pkg1
public class Foo {}
extend Foo {
public func f(){}
}
///////
package pkg2
import pkg1 .Foo // import Foo
main() {
let a=Foo()
a.f() // ok
}
In particular, since extensions do not support shadowing any member of the type being extended, an
error will be reported when a redefinition of the imported extension occurs.
package pkg1
public class Foo {}
///////
package pkg2
import pkg1 .Foo
public interface I1{
func f():Unit {}
}
extend Foo <:I1 {} // ok, external
///////
package pkg3
import pkg1 .Foo
public interface I2{
func f():Unit {}
}
extend Foo <:I2 {} // ok, external
///////
package pkg4
import pkg1 .Foo
import pkg2 .I1// error
import pkg3 .I2// errorChapter 9
Generics
A declaration which has type parameters declared within angle brackets can be called a generic declaration.
Type parameters can be substituted by other types. Type parameters can be substituted to be other types
when this generic declaration is used. A function with generic parameter is a generic function. Class,
interface, struct, enum, typealias with generic parameters are generic type.
9.1 Type Parameters and Type V ariable
In Cangjie programming language, type parameters are represented by identifiers enclosed in <>. Multiple
type parameters are separated using comma ,in<>, e.g., <T1, T2, T3> ,T1,T2, and T3are all type parameters.
Once type parameters are declared, they can be used as a type.
When using an identifier to refer a type introduced by a declaration of type parameters, the identifier is
called type variable.
The Syntax of type parameter is as follows.
typeParameters
: '<' identifier (',' identifier)* '>'
;
9.2 Generic Constraints
In Cangjie programming language, <:can be used to denote one type is a subtype of another type. <:is a
binary relation. By using this relation operator, constraints can be imposed to type parameters so that the
type parameters can only be substituted with only certain types that satisfies the relation.
Generic constraints are declared with <:operator after wherekeyword. LHS of <:is called lower bound
of the constraint. Lower bound of a generic contraint can only be type variable. RHS of <:is called upper
bound. Upper bound of a constraint can be type. The constraint is called subtype constraint when upper
bound is type. When the upper bound is a type, it can be any types.
A type variable can be constrained by multiple upperbound. For a particular type variable, its multiple
constraints must be combined with &which simplified situations where one type parameter constrained by
multiple upper bounds. It actually denotes many constraints in one clause. Constraints of different type
parameters need to be separated by “ ,”.
The Syntax of generic constraints is as follows:
upperBounds
: type ('&' type)*
;
genericConstraints
: 'where' identifier '<:' upperBounds (',' identifier '<:' upperBounds)*
;
For example, the following shows how generic constraints are declared.
interface Enumerable <U>where U <: Bounded { ...}
interface Comparable <T>{...}
func collectionCompare <T>(a:T,b:T)where T <: Comparable <T>&Seqence {...}
func sort <T,V>(input :T)
where T <: Enumerable <V>,V<:Object {...}
The constraints of type variables Xand Yare the same, which means that all types that meet the X
constraints meet Yconstraints, and all types that meet the Yconstraints also meet the Xconstraint;
The constraints of the type variable Xis stricter than that of Y, which means that all types that meet the
Xconstraint check meet the constraint check of Y; otherwise, the constraint may not be met;
IfXis stricter than Y, then Yis looser than X.
The constraints of two generic types are the same, which means that the number of type variables of the
generic type is the same, and all the corresponding type variables constraints are the same.
One generic type Ahas a stricter constraints than another generic type B, meaning that Aand Bhave
the same number of type variables. The constraints of all type variables of Aare stricter than those of the
corresponding type variables of B.
If one generic type Ahas stricter constraints than another generic type B,Bhas looser constraints than A.
For example, the following two generics Cand Dare used. Assume that I1 <: I2 exists. The constraint
ofCis stricter than that of D.
class C<X, Y> where X <: I1, Y <: I1 and class D<X, Y> where X <: I2, Y <: I2
9.3 Type V ariance
Generics are subject to constraints called type variance. Before introducing the generic functions and generic
types etc., we briefly introduce the following type variance which constraints the subtype relationships of
generic types.
9.3.1 Definitions
Let Aand Bbe types and Tbe a type constructor. Suppose that Thas a type parameter X.
•When T(A) <: T(B) holds if and only if A <: B, then Tiscovariant regarding X.
•When T(A) <: T(B) holds if and only if B <: A, then Tiscontravariant regarding X.
•When T(A) <: T(B) holds if and only if A = B, then Tisinvariant regarding X.
9.3.2 Generic is Invariant
In Cangjie programming language, all generics are invariant. For instance, if Ais a subtype of B,ClassName<A>
is not a subtype of ClassName<B> . We forbid this behavior to ensure runtime safety.
9.3.3 Type V ariance in F unctions
The parameter type of a function is contra-variant, and the return type of a function is covariant. Assume
that the type of the f1function is S1 -> T1 and the type of the f2function is S2 -> T2 .f1is a subtype of
f2ifS2 <: S1 and T1 <: T2 .
9.3.4 Type V ariance in T uples
A type of tuples may be a subtype of another. That is, if each element of a tuple is of a type that is a
subtype of the corresponding element of another tuple, the former is a subtype of the latter. That is, let
Tuple1and Tuple2be two tuples of type (A1, A2.., An) and (B1, B2.., Bn) .Tuple1 <: Tuple2 ifAi <: Bi
for all i in {1,2,...,n} .
9.3.5 Derived constraints of upper bounds of a generic constraint
Foraconstraint L <: T<A1..An> ,thedeclaration Tofitsupperbound T<T1..Tn> maydeclaredotherconstraints.
These constraints need to be substituted by type arguments Tiand introduced to current declaration context
implicitly whenever possible. For example:
interface Eq<T>{
func eq(other :T):Bool
}
interface Ord<T>where T <: Eq<T >{
func lt(other :T):Bool
}
func foo<T>(a:T)where T <: Ord <T>{
a.eq(a)
a.lt(a)
}
Infoofunction, even though only T <: Ord constraint is declared, the Ttype in Ordis constrained by Eq.
Therefore, eqfunction can be called in function fooand the actual constraints here are T <: Eq & Ord . When
a constraint is declared, constraints of its upper bound also need to be introduced to the constraint.
For other generic declarations, this rule also applies to them. For example:
class A{}
class B<T>where T <: A {}
class C<U>where U <: B<U >{}// actual constraints are U <: A & B<U>
For class C, The constraints imposed on its type parameter Uare actual U <: A & B<U> .
Note that although constraints on upper bounds in the current declaration are introduced implicitly, the
current declaration can still write these constraints out explicitly.
9.4 Generic F unctions and Generic Types
9.4.1 Generic F unctions
If a function is declared with one or more type parameters, it is called a generic function. Syntax-wise,
type parameters are placed immediately after the function name and are enclosed in <>. Multiple type
parameters are separate by ,.
func f<T>(){...}
func f1<T1, T2, T3, ...> (){...}
The syntax of generic functions is as follows.
functionDefinition
: functionModifierList? 'func' identifier
typeParameters functionParameters
(':' type)? genericConstraints?
('=' expression | block)?
;
9.4.2 Generic Types
Ifoneormoretypeparametersaredeclaredinthedeclarationofclasses, interfaces, structs, enumortypealias,
they are called generic types. Syntax-wise, a type parameter is immediately followed by the name (such as
a class name or an interface name) and is enclosed in <>. Multiple type parameters are separated by “ ,”.
class C<T1, T2 >{...} // generic class
interface I<T1>{...} // generic interface
type BinaryOperator <T>=(T, T)->T // generic typealias
For grammars of generic declaration, refer related chapters and sections.
9.5 Type Checking for Generic Types
9.5.1 Type Checking for Generic Declarations
9.5.1.1 Sanity Check of Generic Constraint
For each of type parameter in a generic declaration, its upper bounds can be types. When its upper bounds
are types, there are two possibilities:
1.Its upper bounds are generic parameters, the upperbounds may contain itself or other generic param-
eters.
2.When upper bounds are concrete types, there are two cases:
•The first case is when upper bounds are classes or interfaces, which are called class-related types.
.
•The other case is for types except class and interface tyes, which are called class-irrelated types.
In cangjie programming langauge, the concrete type upperbounds of a generic type parameter need to
satisfy the following rules:
1.They must be one of the above two cases. Its upper bounds are in class-related case or class-
irrelative case. For example, T <: Object & Int32 is illegal.
2.When upper bounds are classes and interfaces, if there are multiple classes then these classes must
be in one inheritance chain. There is no special rules for interfaces.
3.When upper bounds are in the case of class-irrelated types, they can be only one kind of class-
irrelated concrete type. It cannot be two different concrete types simultanously. For example, T
<: Int32 & Bool is illegal.
4.When upper bounds are class-irrelative types, the constraint cannot be a recursive constraint. A
Recursive generic constraint is a constraint with the type arguments of its upper bound depending
on the type variable of the lower bound directly or indirectly. For example, since Optiontype is
defined by enumdeclaration, T <: Option<T> is illegal. T <: U, U <: (Int32) -> T is also illegal
since function is a primitive type and it conform a recursive constraint via type parameter U.
9.5.1.2 Type Compatibility Checking
Type checking for generic declarations mainly checks whether the generic type is compatible with the type
context it locates, whether the value of the generic type can access a certain member variable or function is
legal.
open class C{
func coo(){...}
}
class D<:C {...}
interface Tr{
func bar():Int64
}
func foo<T>(a:T){
var b:C=a// error, T is not a subclass of C
a.coo() // error, T has no member function coo
a.bar() // error, T did not implement Tr
}
In function body of foo, there are three errors, the reasons are listed in the following:
1.Variable ddeclared in function foois excepted to have type C, compiler will then check whether type
Tis a subtype of C, i.e., T <: C. This constraint is not in the context of function declaration. Hence,
an error is emitted.
2.because generic type Tis not related with class Cin the context, it cannot access C’s member function
coo.
3.Similarly, because generic type Tis not constrained by Tr, it cannot access Tr’s member function bar.
If we want the program to pass type checker, constraints can be added at the place just in the front of
function body:
open class C{
func coo(){...}
}
interface Tr{
func bar():Int64
}
func foo<T>(a:T)where T <: C &Tr{
var b:C=a// OK, T is a sub type of C now
a.coo() // OK, T is a sub type of C, so it has coo member function
a.bar() // OK, T is constrained by Tr
}
9.5.2 Type Checking for the Usages of Generic Declarations
For checking the usages of generic declaration, type parameters in generic declarations are substituted with
type arguments first, then check whether the type constraints are satisfied.
If we want to invoke foofunction defined in previous subsection with class type C:
main() :Int64 {
foo<C>(C()) // error C does not implement Tr
return 0
}
Compiler will emit an error message which says type Cdoes not implement Tr. This is because in function
foothere are constraints T <: C & Tr and type parameter Tis substituted with type argument C.C <: Cis
satisfied, while C <: Tris not.
For type C, if an extend declaration of Tris added then the constraint T <: Tris satisfied.
extend C<:Tr {
func bar():Int64 {...}
}
In particular, when interface is used as a generic constraint, the type instantiated by the generic variant
when invoked must fully implement all of the interface static functions in the upper bound constraint.
Means that if there is a static function in the interface that is a generic constraint, it is not possible to
instantiate an interface or abstract class that does not implement the corresponding static function as a type
of generic variant.
interface I{
static func f():Unit
}
func g<T>():Unit where T <: I {}
main() {
g<I>()// error
return 0
}
9.5.3 Depths of Generic Instantiation
For avoiding infinite loop or exhausting memory during generic declaration instantiation, compiler will
restrict the depth of generic instantiation. For example:
class A<T>{
func test (a:A<(A<T>,A<T>)>):Bool {true }
}
main() :Int64 {
var a:A<Int32 >=A<Int32 >()
return 0
}
The above program will report infinite instantiation error.
9.6 Generic Instantiation
Given a generic declaration, after all the type parameters are determined, a non-generic declaration will be
formed. This process is called generic instantiation.
9.6.1 Generic function instantiation
func show <T>(a:T)where T <: ToString {
a.toString()
}
When type argument Tis given a concrete type Int32, the following non-generic function will be instan-
tiated.(assume that show$Int32 is a name used by compiler internally. This convention will also be used in
the rest of this chapter.)
func show$Int32 (a:Int32 ){
a.toString()
}
9.6.1.1 Limitation of Generic Function Instantiation
Since Cangjie implements generic function by instantiation, generic type parameters cannot be declarared
in the following situations:
1. Nonstatic abstract functions in interfaces and abstract classes.
2. Functions with open modifier in classes.
3. Operator overloading functions.
The following function declarations and definitions are illegal:
abstract class AbsClass {
func foo<T>(a:T)// error: abstract generic function in abstract class
open func bar<T>(a:T){// error: open generic function in abstract class
...
}
}
interface IF{
func foo<T>(a:T)// error: abstract generic function in interface
}
class Foo {
open function foo<T>(a:T):Unit {// error: open generic function in class
...
}
}
The following generic function definitions are legal:
class Foo {
static func foo<T>(a:T){...}// generic static function in class
func bar<T>(a:T){...}// generic non-open function in class
}
abstract class Bar {
func bar<T>(a:T){...}// generic non-open function in abstract class
}
struct R{
func foo<T>(a:T){...}// generic function in struct
}
enum E{
A|B|C
func e<T>(a:T){...}// generic function in enum
}
9.6.2 Generic class and interface instantiation
class Foo<T><:IBar<T >{
var a:T
static func foo(a:T){...}
func bar(a:T,b:Int32 ):Unit {...}
}
interface IBar <T>{
func bar(a:T,b:Int32 ):Unit
}
When T = Int32 , the following instantiated declaration will be generated
class Foo$Int32 <:IBar$Int32 {
var a:Int32
static func foo(a:Int32 ){...}
func bar(a:Int32 ){...}
}
interface IBar$Int32 {
func bar(a:Int32 ,b:Int32 )
}
9.6.3 struct instantiation:
struct instantiation is similar with class.
struct Foo<T>{
func foo(a:T){...}
}
When T = Int32 , the following instantiated declaration will be generated:
struct Foo$Int32 {
func foo(a:Int32 ){...}
}
9.6.4 Enum instantiation:
enum Either <L,R >{
Left(T)
|Right(R)
}
When Int32and Booltwo types are give to Either, it will be instantiated as:
enum Either$Int32$Bool {
Left( Int32 )
|Right( Bool )
}
When using a generic declaration, such as calling a generic function, constructing a value instance of a
generic type, the values of all type parameters of the generic must be determined and instantiated. In fact,
once a generic function or type is instantiated, the non-generic function or type is used.
•When <and >are used, they will be parsed as generic operator. If the process succeed, it will be parsed
as a generic expression. If parsing failed, it will parsed as a comparing expression. For example:
(c <d , e> (f))
This expression will be parsed as function call expression.
9.7 Generic F unction Overloading
In the CangJie programming language, overloading between generic functions and between generic functions
and non-generic functions is supported. For details about the definition of overloading, see Section Function
Overloading .
When a function is called, the overloading process is as follows:
Step 1: Construct a candidate set for function calling. The functions that enter the candidate set are
all functions that can be called. For details, see Candidate Set . There are extra rules for generic functions
when constructing a candidate set, which will be described in detail below.
Step 2: If there are multiple functions in the candidate sets, select the most matching function based on
thescopepriorityrules(Fordetails, see ScopePriority )andmostmatchingrule(Fordetails, see Closestmatch
rule). If the unique best matching function cannot be determined, an error indicating that the resolution
cannot be resolved is reported.
Step 3: If there are multiple types for an argument, determine the argument type based on the most
matching function. If the unique argument type cannot be determined, an error is reported.
When building a candidate set for function calls, pay attention to the following points for
generic functions:
1￿When a function is called, the generic function fmay be a partially instantiated generic function or a
fully instantiated function that enters the candidate set. The form of a candidate function is determined by
the form of the calling expression.
•The call expression is in the form C<TA>.f(A) , that is, fis a static member function of a generic type.
The type is instantiated first. Then, the instantiated static member function enters the candidate set
if it is type checked. If the type parameters of CisX, the function fthat enters the candidate set is to
replace Xwith TAinf:
𝜎 = [𝑋 ↦ 𝑇𝐴]
𝑓′= 𝜎𝑓
// The context contains the following types: Base, Sub, and Sub <: Base.
class F<X>{
static func foo<Y>(a:X,b:Y){} // foo1
static func foo<Z>(a:Sub, b:Z){} // foo2
}
/* The functions that enter the candidate set are foo1 and partial instantiated foo2:
foo<Y>(a:Base, b: Y) and foo<Z>(a: Sub, b: Z) */ ↪
var f=Foo<Base >.foo(Sub(), Base()) // foo2
•The calling expression is in the form of obj.f(A) , where objis an instance of a generic type instantiation
type, that is, fis a non-static member function of a generic type.
The type of the objin the expression must be determined first, and then the set of candidate functions
can be constructed based on the type of the obj. If the type of objis an instantiated type, and
the non-static member function fof the instantiated type is applicable with respect to A, the fis a
candidate.
// The context contains the following types: Base, Sub, and Sub <: Base.
class C<T, U >{
init (a:T,b:U){}
func foo(a:T,b:U){} // foo1
func foo(a:Base, b:U){} // foo2
}
/* It is infered that the type of obj is C<Sub, Rune>.
The functions that enter the candidate set are instantiated foo1, foo2:
foo(a:Sub, b:Rune) and foo(a: Base, b: Rune)
*/
main() {
C(Sub(), 'a').foo(Sub(), 'a') // choose foo1
return 0
}
2￿If no type arguments are provided during function invoking, that is, the function invoking format is
f(a), the generic function fis a candidate when:
•Iffis a generic function in the form of f<X_1, ...,X_m>(p1: T_1, ..., pn: T_n): R , the calling
expression does not provide type arguments, and the form is f(a_1, ..., a_n) . If fcan infer a group
of type arguments TA_1,...,TA_m for the call, and
–Once the inferred type arguments TA_1, ...,TA_m are substituted for the function type parameter
(T1, ..., Tn) off, the constructed types in the parameter of fis applicable with respect to A.
𝜎 = [𝑋1↦ 𝑇𝐴1, ..., 𝑋𝑚↦ 𝑇𝐴𝑚]
Δ ⊢ (𝐴1, ..., 𝐴𝑛) <∶ 𝜎(𝑇1, ..., 𝑇𝑛)
–If the return type RAis provided in the calling expression. The constructed type in the return
type of fis a subtype of RA.
𝜎 = [𝑋1↦ 𝑇𝐴1, ..., 𝑋𝑚↦ 𝑇𝐴𝑚]
Δ ⊢ 𝜎𝑅 <∶ 𝑅𝐴
3￿If the type arguments are provided during function invoking, that is, the function invoking format is
f<TA>(a) , the fis a candidate when:
•The number of type parameters of fis the same with the type argument TA, and TAsatisfy the generic
constraints of the f, and the parameter list of fis applicable with respect to a.Chapter 10
Overloading
10.1 F unction Overloading
10.1.1 Definition of F unction Overload
Function overloading occurs if multiple functions with the same name but different parameter types reside
in the same scope.
For details, see Function Overloading Definition .
Note the following:
1.Static member functions and instance member functions of an class, interface, struct type cannot be
overloaded with each other.
2.Static member functions and instance member functions of extends of the same type cannot be over-
loaded with each other, except that two functions in extensions of the same type both are private.
3.The constructors, static member functions, and instance member functions of an enum type cannot be
overloaded with each other.
In the following example, the instance member function fand static member function fin class Aare
overloaded, and an error will be reported during compilation.
class A{
func f(){}
//Static member function can not be overloaded with instance member function.
static func f(a:Int64 ){} // Error
}
In the following example, the instance member function gand static member function gin the extension
of class Aare overloaded, and an error will be reported during compilation.
class A{}
extend A{
func g(){}
static func g(a:Int64 ){} // Error
}
In the following example, instance member function hand static member function hare in different
extensions of class Aand are both private. No error will be reported during compilation.
extend A{
private func h(){}
}
extend A{
private static func h(a:Int64 ){} // OK
}
In the following example, constructor f, instance member function fand static member function fof
enum Eare overloaded, and an error will be reported during compilation.
enum E{
f(Int64 )// constructor
// Instance member function can not be overloaded with constructor.
func f(a:Float64 ){} // Error
// Static member function can not be overloaded with instance member function or constructor.
static func f(a:Bool ){} // Error
}
In the function call expression, the argument type and the context of the expression determined which
function is called.The steps are as follows:
Step 1: Construct a function candidate set.
Step 2: Function overloading resolution.
Step 3: Determine the argument types.
10.1.2 Candidate Set
When the function fis called, it is first required to determine which functions can be called, we call these
functions are candidate set.
To construct a function candidate set, perform the following steps:
1.Search for a visible function set, that is, determine all visible functions based on the call expression
and the context.
2.Check the type of functions in the visible function set. The functions that pass the type check (that
is, the functions that can be called) enter the candidate set.
10.1.2.1 Visible Function Set
Functions in the visible set must meet the following conditions:
1.Must be visible in the scope of the function call expression.
2.Determine the visible set based on whether fis a function or a constructor. 2.1. If fis a constructor,
determine the visible set according to the following rules:
•Iffis a type name who has constructors, the visible set includes only the constructors defined in f.
•Otherwise, if fis constructor name of a enumtype, the visible set includes only the constructor named
fin the specified enum.
•Otherwise, if fissuper, the calling expression appears in class/interface, and fcontains only the direct
super class’s constructor of the class/interface where the calling expression resides.
•Otherwise, if fis a type name without a constructor, the visible set is empty.
2.2. If fis a function name, the visible set includes functions that are introduced in the following ways:
•By calling function without qualifier￿e.g. f(...), the visible set includes functions introduced in the
following ways:
1)Local functions visible in the scope;
2)If the function call expression is in the static context of class/interface/struct , the static member
methods of the type is included.
3)If the function call expression is in the non-static context of class/interface/struct , the member
methods of class/interface/struct is included;
4)Functions defined in the top level of the package.
5)Functions declared in extend;
6)Functions imported from other packages by importclause .
•For function calls with a qualifier, e.g. c.f(...) , the visible set includes functions introduced in the
following ways:
1)Ifcis the name of a package and fis a function defined at the top of the package, it does not
include functions imported by way of importclause.
2)Ifcina.b.cis a type name defined by class,structorenum, visible set includes static methods
defined in the c.
3)If the function invocation is in the form of this.f(...) , that is, the this.f(...) expression
appears in the definition or extension of class,interface ,struct,enum. If present in a type
definition, the visible function set contains only non-static member methods fin the current type
(including inherited but not extended); If present in a type extension, the visible function set
contains both the non-static member method fin the type and in the extension.
4)Ifthefunctioninvocationisintheformof super.f(...) , thevisiblesetincludesnon-staticmember
functions in the super class or super interfaces.
5)If the function invocation is in the form of <object name>.f(...)
Iftheobjecttypeisa class,interface ,structorenumtypeandthetypecontainsinstancemember
method f, all member methods named fare included in the visible set.
2.3 If fis an instance of a type, assuming that fis of type T, the visible set includes the following:
1) The ()operator overload functions defined in T; 2) The ()operator overload functions defined in
the extension (visible in the current scope) of T; 3) If T has a super class, the ()operator overload
function inherited from the super class is also included. 4) If T implements interfaces, the ()operator
overload function obtained from the interface with the default implementation is also included.
3.When a function is called, the generic function fmay be a partially instantiated generic function or
a fully instantiated function that enters the visible function set. The form of a visible function is
determined by the form of the calling expression, which are described in detail in Section Generic
Function Overloading .
10.1.2.2 Type Checking
The type check is performed on functions in the visible function set. Only functions that pass the function
call type check can be added to the candidate set.
open class Base {}
class Sub <:Base {}
func f<X,Y>(a:X,b:Y){} // f1, number of type parameters is not matched
func f<X>(a:Base, b:X)where X <: Sub {} // f2
func test (){
f<Base >(Base(), Sub()) // candidate set: { f2 }
}
Note the following:
1.If an actual parameter has multiple types and one of the types of the parameter can pass the type check
in the type check phase, it is considered that the parameter can pass the type check of the candidate
function.
open class A{}
open class B<:A {}
func g(a:A):B{//g1
B()
}
func g(a:B):B{//g2
B()
}
func g(a:Int64 ):Unit {} //g3
// (A)->B <: (B)->B <: (B)->A
func f(a:(A)->B){} //f1, g1 can pass the type check
func f(a:(B)->B){} //f2, g1, g2 can pass the type check
func f(a:(B)->A){} //f3, g1, g2 can pass the type check
func f(a:Bool ){} //f4, no g can pass the type check
func test (){
f(g) // candidate set: { f1, f2, f3 }
}
10.1.3 F unction overloading Resolution
If there is no matching function declaration (i.e., with the right name and parameter types) in the scope, a
compilation error is reported.
If there is exactly one matching function declaration, it is invoked.
If there are multiple functions in the candidate set, the function with the highest scope priority is selected
first according to the scope priority rule . If there are still multiple matches with the highest scope level, the
closest match is selected based on the closest match rule . If no unique closest matching function exists, a
compilation error is reported.
10.1.3.1 Scope priority
If two functions in the candidate set have different scope levels, the function with the higher scope level is
selected when the function is overloaded. If the scope levels of the two functions are the same, the function
is selected based on the rules in closest match rule .
The scope level includes the following cases :
1.Functions defined in the super classes and sub classes in the candidate set are processed as the same
scope priority when the functions are overloaded.
2.Functions defined in the type and the extension of the type are processed as the same scope priority
during when the functions are overloaded.
3.Functions defined in different extensions of the same type in the candidate set are processed as the
same scope priority when the functions are overloaded.
4.The operator overloading functions in the extension or type and built in operators are processed in the
same scope priority when the functions are overloaded.
5.For other scenarios, the scope level based on the rules in Scope level .
/* According to the scope-level precedence principle, two functions in the candidate set, with
different scope-levels, are preferred to the one with higher scope-level. */ ↪
func outer (){
func g(a:B){
print( "1")
}
func g(a:Int32 ){
print( "3")
}
func inner (){
func g(a:A){print( "2")}
func innermost (){
g(B()) // Output: 2
g(1) // Output: 3
}
g(B()) // Output: 2
}
inner()
g(B()) // Output: 1
}
In the above example, the innermost function calls the gfunction, and the input argument B()is trans-
ferred. According to the scope-level priority principle, the function with a higher scope-level is selected.
Therefore, the funtion gdefined in line 7 is selected.
/* The inherited names are at the same scope level as the names defined or declared in the class.
*/ ↪
open class Father {
func f(x:Child) {print( "in Father" )}
}
class Child <:Father {
func f(x:Father) {print( "in Child" )}
}
func display (){
var obj:Child =Child()
obj.f(Child()) // in Father
}
In the above example, the function displaycalls the function f, and the input argument Child()is
passed. The function inherited from superclass has the same scope level as the function defined in the
subclass , selects f(x: Child) {...} defined in the Fatherclass based on the closest matching rule.
In the following example, the scope priority of function fdefined in class Cis the same as the function f
defined in an extension of Cwhen the functions are overloaded.
open class Base {}
class Sub <:Base {}
class C{
func f(a:Sub) :Unit {} // f1
}
extend C{
func f(a:Base) :Unit {} // f2
func g(){
f(Sub()) // f1
}
}
var obj =C()
var x=obj.f(Sub()) // f1
10.1.3.2 Closest match rule
There are multiple functions with the highest priority in the candidate set: { f_1, …, f_n}. These functions
are called match items. If there is a unique match item f_m, which is more matched than all other matches,
f_mis the most matched function.
The comparison between two matches is the comparison of the formal parameters of two matches:
Step 1: Specify the quantity and order of the shape parameters used for comparison in overloading
resolution.
•Note that if the function parameter has a default value, the default parameter that does not specify
an argument does not participate in the overload resolution.
open class Base {}
class Sub <:Base {}
func f(a!:Sub =Sub(), b!:Int32 =2){} // This is f1￿
func f(a!:Base =Base()) {} // This is f2.
var x1=f(a:Sub()) // parameters involved in comparison in f1 is only a
•If a function has named arguments, the sequence of the named arguments may be different from that
of the parameters. In this case, the sequence of the parameters used for overloading resolution must
be the same as that of the arguments to ensure that the parameters used for comparison of the two
candidate functions are corresponding.
Step 2: Compare the parameters of the two matches to determine which is better.
For two matching items, f_iand f_j, if the following conditions are met, f_iis more matched than f_j:
For a function call expression e<T1, ..., T_p>(e_1, ..., e_m, a_m+1:e_m+1, a_k:e_k) , if the number of
arguments is k, the number of parameters used for overloading resolution is k.
The parameters for f_iand f_jare(a_i1, ..., a_ik) and (a_j1, ..., a_jk) respectively. The types of
parameters are (A_i1, ..., A_ik) and (A_j1, ..., A_jk) .
If(a_i1, ..., a_ik) off_iis forwarded as arguments to f_j, the type checking can be passed, and
(a_j1, ..., a_jk) off_jis forwarded as arguments to f_i, the type checking failed , then, we consider that
f_iis better matched than f_j. As the following:
func f_i<X1,...,Xp>(a_i1 :A_i1, ...,a_ik :A_ik) {// f_i may not have type parameters
f_j(a_i1, ...,a_ik) // If this call expression can pass the type checking
}
func f_j<X1,...,Xq>(a_j1 :A_j1, ...,a_jk :A_jk) {// f_j may not have type parameters
f_i(a_i1, ...,a_ik) // And this expression cannot pass the type checking
}
The following are some examples of function overloading resolutions:
interface I3{}
interface I1<:I2&I3{}
interface I2<:I4 {}
interface I4<:I3 {}
func f(x:I4) {} // f1
func f(x:I3) {} // f2
class C1<:I1 {}
var obj =C1()
var result =f(obj) // choose f1, because I4 <: I3
open class C1{}
open class C2<:C1 {}
class C3<:C2 {}
func f(a:C1, b:C2, c:C1) {} // f1
func f(a:C3, b:C3, c:C2) {} // f2
func f(a:C3, b:C2, c:C1) {} // f3
// function call
var x=f(C3(), C3(), C3()) // f2
open class A{}
class B<:A {}
func foo<X>(a:X,b:X):Int32 {} // foo1
func foo(a:A,b:B):Int32 {} // foo2
func foo<X>(a:A,b:X):Int32 {} // foo3
foo(A(), A()) // Error: cannot resolve.
foo(A(), 1) // foo3. foo3 is the only function in candidate set.
10.1.3.3 Determine the Argument Type
If there are multiple types of arguments, we need to determine the type of arguments:
If only one of argument types ( T) that passes the most matching function’s type check, then the type of
the argument is determined as T, otherwise, an error is reported.
// Sub <: Base
func f(a:(Base) ->Int64 ,b:Sub) {}//f1
func f(a:(Sub) ->Int64 ,b:Base) {} //f2
func g(a:Base) :Int64 {0} // g1
func g(a:Sub) :Int64 {0} // g2
func test (){
f(g, Base()) // Error, both of g can pass f2's type check.
f(g, Sub()) // OK￿only g1 passes f1's type check.
}
10.2 Operator Overloading
The Cangjie programming language defines a set of operators that are represented by special symbols (see
Chapter 4 Expressions for all operators), such as arithmetic operators (i.e., +,-,*,/,%and **), logic operator
(i.e., !,&&and ||), function call operator (), etc. By default, the type of operands for an operator can only
be of specific types, e.g., the operand of an arithmetic operator can only be numeric types, and the operand
of a logical operator can only be of Booltype. If it is required to extend the operand types supported by
some operators, or allowing user-defined types to use these operators, operator overloading can be helpful.
In order to overload the operator opSymbol on the type Type, an operator function can be addedto
Type. After which, the operator function (named with opSymbol ) is automatically called when using operator
opSymbol on instances of Type.
The syntax for defining an operator function:
operatorFunctionDefinition
: functionModifierList? 'operator' 'func'
overloadedOperators typeParameters?
functionParameters (':' type)?
(genericConstraints)? ('=' expression | block)?
;
The operator function definition is similar to the ordinary function definition. The differences are as
follows:
•When defining operator functions, an operator modifier must be used before the funckeyword.
•The name of a operator function is the symbol of a operator, and the operator can be overloaded. For
details, see [Operators that can be reloaded].
•The number of parameters of the operator function must be the same as the number of operands of
the operator.
•Operator functions can only be defined in class, interface, struct, enum, and extend.
•Operator functions have the semantics of instance functions, so that staticis not allowed here.
•Operator functions can not be generic.
Note the following:
•It should be noted that the operators that are overloaded do not change their precedence and associa-
tivity (For details about the precedence and associativity, see Chapter 4).
•The usage of unary operators to be prefix operators or suﬀix operators keeps consistent with the default
usage of them. Since there are no operators in the Cangjie programming language that can be used as
both a prefix and a suﬀix operator, there will be no confusion.
•The way that operator functions are invoked follows the way that operators are used. Determine which
operator function to call based on the number and type of operands when multiple operator functions
with the same symbol.
In order to overload an operator opSymbol on a type Type, an operand function named opSymbol needs to
be defined on type Type. There are two ways to define operator functions on types:
1.For types that can not directly contain function definitions, i.e., types other than struct,class,enum
and interface , an operand function opSymbol can be indirectly added on Typebyextendin which the
operand function opSymbol is declared.
2.For types that can directly define functions, including class, interface, enum and struct, operator
overloading can be achieved by directly defining operator functions within them.
10.2.1 Define Operator F unctions
Since the operator function is associated with particular types, it has a little difference with common member
functions:
1.For unary operator functions, it must has no parameter, but the returned value can be any type.
For example, suppose opSymbol1 is a unary operator, the operator function opSymbol1 is defined as:
operator func opSymbol1 ():returnType1 {
functionBody1
}
2.For binary operator functions, it has one parameters, the returned value can be any type.
For example, suppose opSymbol2 is a binary operator, the operator function opSymbol2 can be defined as:
operator func opSymbol2 (right :anyType) :returnType2 {
functionBody2
}
Similarly, after defining operator functions in TypeName ,opSymbol1 toopSymbolN can be directly used over
instances of TypeName . The usage of every overloaded operator is same as their default way. Note that
operator functions are instance functions, using the overloaded operator opSymbol on instances AofTypeName
is actually the syntax sugar of the function call A.opSymbol(arguments) (different operator functions are
invoked based on the number and types of parameters).
The following example illustrates how to define operator functions in the classtype.
Suppose we want to implement two operations, i.e., prefix negative ( -) and infix addition( +), on a class
called Pointwhich containing two Int32variable members xand y). The prefix negative receive a Pointobject
then returns a new Pointobject whose value of xand yare the negative of xand yrespectively from the
received object. The infix addition receive two Pointobjects then returns a new Pointobject whose value of
xand yare the sum of xand yrespectively from the two received objects.
First, define a Pointclass in which two operator functions with the name -and +are defined:
class Point {
var x:Int32 =0
var y:Int32 =0
init (a:Int32 ,b:Int32 ){
x=a
y=b
}
operator func -():Point {
return Point( -x,-y)
}
operator func +(right :Point) :Point {
return Point(x +right.x, y+right.y)
}
}
Then, operator -and +can be directly used on objects of Point:
main() :Int64 {
let p1=Point( 8,24)
let p2=-p1 // p2 = Point(-8, -24)
let p3=p1+p2// p3 = Point(0, 0)
return 0
}
10.2.2 The Scope of Operator F unctions and the Search Strategy when Opera-
tors are Used
This section describes the scope of operator functions and the search strategy when operators are used.
10.2.2.1 The Scope of Operator Functions
Operator functions have the same scope level as ordinary functions defined or declared in the same location.
10.2.2.2 The Search Strategy when Operators are Used
With the abovedefinition for the scope of operator functions, the searchstrategy when operators are used can
be defined. Since the search for a unary operator function is a subcase of the search for a binary operator, so
only the search strategy for binary operators (denoted as op) are introduced (the search for unary operators
follows the same strategy):
Step 1: determine the type of the left operand lOperand and the type of the right operand rOperand
(assuming to be lTypeand rTyperespectively);
Step 2: Search for all operator functions associated with lTypewith the name opand the right operand
type rTypein the current scope of the calling expression lOperand op rOperand . If there is one and only one
such operator function, convert the expression call to a call to this operator function; if no such function is
found, continue with step 3.
Step 3: repeat step 2 in a lower scope. If no matching operator function is found in the lowest scope level
(i.e., 0), terminate the search action and generates a compilation error ( undefined function error);
10.2.3 Operators that can be Overloaded
The following table lists all the operators that can be overloaded (the closer an operator is to the top of the
table, the higher precedence it has):
Operator Description
() Function call
[] indexing
!- NOT: unary Negative: unary
** Power: binary
*/% Multiply: binaryDivide: binaryRemainder: binary
+- Add: binarySubtract: binary
<<>> Bitwise left shift: binaryBitwise right shift: binary
<<=>>= Less than: binaryLess than or equal: binaryGreater than:
binaryGreater than or equal: binary
==!= Equal: binaryNot equal: binary
& Bitwise AND: binary
^ Bitwise XOR: binary
| Bitwise OR: binary
It should be noted that:
1.Except for the operators listed in the above table, the other operators (see Section 1.4 for a complete
list of operators) do not support to be overloaded.
2.Once the two binary operators other than the relational operators <,<=,>,>=,==and !=) are overloaded
on a certain type, and the return type of the operator function is the same as or a subtype of the type
of the left operator, then the corresponding compound assignment symbol can be naturally used on
this type. However, if the type of the return value of the operator function is not the same as nor the
subtypeofthetypeoftheleftoperand,atypemismatcherrorisgeneratedwhenusingthecorresponding
compound assignment symbol on this type.
3.The Cangjie programming language does not support user-defined operators. That is, it is not allowed
to define operator functions with names other than operators listed in the above table.
4.The function call operator ( ()) overloaded functions have no requirements on input parameters and
return value types.
5.For a type T, ifTalready supports some of the above operators that can be overloaded by default,
then implementing the operator function with the same signature for Tby extension will result in a
redefinition error. For example, a redefinition error is reported when overloading a supported operator
with the same signature such as an arithmetic operator, bitwise operator or relational operator for
a numeric type, or overloading a relational operator with the same signature for the Chartype, or
overloading a same signatured logical, equal or unequal operator for the Booltype, etc.
There are the following special scenarios:
The ()operator overload function cannot be called with thisorsuper.
For enumeration types, if both the constructor form and the overloaded function of the ()operator are
satisfied, the constructor form is preferentially matched.
// Scenario for `this` or `super`.
open class A{
init (x:Int64 ){
this ()// error, missing argument for call with parameter list: (Int64)
}
operator func ()() :Unit {}
}
class B<:A {
init (){
super() // error, missing argument for call with parameter list: (Int64)
}
}
// Scenario for enum constructor.
enum E{
Y|X|X(Int64 )
operator func ()(a :Int64 ){a}
operator func ()(a :Float64 ){a}
}
main() {
let e=X(1)// ok, X(1) is to call the constructor X(Int64).
X(1.0) // ok, X(1.0) is to call the operator () overloading function.
let e1=X
e1(1)// ok, e1(1) is to call the operator () overloading function.
Y(1)// oK, Y(1) is to call the operator () overloading function.
}
10.2.4 Index Operator Overloading
The index operator ( []) is divided into two forms, let a = arr[i] and assignment arr[i] = a , which
are distinguished from each other by the presence or absence of a special named parameter value. Index
operator overloading does not require both forms to be overloaded, and can overload only assignment without
overloading fetch, or vice versa.
The sequence of arguments within the index operator value form []corresponds to the non-named
arguments of the operator overload, and can be 1 or more, and can be of any type. No other named
arguments are allowed. The return type can be of any type.
class A{
operator func [](arg1 :Int64 ,arg2 :String) :Int64 {
return 0
}
}
func f(){
let a=A()
let b:Int64 =a[1,"2"]
// b == 0
}
The sequence of arguments inside []corresponds to the non-named arguments of the operator overload,
which can be 1 or more, and can be of any type. The expression on the right side of =corresponds to the
named parameter overloaded by the operator, there is one and only one named parameter, the name of the
named parameter must be value, there can be no default value, and value can be of any type. The return
type must be of type Unit.
Note that value is only a special token and does not need to be called as a named parameter when the
index operator is assigned.
class A{
operator func [](arg1 :Int64 ,arg2 :String, value !:Int64 ):Unit {
return
}
}
func f(){
let a=A()
a[1,"2"]=0
}
In particular, Numeric type, Bool, Unit, Nothing, Rune, String, Range, Function, Enum, Tuple type do
not support the overloaded index operator assignment form.Chapter 11
Packages and Module Management
In the Cangjie programming language, a program is a collection of packages.
The members of a package are top-level definitions or declarations that can be defined or declared within
the source files in the package. Top-level definitions or declarations of the same name are not allowed within
a package (except function overloading).
A module is a collection of packages and is the minimum unit to be released to third-party developers.
11.1 Packages
11.1.1 Package Declaration
Package declaration begins with the keyword package, followed by the package name, must be at the first
non-comment, non-blank line of a file.
The syntax of package declaration is as follows.
packageHeader
: 'package' packageNameIdentifier
;
packageNameIdentifier
: identifier ('.' identifier)*
;
The package declaration in the following example means that the source file a.cjand b.cjare in the p1
and p2package respectively.
// a.cj
package p1
// b.cj
package p2
11.1.1.1 Package Names
In a package declaration, the keyword packageis followed by a package name. The package name must be
a valid identifier. Moreover, the package name should correspond to the relative path of the current source
file folder relative to the root of the source file, separated by ’. ’between two adjacent directory names. For
details on the mapping between the package name and the file system, see Mapping between Package Names
and the File System . According to the scope rules, if the package declaration has the same name as the
top-level declaration in the current package, an error will be reported.
11.1.2 Package Members
Members of a package include top-level declaration of classes, interfaces, struct, enum, typealias global
variables, extend, and functions. Kindly refer to the corresponding Sections on details on these declarations.
11.1.3 Import
The syntax of importis as follows.
importList
: ('from' identifier)? 'import' importAllOrSpecified (',' importAllOrSpecified)*
;
importAllOrSpecified
: importAll importAllAlias?
| importSpecified importAlias?
;
importSpecified
: (identifier '.')+ identifier
;
importAll
: (identifier '.')+ '*'
;
importAllAlias
: 'as' identifier '.' '*'
;
importAlias
: 'as' identifier
;
•Take import pkga.pkgb.item as an example, ‘ pkga.pkgb is the name of the package where the imported
top-level definition or declaration locates, and itemis the imported top-level definition or declaration.
•The identifier that follows the keyword asinimportAlias is an alias for the for the imported top-level
definition or declaration.
•The identifier after the fromkeyword is the name of the imported module, which is the same as the
module name specified in the import profile output by the module management tool or in the import
profile set by the user (these profiles maintain the mapping of the module name to the path of the
corresponding cjofile of the module). When importing content from current modules, you can omit
from identifier ; When importing across modules, you must specify the module using from identifier .
The compiler checks whether the path and the name of the imported package are the same. Packages
that do not match with their file paths will not be imported. An error will be reported indicating that
the packages were not found. Packages without module names cannot be imported by other modules.
•importdeclaration must be after the package declaration and before any other declaration.
from module_name import package1 .*
from module_name import package1 .*,package2 .*
from module_name import package1 .foo
from module_name import package1 .foo,package2 .bar
from module_name import package1 .foo asalias1 ,package2 .bar asalias2
// p1 without module name
package p1
// p2 without module name
package p2
import p1.*// this means import p1 without module name.
// p1 in module2
package p1
// p2 in module2
package p2
import p1.*// this means import p1 from module2.
// if parent path of p1.cjo is not module2,
// p1 is not a legal package and will not be imported.
// p1 without module name
package p1
// p2 without module name
package p2
import p1.*// this means import p1 without module name.
// p3 in module2
package p3
import p1.*// Error￿p1 does not exist in module2
The following rules apply when a package is imported.
•It is forbidden that only package name is imported like import packageName .
•Only public declarations or definitions can be imported. If a declaration or definition is not public, an
error will be reported for the import declaration.
•In the case of import packageName.xxx , only the declaration xxxis imported, which can be accessed
through the syntax packageName.xxx orxxx.
•In the case of import packageName.* , top-level declarations declared with modifier publicin the package
packageName are imported, which can be accessed through the syntax packageName.xxx or simply xxx.
•It is not supported to use the fully qualified name to access the contents of other packages that are
not imported.
•All top-level definitions or declarations are accessible from any file in the package by default. Importing
definitions or declarations of the current package is prohibited. It is supported to use a fully qualified
name like curPackageName.xxx to access the contents of the current package.
•Circular dependency imports between packages is forbidden.
11.1.3.1 Importing Visibility
The content imported in a source file of a package is visible to all source files of the same package.
package p1
public class C{}
public interface Add<T>{
func add(other :T):T
}
extend Int64 <:Add<Int64 >{
public func add(other :Int64 ):Int64 {
return this +other
}
}
// file1 in package p2
package p2
import p1.C
import p1.Add
interface Minus <T>{
func minus (other :T):T
}
extend Int64 <:Minus<Int64 >{
public func minus (other :Int64 ):Int64 {
return this -other
}
}
func Foo(){
var obj =C() // OK, the imported class C is visible to all files of current package.
1.add( 2) // OK, the imported extend declaration is visible to all files of current
package. ↪
2.minus( 1) // OK, the extend declaration is visible to all files of current package.
}
// file2 in package p2
package p2
func Bar(){
var obj2 =C() // OK, the imported class C is visible to all files of current package.
1.add( 2) // OK, the imported extend declaration is visible to all files of current
package. ↪
2.minus( 1) // OK, the extend declaration is visible to all files of current package.
}
11.1.3.2 import as
A declaration or the whole package can be renamed when it is imported using the syntax import packa-
geName.name as newName where newNameis a name used to refer to the declaration in the file. Renaming
can be used to avoid name conflicts when importing top-level declarations of the same name from different
packages.
// a.cj
package p1
public func foo(){...}
// c.cj
package p2
import p1.foo asf1 // rename foo defined in p1 as f1
func foo(){...}
var result1 =f1()
var result2 =foo()
•Renaming a package by using import packageName.* as newPackageName.* is supported to resolve name
conflicts between packages with the same name from different modules.
// a.cj in module1
package p1
public func f1(){...}
// b.cj in module2
package p1
public func f2(){...}
// main.cj in module3
from module1 import p1.*asA.*
from module2 import p1.*asB.*
main (){
A.f1()
B.f2()
}
•According to the rules in Scope level , the scope level of the imported name is lower than the top-level
scope level of the current package. It should be noted that the scope level of the new name renamed
by using import as is the same as the top-level scope level of the current package, and the renamed
function can still participate in function overloading.
// a.cj
package p1
public func f1(){...}
// b.cj
package p2
public func f2(a:String) {...}
import p1.f1asf// Ok, overloaded.
import p2.f2asf// Ok, overloaded.
func f(a:Int32 ){} // Ok, overloaded.
main() {
f(1) // Ok, invoke 'f' defined in b.cj.
return 0
}
•After renaming the imported declaration by using import as , the current package can only use the
renamed name. The original name cannot be used.
// a.cj in module1
package p1
public func f1(){...}
// b.cj in module2
package p1
public func f2(){...}
// c.cj in module3
package p2
public func foo(){...}
// main.cj in module3
from module1 import p1.*asA.*
from module2 import p1.*asB.*
import p2.foo asf2
main (){
A.f1() // OK
B.f2() // OK
p1.f1() // Error
module1.A.f1() // OK
f2() // OK
foo() // Error
p2.foo() // Error, f2 is a new name of p2.foo
}
•Ifimport as is not decorated with public, the new name is private and will not be exported; If import
asis decorated with public, it will be reexported.
// a.cj
package p1
public func f1(){}
public func f2(){}
// b.cj
package p2
import p1.f1asfoo // foo is private in current file.
public import p1.f2asfoo2 // foo2 is public.
// c.cj
package p3
import p2.foo // Error, name foo is not exported by package p2.
import p2.foo2 // OK, name foo2 is exported by package p2.
main() {
foo() // Error
foo2() // OK
}
11.1.3.3 import *
The syntax import packageName.* is used to import all top-level definitions or declarations in packageName .
package p1
// a.cj
public class C1{...}
public func foo(){...}
// b.cj
package p2
import p1.* // import all top-level type declarations in package p1.
var obj =C1()
var result =foo()
11.1.3.4 Importing Multiple Declarations
A package can import multiple declarations for the same package, which can be done in one of three ways.
package p1
public class C{}
public func f():Unit {}
package p2
// first way
import p1.CasC1
import p1.fasf1
package p3
// second way
import p1.CasC1,
p1.fasf1
package p4
// third way
import p1.{C asC1,
fasf1}
11.1.3.5 Importing Multiple Packages
A package can import several different packages. If top-level declarations of the same name are imported
from different packages, the import packagename.name as newName mentioned in the import as can be used to
avoid name conflicts. If no rename operation is performed, no error is reported at the importstatement. The
content with name conflicts can only be accessed by using packageName. XXX , while error will be reported
when accessing it by using its name only.
package p1
public class C{}
package p2
public class C{}
package p3
import p1.* // OK
import p2.* // OK
main() :Int64 {
let a=C() // Error, can not distinguish which class C is used.
let b=p1.C() // OK, class C in package p1 is used.
let c=p2.C() // OK, class C in package p1 is used.
}
package p4
import p1.C,p1.Add // OK
import p2.C,p2.Add // OK
main() :Int64 {
let a=C() // Error, can not distinguish which class C is used.
let b=p1.C() // OK, class C in package p1 is used.
let c=p2.C() // OK, class C in package p2 is used.
}
Similarly, if definitions or declarations with the same name of different packages with the same name are
imported from different modules, no error will be reported at the import declaration without renaming, but
it can only be accessed by moduleName.packageName.declName . Conflicting definitions or declarations cannot
be accessed through packageName.declName ordeclName , because neither of these two methods can distinguish
which definition or declaration is used.
// module m1
package pkg1
class C()
// module m2
package pkg1
class C{}
// module m3
from m1import pkg1 .C // OK
from m2import pkg1 .C // OK
var a=C() // Error
var b=pkg1.C() // Error
var c=m2.pkg1.C() // OK
If the imported definitions or declarations have the same name as the top-level definitions or declarations
in the current package and do not constitute function overloading, they will be shadowed according to the
scope rule mentioned in Shadowing , while if the imported definitions or declarations have the same name
as the top-level definitions or declaration in the current package and constitutes function overloading, the
function resolution is made according to the function overloading rule in Generic Function Overloading and
Function Overloading .
package pkg1
public func foo(a:Int8 ){} // f1
public func foo(a:Int16 ){} // f2
package pkg2
public func foo(a:Int32 ){} // f3
public func foo(a:Int64 ){} // f4
package pkg3
public class foo {}
package pkg4
import pkg1 .foo // Shadow
import pkg2 .foo // Shadow
import pkg3 .foo // Shadow
func foo(a:UInt64 ){} // f5
main() :Int64 {
let a:Int32 =1
pkg1.foo(a) // Error, overloading resolution is made in collection {f1, f2} of
pkg1 ↪
pkg2.foo(a) // OK, overloading resolution is made in collection {f3, f4} of pkg2
foo(a) // Error, overloading resolution is made in collection {f1, f2, f3,
f4, f5} ↪
return 0
}
11.1.3.6 Re-exporting
The imported content can be re-exported by using public import . The name imported with public import
is equivalent to defining a new name in this package that is the same with the imported one, namely public
import packageName.itemName as itemName . Other packages can import and use the re-exported content
directly without importing it from its original package.
// pkg1
package pkg1
public interface Num<T>{
func add(other :T):T
}
extend Int32 <:Num<Int32 >{
func add(other :Int32 ){
this +other
}
}
public var a:Int32 =1
public class C{}
// pkg2
package pkg2
public import pkg1 .Num
import pkg1 .a
public import pkg1 .C
// pkg3
package pkg3
import pkg2 .*
main ():Int64 {
1.add( 2) // OK, interface Num is re-exported by pkg2.
var b=a // error, a is not re-exported by pkg2.
var c=C() // OK, C is re-exported by pkg2.
return 0
}
If the current package imports a series of declarations that need to be exported along with other top-level
declarations in the current package, these declarations must be decorated with the public import keyword.
The situation where re-exports are required is when the imported type appears in the parameter type or
return value type of a function that has publicsemantics in the current package. When other packages
import declarations in the current package, the re-exported content in the current package is automatically
imported into other packages without manual import.
package pkg1
public class C{}
package pkg2
public import pkg1 .C // class C of pkg1 must be re-exported.
public func f(){
let c=C()
return c
}
package pkg3
import pkg2 .f
main ():Int64 {
let obj =f() // OK
return 0
}
In the above example, fis a publicfunction in pkg2whose return value type is the imported type C.
Another package pkg3imports the function finpkg2. If pkg3does not manually import the class Cinpkg1,
or keyword public import is not used in pkg2when importing function fto indicate that class Cis re-exported,
an error will be reported when invoking the function finpkg3because class Ccan not be found. Forcibly
restricting pkg2to re-export class C,pkg3does not need to manually import class Cfrom pkg1when using f.
Since the name imported with public import is equivalent to defining a new name in this package, the
name imported by public import have the same rules with the name renamed by import as , that is, the
scope level of the name imported by public import is consistent with the top level of the current package,
and if the imported definition or declaration is function type, the imported name will still participate in
function overloading.
package pkg1
public class C{}
public func f(){}
package pkg2
public class C{}
public func f(a:String){}
package pkg3
public import pkg1 .C // Error, C is redefined.
public import pkg2 .C // Error, C is redefined.
public import pkg1 .f // ok, overloaded.
public import pkg2 .f // ok, overloaded.
public class C{} // Error, C is redefined.
public func f(a:Int64 ){}// ok, overloaded.
For the re-export scenario using wildcards, re-export declarations that cause name conflicts are ignored
and an alarm is reported, indicating that the corresponding declarations are ignored.
// pkga
public func A1(){}
public class A1{}
public func A2(){}
// pkgb
public import pkga .*// warning￿imported declaration A1 conflicted in namespace of pkgb,
// it will be ignored by compiler.
// add A2 into namespace of pkgb
public func A1(){} // OK
// pkgc
public import pkgb .*// add A1￿A2 into namespace of pkgb
// pkgd
public import pkgb .*// warning￿imported declaration A1￿A2 conflicted in namespace of pkgd,
// they will be ignored by compiler.
public import pkgc .*// warning￿imported declaration A1￿A2 conflicted in namespace of pkgd,
// they will be ignored by compiler.
main() {
pkgb.A1() // OK
A1() // Error
}
11.1.4 Mapping between Package Names and the File System
A package may consist of multiple source files. The name of a package must be same as the directory
containing all source files in the package.
By default, srcis the root directory of source files of a project. So that, without special instructions, we
usesrcas the root directory of a module to contain the sub-directories and source files which should follow
the rules as described in this section. Users can also configure name of the root directory of the source file.
The directory will be ignored during compilation if it is empty or there is no valid code in the file. There
is no output ( .cjo,.o) as well.
It implies that the package name must be adjusted sometime to be consistent with the directory structure,
as shown in the following example.
// The directory structure is as follows:
src
`-- directory_0
|-- directory_1
| |-- a.cj
| `-- b.cj
`-- c.cj
// in c.cj, we make a declaration.
// c.cj
package directory_0
// in the a.cj file, the package name needs to correspond to the path name.
// a.cj
package directory_0 .directory_1
// b.cj
package directory_0 .directory_1
According to path and package name consistency rules, the folder name in which the package resides
must be a valid identifier and cannot contain other symbols such as ..
src
`-- directory_0
|-- directory_1
| |-- a.cj
`-- directory_0.directory
|-- b.cj
// a.cj
package directory_0 .directory_1 .pkgA // OK
// b.cj
package directory_0 .directory_1 .pkgB // Error, the directory name is illegal.
It is prohibited that a package having a sub-directory with the same name as a top level declarations in
that package.
// a.cj
package A
public class B{} // Error, top-level declaration "B" clashes with sub-directory of same name.
// b.cj
package A.B // Error, package "A.B" clashes with the top-level declaration "B" in package
"A". ↪
11.1.5 Package in the root directory of source files
The root directory of source files is the package where the module’s program entry is located, which can have
more than one source file. These files can declare any legal package name. If there is no package declaration,
the compiler will specify its package name as defaultby default. Package in the root directory of source
files will not do consistency check between the package name and file path, but all source files must have the
same specified package name.
11.1.5.1 Program Entry Point
The syntax of program entry point is as follows.
mainDefinition
: 'main' functionParameters (':' type)? block
;
The mainis the entry point to a Cangjie program. mainis not a function. The package in root directory
of source files can only have at most one top-level main. When a package is compiled into a library, the
program entry will be ignored by the compiler. When a package is compiled into a library, mainwill be
ignored by the compiler and will not be used as a program entry.
If the module is compiled using the compilation method of generating executable files (specified by the
users), the compiler will only look for the main method at the top level of root directory of source files. If
no or multiple main methods are found, the compiler will report an error. If a unique main method is found,
the compiler will further check its parameter and return value type.
The main can have no parameter or parameter of type Array<String> and return value of type Unitor
integer.
11.2 External and Internal
In the Cangjie programming language, the modifier publicis used to manage the accessibility of all top-level
definitions or declarations. Accessibility refers to whether it can be accessed in other packages.
When a declaration is modified by public, it indicates that the declaration can be directly imported
into other packages or can be accessed in the form of package name.xxx after the package is imported. The
declaration or definition that are not modified by publiccan be accessed within the current package. And
theinternal is the default accessibility.
public let a=1
let b=a// OK
let c=2
public let d=c// OK
The access level is specified as follows based on the accessible scope:
•Top-level access level: external > internal
Under this level, the behavior across access levels is defined as follows:
•Theaccessleveloftherightvalueoftheassignmentandvariabledeclarationexpressionscanbedifferent
from that of the left value.
Cangjie’s access control follows the rule that “an entity with a lower access level cannot be used to define
another entity”. An error will be reported at the declaration when the declaration modified by publicuses
internal types, including:
•The type of parameters and return value of the function declaration modified by publicmust be
external .
•The type of variable declaration including variable declaration in toplevel pattern modified by public
must be external .
•The type of typealias declaration modified by publicmust be external .
•The type referenced in the generic declaration modified by public(the type argument of the generic
type, the upper bound in the whereconstraint) must be external .
•The type referenced in the declaration modified by publicmust be external , specifically:
•The type of the inherited class or the implemented interface in the class declaration￿internface dec-
laration￿enum declaration or struct declaration modified by publicmust be external ￿ and the type
of members including function￿variable declaration￿property modified by publicorprotected must be
external .
open class A{}
public func foo(a:A){A()} // error, external declaration use internal types
public func foo<T>()where T <: A { 0}// error, external declaration use internal types
public type B=A// error, external declaration use internal types
public let (a, b,c)=(A(), 1,2)// error, external declaration use internal types
public C<:A{// error, external declaration use internal types
public :
func foo(a:A){A()} // error, external declaration use internal types
protected :
func foo(a:A￿b:A){}// error, external declaration use internal types
private :
func foo(){A()}
}Chapter 12
Exceptions
A software system often has to detect and handle exceptional or erroneous program behaviors. To ensure
the correctness and robustness of the software system, there must be program codes which are dedicated to
error detection and handling. Exceptions are special type of errors that can be caught and handled by the
programmer. Exceptions are abnormal behaviors that occur during the execution of the program, such as
index out of bounds, division by zero, overflow, invalid input and access to undefined objects.
Exceptions are abnormal behaviors of the program. Once an exception is thrown, the program must
handle it immediately. That is to say, the control flow of the program is transferred from where the execution
occurs to where the exception is caught and handled. The Cangjie programming language provides an
exception handling mechanism to handle exceptions that may occur at run-time. The exception handling
mechanism is composed of the following components.
•Try expressions, which include both ordinary try expressions and try-with-resources expressions.
•Throw expressions start with the keyword throwand are followed by expressions. The type of the
expression after throwkeyword must inherit from Exception orErrorclass.
In the following, we introduce try expressions and throw expressions in details.
12.1 T ry Expressions
Try expressions are divided into two types based on whether automatic resource management is involved:
the ordinary try expressions that do not involve automatic resource management, and the try-with-resources
expressions that automatically manage resources. The syntax of try expressions is as follows.
tryExpression
: 'try' block 'finally' block
| 'try' block ('catch' '(' catchPattern ')' block)+ ('finally' block)?
| 'try' '(' ResourceSpecifications ')' block ('catch' '(' catchPattern ')' block)* ('finally'
block)? ↪
;
catchPattern
: wildcardPattern
| exceptionTypePattern
;
exceptionTypePattern
: ('_' | identifier) ':' type ('|' type)*
;
ResourceSpecifications
: ResourceSpecification (',' ResourceSpecification)*
;
ResourceSpecification
: identifier (':' classType)? '=' expression
;
In the following, the ordinary try expressions and the try-with-resources expressions are introduced in
detail .
12.1.1 Ordinary T ry Expressions
ordinary try expressions (try expressions in this section unless stated otherwise) have three parts: a try
block, zero or more catch blocks and an optional finally block. Note that there must be at least one catch
block or finally block.
1.A try block starts with the keyword tryand is followed by a block consisting of expressions and decla-
rations (defined in a pair of braces) which creating a new local scope and can contain any expression
and declaration). If the block after try throws an exception and it matches one of the catch blocks,
the corresponding catch block starts executing immediately. If there is no catch block or the exception
does not match any of the catch blocks, the exception is thrown after evaluating the finally block.
2.A try expression can contain zero or more catch blocks (there must be a finally block when there is
no catch block). Each catch block starts with the keyword catch, followed by a (catchPattern) and a
block of expressions and declarations . The catchPattern matches the exception to be caught by pattern
matching, and if the match is successful, it is passed to the block of expressions and declarations for
processing, and all subsequent catch block are ignored. When all catchable exception types of a catch
block can be caught by other catch blocks defined before it, a “catch block unreachable” warning is
given at the catch block.
3.Afinallyblockstartswiththekeyword finally,andisfollowedbyablockconsistingofexpressionsand
declarations. finallyblocksaremainlydesignedforclean-upworks, e.g., releasingresources. Moreover,
throwing exceptions in the finally block is not recommended. The finallyblock always executes after
evaluating the tryblock and the catchblocks, no matter whether an exception is thrown or not.
catchPattern has two patterns:
•A wildcard pattern ( _) catches any type of exception, which equivalents to having e: Exception in the
type pattern (see below). That is to say, the wildcard pattern can match instances of class Exception
and that of its subclasses. The following shows an example.
// Catch with wildcardPattern.
let arrayTest :Array <Int64 >=Array <Int64 >([0,1,2])
try {
let lastElement =arrayTest[ 3]
}catch (_){
print( "catch an exception!" )
}
•A type pattern catches instances of a specific exception class or subclasses of the exception class. A
type pattern can be written in two forms.
–identifier: ExceptionClass . In this form, instances of the class ExceptionClass and that of its
subclasses are caught. When an instance is caught, the instance is converted to an instance of
class ExceptionClass . Afterwards, the instance is bound to the variable identifier so that it can
be accessed through identifier in the catchblock.
–identifier: ExceptionClass_1 | ExceptionClass_2 | ... | ExceptionClass_n . In this form, mul-
tiple exception classes can be concatenated using the connector |. The connector |intuitively
means or, i.e., this pattern catches instances of the class ExceptionClass_1 and that of its sub-
classes, or instances of the class ExceptionClass_2 and that of its subclasses, and so on. Because
the type of a caught instance cannot be statically determined, the instance is always converted to
the least common super-type of all classes connected by the |, after which the instance is bound
with identifier . As a result, member variables and member functions that are only defined in
the least common super-type of all ExceptionClass_i (1 <= i <= n) can be accessed through
identifier within the catch block. Furthermore, a wildcard pattern _can be used to replace
identifier in the type pattern.
An example of the usage of the type pattern is shown below:
// The first situation.
main() {
try {
throw ArithmeticException()
}catch (e:RuntimeException) {// Caught.
print( "RuntimeException and its subtypes can be caught here" )
}
}
// User defined exceptions.
open class Father <:Exception {
var father :Int64 =0
func whatFather (){
print( "I am Father" )
}
}
class ChildOne <:Father {
var childOne :Int64 =1
func whatChildOne (){
print( "I am ChildOne" )
}
func whatChild (){
print( "I am method in ChildOne" )
}
}
class ChildTwo <:Father {
var childTwo :Int64 =2
func whatChildTwo (){
print( "I am ChildTwo" )
}
func whatChild (){
print( "I am method in ChildTwo" )
}
}
// Function main.
main() {
var a=1
try {
throwE()
}catch (e:ChildOne |ChildTwo) {
e.whatFather() // ok: e is an object of Father
//e.whatChildOne() // error: e is an object of Father
//e.whatChild() // error: e is an object of Father
print(e.father) // ok: e is an object of Father
//print(e.childOne) // error: e is an object of Father
//print(e.childOTwo) // error: e is an object of Father
}
func throwE (){
if(a==1){
ChildOne()
}else {
ChildTwo()
}
}
}
The following shows an example of a finallyblock.
// Catch with exceptionTypePattern.
let arrayTest :Array <Int64 >=Array <Int64 >([0,1,2])
try {
let lastElement =arrayTest[ 3]
}catch (e:ArithmeticException |ArrayIndexOutOfBoundsException) {
print( "exception info: " +e.toString())
}catch (e:Exception) {
print( "neither ArithmeticException nor ArrayIndexOutOfBoundsException, exception info: " +
e.toString()) ↪
}finally {
print( "the finally block is executed" )
}
12.1.1.1 The type of tryexpression
Similar to the if expressions,
1.When tryexpression is not read or returned, then the type of the tryexpression is Unit, and the try
block and catchblocks are not required to have common supertype; otherwise check types as below;
2.If the context does not explicitly require a certain type, the tryblock and all catchblocks (if present)
are required to have their least common super type, which is also the type of the entire tryexpression.
3.If the context does explicitly require a certain type, the tryblock and each of the catchblocks (if
present) are required to be a subtype of the required type. In this case, however, they are not required
to have their least common super type.
12.1.1.2 The evaluation order of tryexpression
Moreover, the type of the final lyblock is always Unit, regardless of the type of expressions in the block.
Here are additional rules about the execution of the try {e1} catch (catchPattern) {e2} finally {e3}
expression:
•If any return e expression is executed before entering the finally block, then ewill be evaluated to
a value vand the finally block will be executed immediately; if any breakorcontinue expression is
executed before entering the finally block, then the finally block will be executed immediately.
–If there is no return(or throwexpression) in the final lyblock, the cached result vwill be returned
(or an exception will be thrown) after the final lyblock is processed. That is, assignment to any
variable referenced in the expression eabove in the final lyblock will not affect the result v(that
has already been evaluated). For example:
func f():Int64 {
var x=1;
try {
return x+x; // Return 2.
}catch (e:RuntimeException) {// Caught.
print( "RuntimeException and its subtypes can be caught here" )
}finally {
x=2;
}// The return value is 2 but not 4.
–If some other return e2 orthrow e2 in the finally block is executed, e2will be evaluated to the
result v2. Then v2is returned or thrown immediately. If any breakorcontinue expression in the
finally block is executed, then the enclosing loop will be ended immediately. For example:
func f():Int64 {
var x=1;
try {
return x+x;// Return 2.
}catch (e:RuntimeException) {// Caught.
print( "RuntimeException and its subtypes can be caught here" )
}finally {
x=2;
return x+x;// Return 4
}// The return value is 4 but not 2.
}
In conclusion, a finally block will be executed anyway. If any control transfer expression within the finally
block is executed, then the ones executed before entering the finally block will not take effect.
The treatment for throwexpressions within a try expression is much more complex and is explained in
the next section.
12.1.1.3 The exception handling of tryexpression
Given a try expression try {e1} catch (catchPattern) {e2} finally {e3} , its evaluation has the following
cases.
1.If no exception is thrown during the evaluation of the expression e1, the expression e2is not evaluated
and the expression e3is evaluated.
•If no exception is thrown during the evaluation of e3, the tryexpression does not throw any
exception.
•Ifananexception E3isthrownduringtheevaluationof e3, the tryexpressionthrowstheexception
E3.
2.If an exception E1is thrown during the evaluation of e1, and an exception E3is thrown during the
evaluation of e3, the tryexpression throws the exception E3(regardless of whether E1is caught by the
catch block).
3.Assume that an exception E1is thrown during the evaluation of e1, and no exception is thrown during
the evaluation of e3, then:
1.If the exception E1is caught by a catchblock and no exception is thrown during the evaluation
ofe2, then the try expression will not throw an exception.
2.If the exception E1is caught by a catchblock and an exception E2is thrown during the evaluation
ofe2, then the try expression throws the exception E2.
3.If the exception E1is not caught by the catchblocks, the try expression throws the exception E1.
12.1.2 The T ry-With-Resources Expression
Try-with-resources expressions are introduced mainly for automatically releasing non-memory resources.
In a try-with-resources expression, one or more ResourceSpecifications are defined between the keyword try
and its following block. A resource is in general an object in Cangjie. Note that both catch blocks and the
finally block are optional in a try-with-resources expression. Furthermore, ResourceSpecification does not
affect the type of the try expression. The following is an example of try-with-resources expressions.
try (input =FileInputStream( "input.txt" ),
output =FileOutputStream( "output.txt" )){
while (input.hasNextLine()) {
let lineString =input.readLine()
output.writeLine(lineString)
}
}
Thetypeof ResourceSpecification sintry-with-resources expressionmustimplement Resource interface:
interface Resource {
func isClosed ():Bool
func close ():Unit
}
Thetry-with-resourcesexpressionfirstinstantiates(indeclarativeorder)thecorrespondingsetofresource
requests (in the above example, the inputobject is instantiated first, followed by the outputobject), during
which if a resource request fails (e.g. the outputinstantiation fails), all the resources that were successfully
requested before it (e.g., the inputobject) are released (any exceptions thrown during the release process are
suppressed) and an exception is thrown for the failure to request this resource ( output).
If all resources are successfully requested, execution continues with the block immediately following
try. During the execution of the block, whether or not an exception is thrown, the resources are then
automatically released in the reverse order in which they were requested (in the above example, the output
object is released first, then the inputobject). In the process of releasing resources, if an exception is thrown
when a resource is released, it does not affect the release of other resources, and the exceptions thrown
by the entire try expression conform to the following principles: (1) if an exception is thrown in the block
immediately following try, the exception thrown during the release of the resource is suppressed; (2) if no
exception is thrown in the block immediately after try, the first exception thrown during the release will be
thrown (any subsequent exceptions thrown during the release will be ignored).
It should be noted that, when using try-with-resources expressions, it is generally not necessary to
include catch and finally blocks and we do not recommend the user manually release resources, as all
requested resources are automatically released during the execution of the try block, regardless of whether
an exception occurs, and any exceptions thrown during execution are thrown outwards. However, if it is
necessary to explicitly catch and handle any exceptions that may be thrown during a try block or resource
request and release, it is still possible to include catch blocks and a finally block in a try-with-resources
expression:
try (input =FileInputStream( "input.txt" ),
output =FileOutputStream( "output.txt" )){
while (input.hasNextLine()) {
let lineString =input.readLine()
output.writeLine(lineString)
}
}catch (e:IOException) {
print( "IOException happened when executing the try-with-resources expression" )
}finally {
print( "end of the try-with-resources expression" )
}
In fact, the above try-with-resources expression is equivalent to the following ordinary try expression:
try {
var freshExc :Optional <Exception >=None // A fresh variable that could store any exceptions
let input =FileInputStream( "input.txt" )
try {
var freshExc :Optional <Exception >=None
let output =FileOutputStream( "output.txt" )
try {
while (input.hasNextLine()) {
let lineString =input.readLine()
output.writeLine(lineString)
}
}catch (e:Exception) {
freshExc =e
}finally {
if(!output.isClosed()) {
try {
output.close()
}catch (e:Exception) {
if(freshExc !=None) {
throw freshExc // Exceptions raised from the user code will be thrown
}else {
throw e
}
}
}else {
if(freshExc !=None) {
throw freshExc
}
}
}
}catch (e:Exception) {
freshExc =e
}finally {
if(!input.isClosed()) {
try {
input.close()
}catch (e:Exception) {
if(freshExc !=None) {
throw freshExc
}else {
throw e
}
}
}else {
if(freshExc !=None) {
throw freshExc
}
}
}
}catch (e:IOException) {
print( "Exception happened when executing the try-with-resources expression" )
printException(e)
}finally {
print( "end of the try-with-resources expression" )
}
As we can see, any exception thrown in the tryblock (i.e., user code) are recorded in the freshExc variable
and eventually thrown outward, taking precedence over exceptions that may occur during the release of
resources. The type of try-with-resource expression is Unit.
12.2 Throw Expressions
The syntax of the throwexpressions is as follows.
throwExpression
: 'throw' expression
;
Throw expressions consist of the keyword throwand an expression that is used to throw an exception.
Throw expressions are always of Nothingtype. Note that the expression following the keyword throwcan
only be an object inherited from Exception orError. Throw expressions alter the execution logic of the
program: the throw expression will throw an exception when executed and the block of code that catches
the exception will be executed instead of the expressions after throw.
The following is an example throwing an exception:
// Catch with exceptionTypePattern.
let listTest =[0,1,2]
try {
throw ArithmeticException()
let temp =listTest[ 0]+1// Will never be executed.
}catch (e:ArithmeticException) {
print( "an arithmeticException happened: " +e.toString())
}finally {
print( "the finally block is executed" )
}
An exception thrown by a throw expression should always be caught somewhere. The matching catch
expression is identified in the reverse order of the function calls, i.e., if it is first matched with catchblocks
in the same tryexpression if there are any and then those catchblocks of the tryexpression which invokes
the containing function, and so on. If no matching catchblock is found to handle the exception, the control
is transferred to the terminate function defined in the Exception class, which aborts the execution of the
program.
The following example shows the scenario where an exception is caught at different program locations.
// Caught by catchE().
func catchE (){
let listTest =[0,1,2]
try {
throwE() // caught by catchE()
}catch (e:ArrayIndexOutOfBoundsException) {
print( "an ArrayIndexOutOfBoundsException happened: " +e.toString())
}
}
// Terminate function is executed.
func notCatchE (){
let listTest =[0,1,2]
throwE()
}
// func throwE()
func throwE (){
throw IndexOutOfBoundsException()
}Chapter 13
Multi-language Interoperability
13.1 C Interoperability
There are situations where access to operating system becomes a necessity. To address this need, Cangjie
provides the ability to interact with C language. However, Cangjie language differs notably from C in its
ability to create objects that are managed by a garbage collector. This design makes Cangjie a much safer
language than C, and brings a few restrictions when interacting with C.
13.1.1 unsafe context
Since it is too easy to cause unsafety in C language, all the interoprations with C language in Cangjie are
available only in unsafe contexts. An unsafe context is introduced by including an unsafe keyword.
unsafekeyword can be used in the following situations: 1. qualify a block. The type of an unsafe
expression is the same as the type of the block. 2. qualify a function definition.
Allunsafefunctions and CFunctype functions must be called in an unsafecontext.
Allunsafefunctions cannot be used as a first-class citizen, including cannot be assigned to a variable,
cannot be used as an argument or return value, cannot be used as an expression.
unsafeExpression
: 'unsafe' '{' expressionOrDeclarations '}'
;
unsafeFunction
: 'unsafe' functionDefinition
;
13.1.2 Calling functions in C
13.1.2.1 The foreignkeyword and @C
If we want to call C functions in Cangjie language, the function should be declared in Cangjie and modified
by foreign keyword. The foreignfunctions can only exist in the top-level scope and is only visible inside
the package, so no other function modifiers can be used.
@Csupports only modifying foreignfunctions, non-generic functions and structtypes in the top-level
scope. When modifying the foreignfunction, @Cmay be omitted. Unless otherwise specified, the foreign
function in the C interoperability is considered as a foreignfunction modified by @C.
Under @Cmodifier, the foreignkeyword only allows modify non-generic functions in the top-level scope.
foreignfunction is a declaration, without function body, its parameters and return types cannot be omitted.
The foreignfunction modifier allows providing functions that can be called with native C ABI and no name
mangling.
foreign func foo(): Unit
foreign var a: Int32 = 0 // compiler error
foreign func bar(): Unit { // compiler error
return
}
Multiple foreign function declarations can be declared with foreign blocks. The foreign block is a
sequence of declarations enclosed by a pair of curly braces after the foreignkeyword. The foreignblock can
only contain function declarations. @Chas the same rules on foreignblocks as on single foreigndeclaration.
When @Cmodifies the foreignblock, @Cis added to each function in the foreignblock.
foreign {
func foo(): Unit
func bar(): Unit
}
The foreignfunction should be able to link with one defined in C language with the same name, and its
parameters type and return type need to be the same with the one in original C language function. Only
types with CTypeconstraint can be used as parameters type and return type in foreignfunction. See the
following section “type mapping” for the definition of CTypeconstraint.
The foreignfunction does not support named parameters and parameter default values. foreignfunction
allows variable-length arguments, which is described by ...as the last one in parameter list. Variable-length
parameters must meet the CTypeconstraint but do not have to be of the same type.
13.1.2.2 CFunc
The CFuncin Cangjie refers to a function that can be called by C code. There are three forms:
1.foreignfunctions modified by @C
2.Cangjie functions modified by @C
3.Lambda expression of the CFunctype
•Unlike normal lambda expressions, CFunc lambda cannot capture variables.
// Case 1
foreign func free (ptr :CPointer <Int8 >):Unit
// Case 2
@C
func callableInC (ptr :CPointer <Int8 >){
print( "This function is defined in Cangjie." )
}
// Case 3
let f1:CFunc <(CPointer <Int8 >)->Unit >={ptr =>
print( "This function is defined with CFunc lambda." )
}
The types of functions declared/defined in the preceding three forms are CFunc<(CPointer<Int8>) ->
Unit>.CFuncis the type corresponding to C’s function pointer type. The type is a generic type. The generic
parameter indicates the input parameter and return value type of the CFunc. The following example shows
how it can be used:
foreign func atexit (cb:CFunc <()->Unit >)
As with the foreignfunctions, the parameters and return types of other forms of CFuncmust conform
theCTypeconstraint, and named parameters and parameter default values are not supported.
When CFuncis invoked in Cangjie code, it needs to be in an unsafe context.
In Cangjie, a variable of type CPointer<T> can be converted to a specific CFunc. The generic parameter T
ofCPointer can be any type that meets the CTypeconstraint. The following example shows how it can be
used:
main() {
var ptr =CPointer <Int8 >()
var f=CFunc <()->Unit >(ptr)
unsafe {f() }// core dumped when running, because the pointer is nullptr.
}
13.1.2.3 inout parameter
When calling CFuncin Cangjie, the parameter can be modified with the keyword inoutto form a pass-by-
reference expression, in which case the parameter is passed by reference. The pass-by-reference expression
is of type CPointer<T> , where Tis the type of the expression that the inoutexpression modifies.
A pass-by-reference expression has the following constraints:
•Can only be used on calls to CFunc;
•The type of the modified object must meet the CTypeconstraint, but cannot be CString;
•The modified object can not be defined with let, can not be a literal, a value of other expression and
other temporary variables;
•The pointer passed to the C side by the Cangjie side pass-by-reference expression is valid only for this
function call, that is, the C side should not save the pointer for later use in this scenario.
Variables modified by inoutcan be variables defined in the top-level scope, local variables, or member
variables in struct, but cannot be derived directly or indirectly from instance member variables of class.
foreign func foo1 (ptr :CPointer <Int32 >):Unit
@C
func foo2 (ptr :CPointer <Int32 >):Unit {
let n=unsafe {ptr.read() }
println( "*ptr = ${n}")
}
let foo3 :CFunc <(CPointer <Int32 >)->Unit >={ptr =>
let n=unsafe {ptr.read() }
println( "*ptr = ${n}")
}
struct Data {
var n:Int32 =0
}
class A{
var data =Data()
}
main() {
var n:Int32 =0
unsafe {
foo1(inout n) // OK
foo2(inout n) // OK
foo3(inout n) // OK
}
var data =Data()
var a=A()
unsafe {
foo1(inout data.n) // OK
foo1(inout a.data.n) // Error, n is derived indirectly from instance member variables of
class A ↪
}
}
13.1.2.4 Calling Convention
Function calling conventions describe how callers and callees make function calls (such as how parameters
are passed, who cleans the stack, etc.). Both function call and called parties must use the same calling
convention to run properly. The Cangjie programming language uses the @CallingConv to represent various
calling conventions. The supported calling conventions are as follows:
•CDECL ,CDECLrepresents the calling convention used by clang’s C compiler by default on different
platforms.
•STDCALL ,STDCALLrepresents the calling convention used by the Win32 API.
For C functions that are called through the C language interoperability mechanism, if the calling conven-
tion is not specified, the default CDECLcalling convention is used. Example of calling the C standard library
function clockas follows:
@CallingConv [CDECL] // Can be omitted in default.
foreign func clock ():Int32
main() {
println(clock())
}
The @CallingConv can only be used to modify foreignblock, single foreignfunction, CFuncfunction in
te top-level scope. When @CallingConv modifies a foreignblock, the same @CallingConv modifier is added
to each function in the foreignblock.
13.1.3 Type mapping
When declaring a foreign function in the Cangjie programming language, the types of parameters and return
values must match the type of the C function to be called. The Cangjie programming language type is
different from the C language type. Some simple value types, such as the int32_ttype in C language, can
be directly used by the Cangjie programming language Int32, but some complex types such as structures
require corresponding type declarations with the same memory layout in Cangjie. The types can interact
with C language in Cangjie programming language must conform to CTypeconstraint, they can be divided
into primitive types and complex types. The primitive foreign types include integer types, floating point
types, the Booltype, the CPointer type and Unittype. Complex foreign types include structs modified by
@Cand CFunc.
13.1.3.1 Primitive Type
When passing parameters between the Cangjie programming language and C, the primitive value types are
copied,suchas int,short,etc. The**fundamentaltypemappingtable**matchingtheCangjieprogramming
language and C language is as follows:
Cangjie Type C type Size
Unit void 0
Bool bool 1
Int8 int8_t 1
UInt8 uint8_t 1
Int16 int16_t 2
UInt16 uint16_t 2
Int32 int32_t 4
UInt32 uint32_t 4
Int64 int64_t 8
UInt64 uint64_t 8
IntNative - platform dependent
UIntNative size_t platform dependent
Float32 float 4
Float64 double 8
Note: Because the size of intand longtypes in C is indeterminate, so the programmers need to specify
the corresponding type in the Cangjie programming language. In C interoperation scenarios, like C, the Unit
type can only be used as a return type in CFunc and as a generic parameter to CPointer.
The types of the parameters and return values of the foreign function in the Cangjie programming
language need to correspond to the types of C function parameters and return values. For types that have a
clear type mapping relationship and are platform independent (refer to the basic type mapping relationship
table), you can directly use the standard corresponding Cangjie programming language basic types. For
example, there is an addfunction defined in C as follows:
int64_t add(int64_t X, int64_t Y) { return X+Y; }
The addfunction is called in the Cangjie programming language. The code example is as follows:
foreign func add(x:Int64 ,y:Int64 ):Int64
main() {
let x1:Int64 =42
let y1:Int64 =42
var ret1 =unsafe {add(x1, y1) }
...
}
13.1.3.2 Pointer
Cangjie provides CPointer<T> type to represent T*type in Clanguage, while Tmust conform to CTypecon-
straint.
There are some rules on CPointer type: * its size and alignment is platform dependent * the arithmetic
operations and read/write operations should be enclosed in unsafe context * CPointer<T1> is allowed to cast
toCPointer<T2> in unsafe context
CPointer has a few member methods:
func isNull ():bool
// operator overloading
unsafe operator func +(offset :int64) :CPointer <T>
unsafe operator func -(offset :int64) :CPointer <T>
// read and write access
unsafe func read ():T
unsafe func write (value :T):Unit
// read and write with offset
unsafe func read (idx :int64) :T
unsafe func write (idx :int64, value :T):Unit
CPointer can construct an instance by its type name, and the value is corresponding to C language’s
NULL.
func test (){
let p=CPointer <Int64 >()
let r1=p.isNull() // r1 == true
}
In Cangjie, a variable of type CFunccan be converted to a specific CPointer . The generic parameter Tof
CPointer can be any type that meets the CTypeconstraint. The following example shows how it can be used:
foreign func rand ():Int32
main() {
var ptr =CPointer <Int8 >(rand)
0
}
13.1.3.3 String
The C language string is actually a one-dimensional character array terminated with ‘ 0’. The ffipackage
provides CStringto match Clanguage strings. The Cangjie programming language create Clanguage strings
byCStringconstructors, and then released by freemethod in CStringclass if necessary.
When declaring a foreign function, you need to determine the function name, parameter type, and return
value type according to the declaration of the C language function to be called. The C language standard
library printffunction is declared as follows:
int printf( const Rune *format, ...)
The parameter Rune *type corresponds to Cangjie’s type CStringclass, and the return type intcorre-
sponds to Cangjie’s Int32. An example of creating a string and calling the printffunction is as follows:
package main
foreign func printf (fmt :CString, ...):Int32
main() {
let str:CString =CString( "hello world! \n")
unsafe {
printf(str)
str.free()
}
}
13.1.3.4 Struct
When the foreignfunction signature contains struct type, you need to define corresponding structwith the
same memory layout in Cangjie side, which is modified by @C.
Referring to the following example, a C graphics library (libskialike.so) has a function distance that
calculates the distance between two points. The related structures and functions in the C language header
file are declared as follows:
struct Point2D {
float x;
float y;
};
float distance (struct Point2D start, struct Point2D end);
When declaring a foreignfunction, you need to determine the function name, parameter type, and return
value type according to the declaration of the C language function to be called. When creating a C-side
structure, you need to determine the name and type of each field of the structure. The code example is as
follows:
package main
@C
struct Point2D {
var x:Float32
var y:Float32
}
foreign func distance (start :Point2D, end:Point2D) :Float32
Structs modified by @Cmust follow a few restrictions:
•their member fields’ type must conform to CTypeconstraint
•it cannot be used as non-static member fields of other classes and structs
•it cannot implement or extend interface
•it cannot be used as element type of tuple
•it cannot be used as associated value type of enum
•it cannot be captured by lambdas
•it cannot have generic parameters
•it cannot be used as type parameters
Structs modified by @Cautomatically conform to CTypeconstraint
13.1.3.5 Function
The function type in Cangjie do not conform to CTypeconstraint, so the CFuncis provided as the mapping
of the function type in C. The function pointer type defined in the following code in C can be mapped to
CFunc<() -> Unit> in Cangjie.
// Function pointer in C.
typedef void (*FuncPtr) ();
For details about CFunc, see the previous CFuncsection.
13.1.4 CType Interface
The CTypeinterface is a language built-in empty interface, which is the implementation of CTypeconstraint
and is by implicitly implemented by all types supported in C Interoperation. So all types supported in C
Interoperation can be used as subtypes of the CTypeinterface.
@C
struct Data {}
@C
func foo(){}
main() {
var c:CType =Data() // ok
c=0// ok
c=true // ok
c=CString( "Hello" )// ok
c=CPointer <Int8 >()// ok
c=foo // ok
}
The CTypeinterface is an interface type in Cangjie and does not meet the CTypeconstraint. In addition,
theCTypeinterface cannot be inherited, implemented explicitly or extended.
The CTypeinterface does not exceed the usage limit of its subtypes.
@C
struct A{}// implicit implement CType
class B<:CType {} // error
class C{}// error
extend C<:CType {} // error
class D<T>where T <: CType {}
main() {
var d0=D<Int8 >()// ok
var d1=D<A>()// error
}
13.2 JavaScript Interoperability
13.2.1 Type Mapping
13.2.1.1 Value Type Mapping
Cangjie JavaScript
Int8/UInt8 number
Int16/UInt16 number
Int32/UInt32 number
Int64/UInt64 number(limited)
Float16/Float32/Float64 number
Rune String
Bool boolean
Unit undefined
String String
Tuple array
enum object (limited)
function function
•Int64/UInt64 is mapped to numberin relaxed mode and opaque objectin strict mode. In relaxed mode,
accuracy will be lost beyond the range of −253253.
•The enumtype only supports direct mapping as a specific type parameter when all constructors have
only one type parameter. The sample is as follows￿
// othername.cj
package othername
enum MomentInput ={I32( Int32 )|Str(String) |Obj(UserDefineClass)}
@JsModule ("moment")
foreign func moment2 (date1 :MomentInput, date2 :MomentInput) :Moment
// main.cj
import othername
main (){
othername.moment2(.Str( "20111031" ),"YYYYMMDD" ).fromNow()
othername.moment2(.I32( 20111031 ),"YYYYMMDD" ).fromNow()
}
In the example code, .I32(20111031) directly corresponds to the JavaScript number type, and
.Str("20111031") directly corresponds to the JavaScript String type.
•struct,Rangeand other unmentioned types do not support mapping when doing JavaScript Interop-
erability.
13.2.1.2 Reference Type Mapping
Cangjie JavaScript
interface (foreign) class
class (foreign) class
13.2.2 Calling JavaScript from Cangjie
Call JavaScript from Cangjie￿you need￿
•Import Dependency
Currently, the NPMpackage and JavaScript file are supported. To import dependency, declare the name
and version of the dependency package in module.json . (The JavaScript file requires the file path.)
•Write bindings for JavaScript API .
Write bindings with the foreignmodifier and a series of annotations ( @JsModule ,@JsMember ,@JsRename ).
13.2.2.1 Import Dependency
Import NPM package When adding the npmpackage dependency, you only need to add the depended
npmpackage and version number to the npmsfield under the module.json ￿foreignRequires field. The format
is as follows:
"foreignRequires":{
"npms": {
"package name": "version number"
}
}
The format of version number complies with the format of npmpackage version. You can add ~ or ^
before the version number to limit the version.
~ will match the dependency package of the latest minor version. For example, to 1.2.3 will
match all 1.2.x versions. ^ will match the latest dependency package of the major version. For
example, ^1.2.3 will match all 1.x.x packages.
The complete module.json example is as follows:
{
"name" :"module name" ,
"description" :"some description" ,
"version" :"module version" ,
"requires" : {
"modules" : [{
"name" :"badboy/foo" ,
"version" :"0.1.0" ,
"repository" :"https://github.com"
}]
},
"foreignRequires" : {
"npms" : {
"lodash" :"^4.17.15"
}
},
"exports" : ["goo" ,"yoo" ]
}
In the sample code, the npms parameter under the foreignRequires field specifies the loadash package to
be imported. The default version is 4.17.15. If the latest 4.x.x version is available, select the latest version.
When using the content in the npmpackage in the Cangjie, you need to use the annotations such as
@JsModule ,@JsMember , and @JsRename . For details, see 13.2.2.3~13.2.2.5.
ImportJavaScriptfiles Whenaddingthe JavaScript filedependency,youonlyneedtoaddthedependent
.jsfile path to the rawJsFiles field in module.json . The format is as follows:
"foreignRequires":{
"rawJsFiles": {
"local":[".js file path"]
}
}
The .jsfile path can be a relative path or an absolute path. For example, the directory structure of the
CharStarter project is as follows:
/root/CharStarter
|-- rawjs
| |-- data.js
|-- src
| |-- module.json
The format of the imported data.js file is as follows:
"foreignRequires":{
"rawJsFiles":{
"local"￿"rawjs/data.js"
}
}
The complete module.json example is as follows:
{
"name" :"module name" ,
"description" :"some description" ,
"version" :"module version" ,
"requires" : {
"modules" : [{
"name" :"badboy/foo" ,
"version" :"0.1.0" ,
"repository" :"https://github.com"
}]
},
"foreignRequires" : {
"rawJsFiles" :{
"local" :["rawjs/data.js" ]
}
},
"exports" : ["goo" ,"yoo" ]
}
In the sample code, rawJsFiles under the foreignRequires field specifies the JavaScript file to be imported
through a relative path.
13.2.2.2 foreign modifier
Cangjie uses the foreignmodifier to represent object types, functions, and variables in JavaScript . The
foreign modifier can modify top classes, interfaces, functions, and variables ( varand let). The syntax
offoreigndeclarations in Cangjie is different from that of non-foreign declarations. For details, see the
following sections. The foreign class and interface are completely different from those of Cangjie. The
foreignclass and interface are used only to represent native JavaScript objects and cannot be inherited or
implemented. (The foreignclass and interface object instance have no parent-child relationship with the
Objectclass.)
The foreignmodifier supports two syntaxes: block and single declaration. The definition from left to
right is foreignkeyword, block or single top-level declaration. The syntax of the foreignmodifier is as
follows:
foreignDeclaration
: 'foreign' (foreignBody | foreignMemberDeclaration)
;
foreignBody
: '{' foreignMemberDeclaration* '}'
;
foreignMemberDeclaration
: (classDefinition
| interfaceDefinition
| functionDefinition
| macroExpression
| variableDeclaration)
;
The foreignblock does not introduce new scopes. It is identical to the single foreign. The following is
an example:
@JavaScript
foreign {
let b:Int32
var a:Int32
}
@JavaScript
foreign class Animal {
var name :String
func sayHi ():String
}
The @JavaScript annotation indicates that the foreigndeclaration maps the JavaScript object (different
from other foreign objects). The @JavaScript annotation must be added to all foreigndeclarations that
represent the external JavaScript declaration (under the backend JavaScript target) . The @JavaScript
annotation must follow the foreigndeclaration (other annotations can be separated between the annotation
and foreign declaration), and can be used for a single foreign declaration or the entire foreign block
declaration.
The foreigndeclaration supports only the publicmodifier, or if it does not modified, it is accessible only
within the package.
foreign class and interface Use the foreignmodifier class to represent the external JavaScript class.
The members of the class are foreignby default, and you do not need to add the foreignmodifier.
Example of foreignmodifying class:
@JavaScript
foreign class Animal {
var name :String
func sayHi ():String
}
Compared with common class,foreign class has the following restrictions:
•All member functions cannot have implementations (function bodies).
•Initialization is not required when the member variable is let.
•Cannot be inherited.
•The initconstructor function and init block are not allowed. Instantiation is not allowed. (Actual
objects can only be created and returned from the JavaScript side.)
•Member variables do not allow any modifiers, member functions only allow staticmodifiers.
•Member functions does not support named parameters and parameter default values.
If you do not need to care about the JavaScript object member variables to be represented, use foreign
interface to represent them.
@JavaScript
foreign interface Animal {
func sayHi ():String
}
Compared with common interface ,foreign interface has the following restrictions:
•Only member functions are allowed. Variables are not supported.
•Member functions do not allow any modifiers, and functions must explicitly give return value types.
•Only used to represent external JavaScript objects are not allowed to be implemented.
•Member functions does not support named parameters and parameter default values.
Note that: The foreignclass and interface do not need to specify the npmpackage or .jsfile from.
foreign variables You can use foreign let to indicate the JavaScript variable that does not need to be
changed in Cangjie side. Otherwise, use foreign var to indicate the JavaScript variable. For example:
@JavaScript
foreign {
let b:Int32 =21
var a:Int32
}
a=32
The differences between foreign var/let and common var/letare as follows:
•foreign let does not require initialization before being used.
•Only some variable types are supported. For details about the variable types that can be modified, see
the type mapping tables at the beginning of this section.
foreign function The JavaScript function can be represented by foreign func . An example is as follows:
@JavaScript
foreign {
interface JQuery {...}
func jQuery (selector :String) :JQuery
func jQuery ():JQuery
}
Compared with common functions, the foreignfunction has the following restrictions:
•Implementation (function body) is not allowed.
•Only some types of parameters and return values are supported. For details about the types that can
be modified, see the type mapping tables at the beginning of this section.
•Does not support named parameters and parameter default values.
13.2.2.3 @JsModule
When the JavaScript package directly exports functions or variables, you can use the @JsModule annotation
to represent them. The @JsModule annotation contains a string parameter indicating the name of the package
exported by JavaScript . The following uses the function object exported from JavaScript as an example.
The sample code is as follows:
// Cangjie code
@JavaScript
foreign class Moment {
func fromNow ():String
}
@JavaScript
@JsModule ["moment"]
foreign func moment1 ():Moment
moment1().fromNow()
// JavaScript code
// The preceding code is translated into the following JavaScript code:
// Classes modified by foreign are not translated to JavaScript.
let moment1 =require('moment');
moment1().fromNow()
13.2.2.4 @JsMember
When a function or variable in JavaScript is exported as a package member, the function or variable can be
represented by @JsMember annotation. The @JsMember annotation contains a string parameter indicating the
package name. The following uses a function as an example:
// Cangjie code
@JsMember ["moment"]
foreign func isMoment (arg :String) :Bool
isMoment( "20111122" )
// JavaScript code
// The preceding code is translated into the following JavaScript code:
let isMoment =require('moment').isMoment
isMoment( "20111122" )
13.2.2.5 @JsRename
If the declared function or variable name conflicts with the syntax of Cangjie (for example, characters or
keywords that are not supported by Cangjie) or needs to be renamed (for example, the NameSpace definition
is omitted), you can modify the name by using the @JsRename annotation. The @JsRename annotation contains
a string parameter that indicates the name of the rename. For example, the JavaScript global object JSON
is as follows:
// Cangjie code
// For example, the global variable $val in the JavaScript
// cannot start with $, You can use @JsRename.
@JsRename ["$val"]
foreign var val:Int32
// For example, the JSON.stringify() function does
// not need to define the JSON structure, You can use @JsRename.
@JsRename ("JSON.stringify")
foreign func JSstringify ():String
JSstringify()
// JavaScript code
// The preceding code is translated into the following JavaScript code:
// The modified function declaration will not be translated into JavaScript code.
JSON.stringify()
13.2.2.6 @JsObject
When representing the anonymous object type JavaScript in Cangjie, you can modify classby using @JsOb-
jectannotation. When a class is annotated with this annotation, only one primary constructor is allowed
in the class, and its parameter can only be a member variable parameter, and the function body is empty.
Classes annotated by using @JsObject do not generate any JavaScript code.
A large number of APIsinJavaScript can be used as input parameters through anonymous objects
(Annoymous Object ). The following describes the definition of the JavaScript ￿ajaxfunction:
ajax( *{name :value, name :value, ... } *)
The actual type of the parameter is object in JavaScript. The parameter is described only in the API
document to support fields such as url, contentType, success, and data. However, no more detailed type
mapping is provided. Use this function in JavaScript . The sample code is as follows:
// javascript code
ajax({ url :"/api/xxx" , contentType :"application/json" ...});
To invoke the ajaxmethod in Cangjie, define the class AjaxOption type to indicate the object type to be
transferred and use the construction method to transfer the required content. The sample code is as follows:
// Cangjie code
// The ajax function requires an explicit AjaxOption type.
@JsObject
class AjaxOption {
AjaxOption(
var url!:String ="",
var contentType !:String ="application/json"
){}
}
@JsObject
class AjaxOptionOther {
var url:String // error: Only primary constructor is valid in a '@JsObject' annotated class
AjaxOption(
url:String, // error: Only member variable parameters are valid in the constructor of a
'@JsObject' annotated class ↪
var contentType !:String ="application/json"
){
this .url =url // error: The body of the primary constructor of a class annotated by the
@JsObject needs to be empty ↪
}
}
@JavaScript
@JsMember ["jquery"]
foreign func ajax (ao:AjaxOption) :Unit
main() {
var ajaxOption =AjaxOption( "/api/xxx" ,"application/json" )
ajax(ajaxOption)
}
// javascript code
// The JS file does not contain the definition of the ajaxOption type.
var ajaxOption ={url :"/api/xxx" ,contentType :"application/json" }
let ajax =require( "jquery" ).ajax
ajax(ajaxOption)
The AjaxOption type does not exist on the JavaScript side. The AjaxOption type does not correspond to
any JavaScript code. Use @JsObject to mark this type as a mapped anonymous object type to distinguish
it from a common classtype.
13.2.3 Calling Cangjie from JavaScript
Not support
13.3 Java Interoperability
13.3.1 Interoperation Mode
13.3.1.1 Invoking Java from Cangjie
In the Cangjie programming language , you can directly import the top-level type of the Javapackage by
using the importstatement, contains classes and interfaces (including enum and annotations). Only the Java
types, fields, or methods visible outside the package ( publicorprotected ) can be used in Cangjie.
The following syntax is supported when the Javatype is imported:
•Import all types in the Javapackage through import packageName.* .
•Import a specific type in the Javapackage through import packageName.name .
•Rename the package by import packageName.name as newName to avoid conflicts or simplify writing.
The content of the Java standard library is obtained from the java8module. Import java.lang.Math to
Cangjie. Sample code is as follows:
// Cangjie code
from java8 import java .lang .Math
main (){
Math.sin(Math.PI /2)// invoke static method and access static field
}
The imported Javaclasses and interfaces support the following usages:
•Create class instances, access class fields, and invoke class methods.
•Inherit classes or implement interfaces through <:(The @Javamacro identifier must be added.)
When Cangjie code invokes Javacode￿the Invoked Javacode is executed in a Java thread . There is a
one-to-one correspondence between Cangjie threads and Java threads used for java interoperability. And
the correspondence is not changed during the whole execution period of the Cangjie program. If the current
execution environment cannot perform Javainterop then JavaNotSupportedException will be thrown at the
first attempt to execute Javacode during runtime.
The imported Javaclasses and interfaces must comply with certain mapping rules (such as type and
modifier mapping) and usage restrictions. For details, see the following sections.
13.3.1.2 Invoking Cangjie from Java
In the Javacode, you can invoke the classes in the Cangjie through reflection ( Class.forName orClass-
Loader.loadClass ). Note that the invoked classes must be modified by @Java. (For details about how to use
@Java, see section [@Java classes and interfaces].)
For example, use Class.forName . The definition of the Cangjie class invoked by Javais as follows:
// Cangjie code
package example
@Java
public class CJClass {
public func foo(str :JString) :Unit {
// do something
}
}
Use the Class.forName method in Javato invoke the code as follows:
// Java code
package com.company ;
import java.lang.reflect.InvocationTargetException ;
import java.lang.reflect.Method ;
public class Main {
public static void main (String []args) throws ClassNotFoundException, NoSuchMethodException,
InvocationTargetException, IllegalAccessException, InstantiationException { ↪
Class clz =Class. forName ("example.CJClass" ); // Get the class through forName
Method method =clz. getMethod ("foo" , Object. class ); // Get the method
method. invoke (clz. newInstance (), "this is a string" ); // Create instance and invoke
the method ↪
}
}
Currently, the importstatement cannot be used in Javato import the Cangjie type. In Java, the mapping
rules and restrictions must be followed for invoking the Cangjie code. For details, see the following sections.
13.3.2 Type Mapping
Fields, method parameters, and return values of imported Javaclasses or interfaces must be used in the
Cangjie based on certain type mapping rules. The mapping types are as follows:
•Both Javaand Cangjie have small differences, such as the primitive type byteinJava.
These Javatypes can be used directly by referring to the mapping table.
•Javaand Cangjie have the same types but have significant semantic differences. For example, Java
character strings and arrays are different from those built in Cangjie.
These Javatypes are supported by additional built-in types, such as ffi.java.JString and
ffi.java.JArray .
•Types that exist in Javabut not in the Cangjie, such as varargs, are not supported in the Cangjie.
This part of the Javatype is supported by some built-in special usage, such as mapping varargsto
JArrayarray of the corresponding type.
•Type specific to the Cangjie, such as tuple and struct. These types cannot be used as field types,
method parameter types, and return value types of classes modified by the @Java, but can be used
inside their methods.
For details about the mapping rules and restrictions of each type and the usage of common classes,
interfaces, and generic types in Java, see the following sections.
13.3.2.1 Java Primitive Types and Package Classes
When primitive types on the Javaside are used as class field types, method parameter types, and return value
types, they can be used based on the types in the mapping table. The following table lists the mappings.
Java Cangjie
byte Int8
short Int16
char UInt16
int Int32
long Int64
float Float32
Java Cangjie
double Float64
boolean Bool
The Cangjie value types that are not supported by the Javaside cannot be used as fields or method
parameters or return value type of classes modified by the @Javamacro. The types include UInt8,UInt32,
UInt64, and Float16.
The packaging type corresponding to each basic type in Javais regarded as a common Javaclass in the
Cangjie and does not provide additional mapping, automatic packing, and unpacking operations. When
using Javacode whose input parameter or return value type is packaging in the Cangjie, you need to import
the corresponding wrapper class and manually create an instance to transfer the class.
The sample code is as follows:
// Java code
package com.example ;
public class BoxedExample {
// foo receive the packing type of the basic type.
public void foo(Integer i){
System. out.println (i.toString ());
}
}
Import the BoxedExample and create an instance to invoke the foofunction. The code is as follows:
import com.example .*
from java8 import java .lang .Integer ;
main(){
var instance =BoxedExample()
instance.foo( 1)// compile error
var i=Integer( 1)
instance.foo(i)
}
#### @Java classes and interfaces
The @Javacan be used to modify classand interface . By default, the types modified by @Javaare
subtypes of java.lang.Object . Only types modified by the @Javacan be used on the Javaside. These types
can also be used outside of @Java-modified classes or interfaces.
Note that the @Javamodifier has the following restrictions:
•The field types, member function parameter types, and return value types of the type modified by
@Javacannot contain the type specific to the Cangjie. The specific types include: Array,enum,struct,
Range,String,Nothing, and C. har,UInt8,UInt32,UInt64,Float16,Unitcan be the return value type.
For details, see Java void .
•@Javamodifiers can be inherited and implemented:
–Imported javaclasses and interfaces.
–Other types modified by @Java.
–Interface type of Cangjie.
open class A{}
@Java
class B<:A {} // compile error, A is neither modified by @Java nor an imported java type.
@Javamodified class’s parent class is java.lang.Object if not specified. The instance of the class modified
by@Javacan directly invoke the java.lang.Object member method. The sample code is as follows:
@Java
class Foo{}
main(){
var instance =Foo()
instance.hashCode() // Call java.lang.Object method
}
In Java, class loaders are responsible for dynamically loading Java classes to VMs. By default, @Java-
modified classes are loaded by Java Application Classloader, which is equivalent to modified by @Java["app"] .
If@Java["ext"] is used, the class will be loaded by the custom classloader.
The usages of @Java["ext"] and @Java["app"] are the same. The only difference is that the class modified
by@Java["ext"] can only be referenced by other classes modified by @Java["ext"] , but functions in the
class can reference other Cangjie code. Classes modified by @Java["ext"] and @Java["app"] are accessible by
reflection in Java.
13.3.2.2 Java Object
In Cangjie, Objectis the parent class of java.lang.Object ofJava.
13.3.2.3 Java void
When the Javamethod is invoked, the return value of the voidtype is the Unittype. The value of Unit
is allocated on the invoking side. When a class inherits the imported Javaclass and overrides the method
of the Javaclass (the method returns void), the override method will not create the Unittype when it is
invoked and executed on the Javaside.
Except as a return value, Unitcannot be used in fields and member function parameters of the type
modified by @Java.
Note: The value of Unitis allocated on the calling side means that var a: Unit = JOb-
ject.callJMethod() is equivalent to JObject.callJMethod();var a:Unit = () .
@Java
class UnitExample <:SomeJClass {
overrride func foo():Unit {
// other code
return () // When the foo function is called on the Java side,
} // the Unit will not be created.
}
main(){
var instance =UnitExample()
var a=instance.foo() // Same as instance.foo(); var a￿Unit = ()
}
#### Java String
Cangjie provides the type mapping java.lang.String , which has all methods of java.lang.String and
are of the same type when running. When the attribute, member method input parameter, and return
value type of the imported Javatype are java.lang.String , the attribute and member method are mapped
toffi.java.JString . The value-type Stringtype cannot be used as the member field, member method
parameters, or return value type of the class modified by @Java.
ffi.java.JString literals support only single-line character literals. The literals start with Jand are
defined by double quotation marks ( J"singleLineStringLiteral" ). The content of the double quotation
marks can be any number of characters, the value must be in the same line.
// Cangjie code
from std import ffi.java .JString
@Java
class JStrExample {
var a:String ="Cangjie string" // compiler error
var b:JString =J"JString" // Single line literal
}
main(){
var obj =Foo()
var jstr :JString =J"Java String"
jstr.equal(J "Java String" ) // Call the equal method to determine whether the string content
is equal ↪
}
In addition to all methods of java.lang.String ,ffi.java.JString supports the level determination ( =,
!=) and combination ( +).
Cangjie provides the conversion between the native Stringtype and ffi.java.JString type. The conver-
sion function is as follows:
public func toJString (str :String) :JString
public func toString (jstr :JString) :String
13.3.2.4 Java Array
Cangjie provides the built-in array type of ffi.java.JArray<T> type mapping Java.ffi.java.JArray<T> is a
generic type of Cangjie, the type of the type argument Tmust be a type that supports mapping to Java, the
basic types include: Int8,Int16,UInt16,Int32,Int64,Float32,Float64, and Bool, and @Javamacro Modifier
type, JStringtype, and JArray<T> type. All the preceding types implement the JTypeinterface, and Thas
the constraint where T <: JType . If a custom type that is not in the preceding range is implemented and
used in the JArray interface, undefined behavior is generated. For example, the user-defined struct type.
You can create ffi.java.JArray<T> in either of the following ways:
•Create it by using the extension function ToJArray ofArray<T> .
let a:JArray <Int64 >=[1,2,3,3,2,1].ToJArray()
•Create it through ffi.java.JArray<T>() orffi.java.JArray<T>(arrayExpr: Array<T>) .
let a:JArray <Int64 >=JArray <Int64 >([0,1,2,3,4,5])
For instance arrof the ffi.java.JArray<T> type, the array length is n. You can use the arr[i]method
to access elements at specific locations, in the preceding information, iindicates the Int32 type ranging from
0to the array length n-1.
Note: The type of the index iofJArrayisInt32, which is the same as that of intofJava.
Members of the ffi.java.JArray<T> type are the same as those of the Javabuilt-in array type, including
thelengthattribute, clonemethod, and other methods inherited from java.lang.Object .
InJava,thedirectparenttypeof Integer[] isNumber[] . However,intheCangjie, ffi.java.JArray<Integer>
and ffi.java.JArray<Number> have no parent-child relationship, for details, see section Generic.
13.3.2.5 Java Enum
The enum type of Javais a special class. In the Cangjie, the Javaenum type is directly mapped to the
corresponding subclass of java.lang.Enum . The usage of this class is the same as that of common Javaclasses
and complies with the same mapping rules and restrictions.
The definition of the enum class Dayon the Javaside is as follows:
// Java code
package com.example ;
enum Day {
MONDAY, TUESDAY, WEDNESDAY,
THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
Class mapped by the Dayenum type in the Cagnjie side have the following features:
•By default, this class inherits the abstract class Java.lang.Enum .Eis a generic type argument. For
example, if the enum class Dayis used, Eis theDay‘ class.
•All enum members are of the Daytype and have the publicand staticfields (not open, corresponding
tofinalon the Javaside).
•This class implements two member functions with publicand staticby default, as follows:
–public static func values(): JArray<E>
valuesis used to return all constant values in the enum in array format.
–public static func valueOf(name: JString): E
The main function of valueOfis to return the enum constants of the specified name (the constants
are initialized as MONDAY = new Day("MONDAY", 0) inJava).
Import the Dayenum class to Cangjie and use the following example:
// Cangjie code
import com.example .*
main (){
var day =Day.MONDAY
var values =Day.values()
day =values[ 0] // day's value is Day.MONDAY, values
day =Day.valueOf( "MONDAY" )// day's value is Day.MONDAY
}
13.3.2.6 Java lambda
The type of the lambdaexpression on the Javaside is a specific functional interface type. A functional
interface ( Functional Interfaces ) in Javarefers to an interface that has only one abstract method (except
Object). In Java, you can create instances of functional interfaces by declaring and instantiating classes and
lambdaexpressions.
You can directly import the function interface of the Java side for use, or declare an interface with
only one abstract method and add @Javamacro to use the function interface of the Java side. In Cangjie,
instances of functional interfaces can be created only through class instantiation. The class must be modified
with @Javaand implemented.
In Cangjie, when invoking a method of the java lambda type, you need to transfer the corresponding
function interface instance.
// Java code
package com.example ;
public interface MathOperation {
int operation (int a,int b);
}
public class LambdaExample {
public MathOperation add =(int a,int b)->a+b// The Java side can be created directly
using a lambda expression. ↪
public int foo(int a,int b, MathOperation op){
return op.operation (a, b);
}
}
The following is an example of accessing addand fooin Cangjie:
// Cangjie code
import com.example .*
@Java
class Sub <:MathOperation {
func operation (a:Int32 ,b:Int32 ):Int32 {
return a-b
}
}
main(){
var instance =LambdaExample()
var add =instance.add // Direct access to Java-side functional interface type
properties. ↪
instance.foo( 1,2,add) // Transfer the instance obtained from the Java side.
var sub =Sub() // Create an instance.
instance.foo( 2,1,sub) // Result is 1.
}
Note: The pure lambdatype in the Cangjie is a value type and does not directly map lambdaon
theJavaside.
13.3.2.7 Java varargs
In the Cangjie programming language , the varargs of Javais mapped to the ffi.java.JArray<T> array type
of the Ttype, when this API is invoked, you need to manually create the corresponding ffi.java.JArray<T>
array instance. varargs function cannot be declared in Cangjie.
When calling this , you need to construct a parameter array and transfer it. The code is as follows:
// Java code
package com.example ;
public class JavaVarargsExample {
public void foo(int... ele){
// some code
}
}
In Cangjie, the invoking code is as follows:
// Cangjie code
import com.example .*
from std import ffi.java .*
main (){
var varargsExample =JavaVarargsExample()
var array64 :Array <Int64 >=[0,1,2,3,4,5]
var array32 :Array <Int32 >=[0,1,2,3,4,5]
var argsArray =ffi.java.JArray <Int32 >([0,1,2,3,4,5])
varargsExample.foo(argsArray) // ￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿￿
}
13.3.3 Java modifier
When imported Javaclasses and interfaces and their members are used in the Cangjie, their modifiers are
mapped according to the following rules. For example, the class members modified by protected on the Java
side can be accessed only in their subclasses when being imported into the Cangjie.
Modifier kind Java Cangjie
Top level public public
class/interface member public public
class/interface member protected protected
class abstract abstract (class)
class/interface member static static
class final/(non final) (non open)/open
Variables/field final let
override @Override override
Note: The strictfpmodifier is not supported currently. In Java, the precision of floating-
point results depends on hardware by default. Using strictfpto modify the class interface
method can ensure platform-independent floating-point calculation.
Javacan use transient to declare member fields of a class. These fields will be ignored during persistent
(serialization) operations. A member field cannot be explicitly marked as transient in Cangjie, however, the
field that is inherited from Javaside and with this attribute remains its original feature when it is used in
Cangjie side. For example, when the serialization method in Cangjie side is invoked, the member field is
ignored in the same way as that in Javaside, the syntax of the synchronized and nativemodified methods
inJavaside is retained when they are invoked in Cangjie. However, Cangjie does not support explicit
declaration of a member method as synchronized ornative.
Note that Cangjie does not support the access to the volatile member attribute. An error will be
reported when you access the attribute. To access the attribute, you must encapsulate the corresponding
operation method in the Javaside for Cangjie.
13.3.4 Nullable Type
For types that may be null on the Java side, you can use either of the following methods:
•Directly use it as a non-nullable type in the Cangjie.
When a nullable variable obtained from the Javaside is stored to any non-nullable variable, the Null-
PointerException exception will be thrown at runtime. At runtime, the NullPointerException is also
thrown when a reference variable whose value is null accesses its member directly or invokes its member
method. The nullable variables obtained from the Javaside refer to the imported Javatype member
fields or method input parameters.
•Save it to the variable of the Option type.
The compiler automatically encapsulates it as an Option type, or if it is nullat runtime, it maps to
Nonein the Option type; otherwise, it maps to Some constructor .
// Java code
package com.example ;
import java.lang.Integer ;
public class JavaClass {
public Integer a =null ;
public Integer foo(Integer a) {
Integer b =100 +a;
return b;
}
}
// Cangjie code
import com.example .JavaClass
from java8 import java .lang .Integer
main (){
var obj =JavaClass()
obj.a.toString() // The value of obj.a is null at runtime. The
`NullPointerException` exception will be thrown at runtime. ↪
var a1:Integer =obj.a // The value of obj.a is null at runtime. The null value is
assigned to a non-Option variable. In this case, the `NullPointerException` exception will
be thrown.↪
↪
var a2:?Integer =obj.a // The compiler automatically encapsulates obj.a as an optional
type. The actual value of a2 is Option<Integer>.None. ↪
a2?.toString() // a2 = Option<Integer>.None, the `toString()` method will not be
invoked. ↪
var a3:?Integer =Option <Integer >.None
s.foo(a3.getOrThrow()) // `a3.getOrThrow()` will throw an `NoneValueException` exception.
var ret:?Integer =s.foo(obj.a) // The value of obj.a is null at runtime, `JavaException`
exception will be thrown at runtime. ↪
}
13.3.5 Exception
When the Javacode is invoked on the Cangjieside, all exceptions thrown on the Javaside are mapped to
theCangjieclass JavaException , which can be caught by Cangjie. Similarly, when Cangjiecode is executed
on the Javaside, all exception classes thrown by Cangjieare mapped to Javaclass CangjieException , which
can be caught on the Javaside. The following table lists the mapping relationships￿
Cangjie Type Java Type
Exception or Error and their subclasses CangjieException
JavaException Throwable and its subclasses
Mapped exceptions can be caught using try/catch in both Cangjieand Java. When an exception thrown
byJavacode is caught in Cangjiecode, the getCause method can be used to obtain the actual Javaexception
class thrown. And then the exception class can be determined and processed. Refer to the following code
example:
// Cangjie Code
from java8 import java .lang .Integer
from java8 import java .lang .Throwable
from java8 import java .lang .NumberFormatException
from java8 import java .lang .ArrayIndexOutOfBoundsException
main (){
try {
var s=J"abc"
var n=Integer.parseInt(s) // It will throw exception.
let array =JArray <Int64 >([0,1,2,3,4,5])
var el=array[n]
}catch (e:JavaException) {
var cause :Throwable =e.getCause()
match (cause) {
case _:NumberFormatException =>print( "Wrong parseInt input!" )
case _:ArrayIndexOutOfBoundsException =>print( "Out of Bounds!" )
case _=>()
}
}
}
13.3.6 Generic
You can directly import generic types from the Java side to create instances, invoke methods, inherit (generic
classes), and implement (generic interfaces). The imported Javageneric types and the generic types modified
by@Javaare erased during compilation (consistent with Java).
The sample code for invoking a generic type in Cangjie is as follows:
// Cangjie code
from java8 import java .util .ArrayList asJArrayList
from java8 import java .lang .Integer
main (){
var arrayList =JArrayList <Integer >()
arrayList.add(Integer( 1))
arrayList.add(Integer( 3))
arrayList.add(Integer( 5))
var iter =arrayList.iterator()
while (iter.hasNext()) {
iter.next().toString()
}
}
Most ‘Java’ generics can be directly used in the Cangjie, but must comply with certain mapping rules
and usage restrictions. For details, see the following sections.
13.3.6.1 Java Type Parameter Constraint
InJava, the generic type parameter constraint can only be specified by extends(the lower bound is not
supported). Multipleboundariescanbespecified. The firstboundarymustbea class, and thenextboundary
must be an interface. The syntax of the type parameter constraint is as follows:
TypeParameter extends C1&I1&I2&... &In
TypeParameter extends C1
TypeParameter extends I1
The preceding syntax can be directly mapped to the following syntax:
where TypeParameter <: C1 &I1&I2&... &In
where TypeParameter <: C1
where TypeParameter <: I1
Note that the generic type modified by @Javahas the following features:
•The type is a subclass of java.lang.Object .
•Type parameters implicitly contain constraints where T<: java.lang.Object (except Tin
ffi.java.JArray<T> , where T may be Int64 non-java.lang.Object)
13.3.6.2 Java Type Wildcard
The wildcard in Javais used to represent a series of types. It can be used as a type argument (not for generic
methods). There are three types: unbounded, upper bound, and lower bound wildcard.
InJava, if the type constraint of a non-wildcard character is too strict, the wildcard character can be used
as a type parameter. In the following code, a compilation error occurs when the sortmethod is invoked:
// Java code
class Person implements Comparable <Person >{}
class Student extends Person {}
class Utilities {
public static <Textends Comparable <T>>void sort (List <T>list) {}
}
List <Student >list =new ArrayList <Student >();
Utilities. sort (list); // error
If wildcards are used as formal parameters, sortcan be invoked as follows:
// Java code
class Utilities {
public static <Textends Comparable <?super T>>void sort (List <T>list) {
}
}
In Cangjie, the wildcard type is not supported, but can be mapped according to certain rules. The
following table lists the wildcard types that need to be mapped.
•Imported member fields, method input parameters, and method return values of the Javatype.
•Inherit or rewrite the input parameters and return values of the method of importing the Javatype in
the@Javatype.
The mapping rules are as follows:
Java Cangjie
List<? super T> List<java.lang.Object>
List<? extends T> List<T>
List<?> List<java.lang.Object>
13.3.6.3 Generic Instance Member Function
When inheriting or implementing the imported Javatype, you can use the generic member function override
super class member function in the Cangjie. Note the following:
•The syntax of generic member functions is the same as that of global generic member functions.
•Class or interface where a generic member function resides must be modified with @Java.
•Generic member functions must be modified with override .
Note that the return type must be the same as the return type of the overridden method or a subtype
of the return type.
The sample code is as follows:
// Cangjie code
package example
import java .GenericClassExample // Importing Java Generic Types.
@Java
class B<:GenericClassExample {
override public foo<T>(t:T){// Overrides super class member functions only.
// do something
}
}
main(){
var p=B()
p.foo(p)
}
Subclass members cannot hide super class members in warehouses, while Javaallows them. When the
two Javaclasses that are covered are treated as pure generic type parameters in the Cangjie, the runtime
access to the obscured variable is the same as the behavior on the Javaside. If the generic function of Cangjie
uses the imported or @Javamodifier type, the generic function must also use @Javamodifier.
// Java code
package com.example ;
public class Foo {
public int a;
}
public class Bar extends Foo {
public byte a;
}
To import the Footype in Javaas a pure generic type parameter in Cangjie, use the following method:
// Cangjie code
import com.example .*
@Java
func f<T>(i:T)where T <: Foo {
i.a // The i.a type is Int32 during compilation.
}
main(){
var bar =Bar()
f<Foo>(bar) // The i.a type is also Int32 at runtime.
}
13.3.6.4 Java Raw Type
The raw types in Java are mapped to the generic types of the corresponding java.lang.Object , as shown in
the following table:
Java Generic Type Java Raw Type Cangjie
C1 C1 C1<java.lang.Object>
For details, see the following Java classes:
// Java code
package com.example ;
public class A<T>{}
public class C{
public A a; // A is a raw type
}
In Cangjie, use the following:
// Cangjie code
import com.example .*
from java8 import java .lang .Object asJObject
main (){
var c=C()
var rawType :?A<JObject >=c.a
}
13.3.6.5 Java Annotations
The Javaannotation is a special interface type. In Java, some customized annotations are mapped to macros
and can be imported. The sample code is as follows:
// Java code
package com.example ;
@Target (ElementType. METHOD )
@Retention (RetentionPolicy. RUNTIME )
public @interface foo {
String value ();
}
class f1{}
Import the above annotations for use in Cangjie, the sample code is as follows:
// Cangjie
import com.example .*
// pure cangjie
class f{
@foo [J"value"] // compile error
func a():unit{}
}
@Java
class sub <:f1{ // Annotations can only be used in @Java modifier types.
@foo [J"value"]
func a():unit{}
}
The imported Java annotations have the following restrictions:
•Built-in annotations are not supported.
@Override has been mapped to the keyword override . Other built-in annotations cannot be imported:
@Deprecated ,@SuppressWarnings ,@Retention ,@Documented ,@Target,@Inherited ,@SafeVarargs ,@Func-
tionalInterface ,@Repeatable .
•Imported annotations can only be used in @Javamodifiers.
Imported Javaannotations are not allowed in pure code.
•Annotation of the type “PACKAGE” or “ANNOTATION_TYPE” is not supported.
The @Targetattribute in Javaside supports the following values, which can be used only in the inter-
operation scope:
// Java code
public enum ElementType {
TYPE, /* Class, interface (including annotation type), or enum declaration */
FIELD,
METHOD,
PARAMETER,
CONSTRUCTOR,
LOCAL_VARIABLE,
ANNOTATION_TYPE,
PACKAGE
}Chapter 14
Metaprogramming
Metaprogramming allows code to be represented as operable data objects, which can be added, deleted,
modified, and queried. Therefore, Cangjie programming language provides the tokens type for describing
code, supporting basic operations of converting code into data, concatenating code, and macro for code
transformation during compilation.
14.1 quote expression and T okens type
The code reference uses the quoteexpression to reference specific code, indicating operable data objects. The
syntax of the quote expression is as follows:
quoteExpression
: 'quote' quoteExpr
;
quoteExpr
: '(' quoteParameters ')'
;
quoteParameters
: (quoteToken | quoteInterpolate | macroExpression)+
;
quoteToken
: '.' | ',' | '(' | ')' | '[' | ']' | '{' | '}' | '**' | '*' | '%' | '/' | '+' | '-'
| '|>' | '~>'
| '++' | '--' | '&&' | '||' | '!' | '&' | '|' | '^' | '<<' | '>>' | ':' | ';'
| '=' | '+=' | '-=' | '*=' | '**=' | '/=' | '%='
| '&&=' | '||=' | '&=' | '|=' | '^=' | '<<=' | '>>='
| '->' | '=>' | '...' | '..=' | '..' | '#' | '@' | '?' | '<:' | '<' | '>' | '<=' | '>='
| '!=' | '==' | '_' | '\\' | '`' | '$'
| 'Int8' | 'Int16' | 'Int32' | 'Int64' | 'UInt8' | 'UInt16' | 'UInt32' | 'UInt64' | 'Float16'
| 'Float32' | 'Float64' | 'Rune' | 'Bool' | 'Unit' | 'Nothing' | 'struct' | 'enum' | 'This'
| 'package' | 'import' | 'class' | 'interface' |'func' | 'let' | 'var' | 'type'
| 'init' | 'this' | 'super' | 'if' | 'else' | 'case' | 'try' | 'catch' | 'finally'
| 'for' | 'do' | 'while' | 'throw' | 'return' | 'continue' | 'break' | 'as' | 'in' | '!in'
| 'match' | 'from' | 'where' | 'extend' | 'spawn' | 'synchronized' | 'macro' | 'quote' |
'true' | 'false' ↪
| 'sealed' | 'static' | 'public' | 'private' | 'protected'
| 'override' | 'abstract' | 'open' | 'operator' | 'foreign'
| Identifier | DollarIdentifier
| literalConstant
;
quoteInterpolate
: '$' '(' expression ')'
;
The syntax rules of quote expressions are summarized as follows:
•Use keyword quoteto define the quoteexpression.
•The quoteexpressionisenclosedby (). Theinternalreferencecanbe code(token)orcode interpolation.
Macro invocations are considered to be code and are not treated specially.
•The quoteexpression is of the Tokenstype. Tokens is a type provided by the Cangjie standard library
and is a sequence consisting of lexical units (token).
In the preceding syntax definition, quoteToken indicates any valid tokensupported by the compiler, except
tokens that are not parsed by Lexer, such as comments and terminators. When a newline character is used
as the separator of two expressions, it is not ignored and parsed as a quoteToken . In the following example,
only the newline character between two assignment expressions is parsed to quoteToken , and other newline
characters in the quoteexpression are ignored.
// The newline character between assignment expression is preserved, others are ignored.
quote (
var a = 3
var b = 4
)
Consecutive quotewithout code interpolation is not allowed. For details about code interpolation, see
the next section. When the quoteexpression references the following token, escape is required:
•The quoteexpression does not support unmatched parentheses. However, the parentheses are escaped
through \and are not counted in the matching rule.
•If@indicates a common tokeninstead of a macro invocation expression, use \to escape.
•If$indicates a common tokeninstead of code interpolation, use \to escape.
Note: The token mentioned in this chapter refers to the lexical unit parsed by Cangjie lexer.
The following are some examples of quoteexpressions that use Tokensor code interpolation as parameters:
let a0:Tokens =quote (==) // ok
let a1:Tokens =quote (2+3) // ok
let a2:Tokens =quote (2) +quote (+) +quote (3) // ok
let a3:Tokens =quote (main(): Int64 {
0
})// ok
let a4:Tokens =quote (select * from Users where id=100086) // ok
let b0:Tokens =quote (() // error: unmatched `(`
let b1:Tokens =quote (quote(x)) // ok -- `b1.size() == 4`
The quoted expression can contain a macro invocation expression. For example:
quote (@SayHi ("say hi")) // a quoted, un-expanded macro -- macro expansion happens later
The Cangjie programming language provides the Tokenstype to indicate the token result obtained after
lexically analyzing the source text. The operator +combines (non-destructively) two token sequences into a
single one. In the following example, a1and a2are equivalent.
let a1:Tokens =quote (2+3) // ok
let a2:Tokens =quote (2) +quote (+) +quote (3) // ok
14.1.1 Code interpolation
In the quoteexpression, use $as the code interpolation operator. The operator is followed by an expression,
indicating that the value of the expression is converted to tokens. This operator is parsed as a unary prefix
operator and may be used only in quoteexpressions. It has a higher precedence than all other operators.
var rightOp :Tokens =quote (3)
quote (2 + $rightOp ) // quote(2 + 3)
Expression types meant to be interpolated must implement the ToTokens interface. The format of the
ToTokens interface is as follows:
interface ToTokens {
func toTokens ():Tokens
}
•Most of the value types in the standard library are implemented by default, including numeric, Rune,
Bool,String, and Tuple.
•The Tokenstype implements ToTokens interface by default, toTokens returns the Tokensvalue itself.
•User-defined data structures must proactively implement the ToTokens interface. The standard library
provides various APIs for generating Tokens. For example, for a variable strof the Stringtype, you
can directly use str.toTokens() to obtain Tokenscorresponding to str.
14.1.2 Rules for Evaluating the Quote Expression
The quoteexpression summarizes the reference rules in parentheses as follows:
•Code interpolation: The result of the expression .toTokens() is obtained.
•Common tokens: Obtain the corresponding Tokensresult.
The quoteexpression is combined into a larger Tokensbased on the sequence in which the expression
appears.
The following are some examples of using quote expressions, The comment indicates the Tokensresult
returned by the program.
var x:Int64 =2+3
// tokens in the quote are obtained from the corresponding Tokens.
quote (x + 2) // quote(x + 2)
// The Tokens type can only add with Tokens type.
quote (x) +1 // error! quote(x) is Tokens type￿can't add with integer
// The value of code interpolation in quote equals to the tokens result corresponding to the
value of the interpolation expression. ↪
quote ($x) // quote(5)
quote ($x+ 2) // quote(5 + 2)
quote ($x+ (2 + 3)) // quote(5 + (2 + 3))
quote (1 + ( $x+ 1) * 2) // quote(1 + (5 + 1) * 2)
quote (1 + $(x+1)* 2) // quote(1 + 6 * 2)
var t:Tokens =quote (x) // quote(x)
// without interpolation, the `t` is the token `t`
quote (t) // quote(t)
// with interpolation, `t` is evaluated and expected to implement ToTokens
quote ($t) // quote(x)
quote ($t+1) // quote(x+1)
// quote expressions can be used inside of interpolations, and cancel out
quote ($(quote (t))) // quote(t)
quote ($(quote ($t))) // quote(x)
quote ($(t+1)) // error! t is Tokens type￿can't add with integer
public macro PlusOne (input :Tokens) :Tokens {
quote (($input + 1))
}
// Macro invocations are preserved, unexpanded, until they are re-inserted into the code by
// the macro expander. However, interpolation still happens, including among the arguments
// to the macro
quote (@PlusOne (x)) // quote(@PlusOne(x))
quote (@PlusOne ($x)) // quote(@PlusOne(2 + 3))
quote (@PlusOne (2+3)) // quote(@PlusOne(2+3))
quote (1 + @PlusOne (x) * 2) // quote(1 + @PlusOne(x) * 2)
// When the macro invocation is outside the quote, the macro expansion happens early
var y:Int64 =@PlusOne (x) // 6 + 1
quote (1 + $y* 2 ) // quote(1 + 7 * 2)
14.2 Macros
Macros are an important technology to realize metaprogramming. Macros and functions are similar in that
they can be called/invoked, and have input and output. The difference is that macro code is expanded during
compilation. Cangjie is responsible for replacing the macro invocation with the target code. You can write
code templates (that is, code that generates code) using macros. In addition, macros provide the ability to
customize the grammar. Users can flexibly define DSL syntax using macros. Finally, Cangjie provides rich
code operation interfaces for users to conveniently transform code.
Macros are classified into non-attribute macros and attributed macros. Compared with non-attribute
macros, attribute macros can analyze and transform the input of macros based on different attributes to
obtain different output results.
14.2.1 Macro Definition
In Cangjie programming language, macro definitions comply with the following syntax rules:
macroDefinition
: 'public' 'macro' identifier
(macroWithoutAttrParam | macroWithAttrParam)
(':' identifier)?
('=' expression | block)
;
macroWithoutAttrParam
: '(' macroInputDecl ')'
;
macroWithAttrParam
: '(' macroAttrDecl ',' macroInputDecl ')'
;
macroInputDecl
: identifier ':' identifier
;
macroAttrDecl
: identifier ':' identifier
;
The summary is as follows:
•Define a macro by using the keyword macro.
•publicmust be added before macro, indicating that the package is visible to the outside.
•macromust be followed by the macro name.
•Parameters of a macro are enclosed by (). For macros without attributes, one token parameter cor-
responds to the macro input. For macros with attributes, two token types correspond to the macro
attributes and input.
•The default return type is Tokens.
•Macro definition cannot have an implicit default. They can be defined with =and expression , similar
to the standard library function body.
The following is an example of a macro without attributes. It contains all the elements of the macro
definition. publicindicates that the macro definition is visible to the outside of the package. macrokeyword;
foois the identifier of the macro. Formal parameter xand its type Tokens; The return value is the same as
the input value and type.
public macro foo(x:Tokens) :Tokens {x}
public macro bar(x:Tokens) :Tokens {
return quote ($x) // or just `return x`
}
The following is an example of a macro with attributes. Compared with non-attribute macros, the macro
definition has an additional input of the Tokens type. Therefore, operations can be performed more flexibly.
public macro foo(attr :Tokens, x:Tokens) :Tokens {attr +x}
public macro bar(attr :Tokens, x:Tokens) :Tokens {
return quote ($attr +$x)
}
Once a macro is defined, the macro name cannot be assigned any value. In addition, macros have strict
requirements on the type and number of parameters.
14.2.2 Macro Invocation
Macro invocation expressions comply with the following syntax rules:
macroExpression
: '@' identifier macroAttrExpr?
(macroInputExprWithoutParens | macroInputExprWithParens)
;
macroAttrExpr
: '[' quoteToken* ']'
;
macroInputExprWithoutParens
: functionDefinition
| operatorFunctionDefinition
| staticInit
| structDefinition
| structPrimaryInit
| structInit
| enumDefinition
| caseBody
| classDefinition
| classPrimaryInit
| classInit
| interfaceDefinition
| variableDeclaration
| propertyDefinition
| extendDefinition
| macroExpression
;
macroInputExprWithParens
: '(' macroTokens ')'
;
macroTokens
: (quoteToken | macroExpression)*
;
The macro invocation expression rules are summarized as follows:
•Use the keyword @to define the macro invocation expression.
•Macro invocations are enclosed in (). The parentheses can contain any valid tokens, but cannot be
empty.
•When a macro with attributes is invoked, the macro attributes are enclosed in []. The value can be
any valid tokens, but cannot be empty.
When the macro invocation expression references the following token, escape is required:
•Unmatched parentheses are not allowed in macro invocation expression parameters, for example,
@ABC(we have two ((and one)) . The parentheses can be escaped using \and are not counted in
the matching rule.
•Unmatched brackets are not allowed in the brackets with attribute macros., for example, @ABC[we have
two [[and one]]() . The square brackets can be escaped using \and are not counted in the matching
rule.
•If@is referenced in the macro invocation expression parameter, the \must be escaped.
The parentheses can be omitted when a macro invocation is used before some declarations or expressions.
The semantics of the macro invocation are different from those of a macro invocation without parentheses.
For macro invocations with parentheses, the parameter can be any valid ‘tokens’. For macro invocations
without parentheses, the parameter must be one of the following declarations or expressions:
•Function declaration
•Struct declaration
•Enum definition
•Enum constructor
•Class declaration
•Static initializer
•primary initfunctions and initfunctions in structs and classes
•Interface declaration
•Property definition
•Extend definition
•Variable declaration (except function parameters)
•Macro invocation expression
In addition, for macro invocations without parentheses, its arguments must also meet the following
requirements:
•If the parameter is a declaration, the macro invocation can only appear where a declaration is allowed.
The following is an example of a macro invocation without an attribute, one with an attribute, and one
without parentheses.
func foo()
{
print( "In foo \n")
}
// Non-attribute macros
public macro Twice (input :Tokens) :Tokens
{
print( "Compiling the macro `Twice` ... \n")
quote ($input ;$input )
}
@Twice (foo()) // After Macro expand: foo(); foo()
@Twice () // error, parameters in macro invocation can not be empty.
// Attributed macros
public macro Joint (attr :Tokens, input :Tokens) :Tokens
{
print( "Compiling the macro `Joint` ... \n")
quote ($attr ;$input )
}
@Joint [foo()](foo()) // After Macro expand: foo(); foo()
@Joint [foo()]() // error, parameters in macro invocation can not be empty.
@Joint [](foo()) // error, attribute in macro invocation can not be empty.
// Non-attribute macros
public macro MacroWithoutParens (input :Tokens) :Tokens
{
print( "Compiling the macro `MacroWithoutParens` ... \n")
quote (func foo() { $input })
}
@MacroWithoutParens
var a:Int64 =0// After Macro expand: func foo() { var a: Int64 = 0 }
public macro echo (input :Tokens) {
return input
}
@echo class A{} // ok, class can only be defined in top-level, so is current macro invocation
func goo(){
@echo func tmp(){}// ok, function can be defined in another function body,
// so is current macro invocation
@echo class B{} // error, class can only be defined in top-level, so is current macro
invocation ↪
}
As an expression, a macro invocation can appear anywhere the expression is allowed to appear. In
addition, macro invoking can appear in the following statements: function declaration, struct declaration,
enum declaration, class declaration, interface declaration, variable declaration (except function parameter
declaration), attribute declaration, and extension declaration.
Macros are visible only during compilation. The macro invocation expression is replaced by the code after
the macro is expanded during compilation. Macro expansion indicates that the macro definition is executed
during code compilation. The execution result is parsed into a syntax tree to replace the macro invocation
expression. After semantic analysis, the replaced node has corresponding type information. The type can
be considered as the type of the macro invocation expression. In the preceding example, when users invoke
macros such as @Twice,@Joint, and @MacroWithoutParens , the code in the macro definition is compiled and
executed, and the word Compiling the macro... is printed, the execution result is used as a new syntax tree
node to replace the original macro invocation expression.
When macro invocation appear in different contexts, the following rules must be met:
1.If the macro invocation appears in the context of the expected expression or declaration, the macro
invocation is expanded into program text at compile time.
2.If the macro invocation appears in the context of the expected token sequence (As the parameters of
macro invocation expression), the macro is called at the moment when the token sequence is evaluated.
In addition, the return value (the token sequence) of the macro invocation is directly used instead of
being expanded into program text.
3.Macro invocations in quoted code returned from a macro are invoced as soon as they are incorporated
back into the source code. For example, a macro can act in a recursive manner, by emitting a macro
invocation to itself.
14.2.3 Macro Scope and Import
The macro must be defined at the top-level of a source file and its scope is the entire package.
Packages with macro declarations, must be modified with macro, in another word, we use macro package
to define a package with macro declarations. Declarations in macro package cannot be external, except macro
declarations.
//define.cj
macro package define // modify package with macro
import ast.*
// public func A(){} // error: func A can not be modified by `public`
public macro M(input :Tokens) :Tokens{ // only macros can be modified by `public`
return input
}
// call.cj
package call
import define .*
func main (){
@M()
return 0
}
The rule of importing macro packages is the same as importing common packages.
Specially, only macro packages can be public import in macro packages, macro packages can only be
public import in macro packages.
// A.cj
macro package A
public macro M1(input :Tokens) :Tokens{
return input
}
  
// B.cj
package B
//public import A.* // error: macro packages can only be `public import` in macro packages
public func F1(input :Int64 ):Int64 {
return input
}
// C.cj
macro package
public import A.*// only macro packages can be public import in macro packages
// public import B.* // error: normal packages can not be public import in macro packages
import B.*
public macro M2(input :Tokens) :Tokens{
return @M1(input) +quote ($(F1(1)))
}
In the same package, the conventions for macros with the same name are the same as those for functions.
The following table lists the rules for attribute macros and non-attribute macros.
Same name, Same package attribute macros non-attribute macros
attribute macros NO YES
non-attribute macros YES NO
14.2.4 Nested macros and Recursive macros
Macro definitions can have nested calls to other macros.
If the macro invocation expression contains macro invocation, for example, @Outer @Inner(22+3) , the
inner macro is executed first, and then the outer macro is executed. The Tokensresult returned by the inner
macro is combined with other Tokensand sent to the outer macro for invoking. The inner and outer macros
can be different macros or the same macro.
For situations where it’s important that an inner macro call finds itself nested inside a particular outer
macro call, the inner macro can call the library function assertParentContext , which will throw an error
unless the inner macro call is nested in the given outer macro call. A second function insideParentContext
returns true only if the inner macro call is nested in the given outer macro call.
public macro Inner (input :Tokens) :Tokens {
assertParentContext( "Outer" )
// ...or...
if(insideParentContext( "Outer" )){
// ...
}
}
An inner macro can also communicate with an outer macro by sending key/value pairs. When the
inner macro executes, it calls the library function setItem; later, when the outer macro executes, it calls
getChildMessages , getting one message (a map of key/value pairs) for each inner macro invocation that sent
messages.
public macro Inner (input :Tokens) :Tokens {
assertParentContext( "Outer" )
setItem( "key1" ,"value1" )
setItem( "key2" ,"value2" )
// ...
}
public macro Outer (input :Tokens) :Tokens {
let messages =getChildMessages( "Inner" )
for (minmessages) {
let value1 =m.getString( "key1" )
let value2 =m.getString( "key2" )
// ...
}
}
Whenamacrodefinitionbodycontainsamacroinvocation, ifthemacroinvocationappearsinthecontext
of the returned token sequence, the two macros can be different macros or the same macro (i.e. recursion is
supported). A macro definition cannot invoke itself as a macro, directly or indirectly. For details, see the
following two examples.
In the following example, if the macro invoked by nesting is displayed in the quoteexpression, recursive
invocation is supported.
public macro A(input :Tokens) :Tokens {
print( "Compiling the macro A ... \n")
let tmp =A_part_0(input)
ifcond {
return quote ($tmp )
}
let bb:Tokens =quote (@A(quote( $tmp ))) // ok
A_part_1()
}
main() :Int64 {
var res:Int64 =@A(2+3) // ok, @A will be treated as Int64 after macro expand
return res
}
In this example, when macro A is not invoked externally, macro A is not executed (even if it is invoked
internally), that is, Compiling the macro A... is not printed. if condis a recursive termination condition.
Note: Macro recursion and function recursion have similar need for a termination condition/base case.
Otherwise, an infinite loop will occur and the compilation will not complete.
In the following example, recursive invocation is not supported if the nested macro is not in the quote
expression.
public macro A(input :Tokens) :Tokens {
let tmp =A_part_0(input)
ifcond {
return quote ($tmp )
}
let bb:Tokens =@A(quote( $tmp )) // error, recursive macro expression not in quote
A_part_1()
}
main() :Int64 {
var res:Int64 =@A(2+3) // error, type mismatch
return res
}
The macro nesting and recursive invocation rules are summarized as follows:
•Macro invocation expressions can contain macro invocations.
•Macro definitions can use macro invocations; recursion (direct or indirect) is allowed without restric-
tion inside of quoteexpressions, but is disallowed outside of quoteexpressions, directly in the macro
definition body.
14.2.5 Restrictions
•Macros conditionally support recursive calls to themselves. For details, see the preceding section.
•Except macro recursive invocations, macro definitions and macro invocations must be located in dif-
ferent packages . The macro invocation must be in the packagewhere the importmacro definition is
located to ensure that the macro definition is compiled before the macro invocation point. Cyclic de-
pendency import of macros is not supported. For example, the following usage is invalid: pkgAimports
pkgB,pkgBimports pkgA, and cyclic dependency exists.
// ======= file A.cj
macro package pkgA
import pkgB .*
public macro A(..) {
@B(..) // error
}
// ======= file B.cj
macro package pkgB
import pkgA .*
public macro B(..) {
@A(..) // error
}
•Macros allow nested calls to other macros. The invoked macro also requires that the definition point
and call point be located in different packages.Chapter 15
Concurrency
15.1 thread
•Each threadmay be preempted by another threadat any time during its execution.
•Multiple threads execute concurrently.
•threadwill be suspended when it is blocked
•threads can communicate with each other via shared memory (where explicit synchronizations are
required) or message passing (libraries that enforce message passing would be considered in future).
Basic functionalities are listed as following:
1.Keyword spawncan be used to create a new thread.
2.Function func sleep(duration: Int64) makes the current ‘thread’ sleep for a specified duration.
The program execution starts with initializing global variables, and it then invokes the entry point main.
When mainexits, the execution exits as well, and it does not wait for other threads to complete.
### Create thread
Athreadcan be created and launched by the keyword spawnfollowed by an optional type ThreadContext
argument (see below for a description of ThreadContext ) and a lambdawithout formal parameters. The spawn
expression returns an instance of type Future<T> (see 15.1.2 below for a description of Future<T> ).
The syntax of the spawnexpression is as follows.
spawnExpression
:'spawn' lambdaExpression
;
Where the optional argument of the spawnexpression is type ThreadContext .
The following is an example of the spawnexpression without passing ThreadContext argument.
func add(a:Int32 ,b:Int32 ):Int32 {
println( "This is a new thread" )
return a+b
}
main() :Int64 {
println( "This is main" )
// Create a thread.
let fut:Future <Int32 >=spawn {
add( 1,2)
}
println( "main waiting..." )
// Waiting for the results of thread execution.
try {
// Print the result.
let res:Int32 =fut.get()
}catch (_)
print( "oops \n")
}
}
// OUTPUT maybe:
// This is main
// main waiting...
// This is a new thread
// 1 + 2 = 3
In the process of executing the spawnexpression, the closure will be encapsulated into a runtime task and
submitted to the scheduler. The scheduler’s strategy determines when to execute the task. Once the spawn
expression is executed, the corresponding threadis ready to execute.
Note: The closure in the spawnexpression cannot capture local variables declared by var. For details
about closures, see Closures.
let a:Int32 =100
main() :Int64 {
let fut:Future <Unit >=spawn {
print( "a = ${a}")// Print a = 100.
}
fut.get()
return 0
}
15.1.1 Future<T> Generic Class
The value of a spawnexpression is a Future<T> object, which can be used to get the computation result of
the created thread. The type Tdepends on the return type of the closure in the spawnexpression.
func foo():Int64 {...}
func bar():String {...}
// The return type of foo() is Int64.
let f1:Future <Int64 >=spawn {
foo()
}
// The return type of bar() is String.
let f2:Future <String >=spawn {
bar()
}
// Waiting for the threads' execution results.
let r1:Int64 =f1.get()
let r2:String =f2.get()
AFuture<T> object represents an incomplete computation or task. Future<T> is a generic class that is
defined as follows:
class Future <T>{
... ...
// Blocking the current thread, waiting for the result of the thread
// corresponding to this Future<T> object.
// If an exception occurs in the corresponding thread, the method will throw the exception.
func get():T
// Same as above, but with an extra timeout.
// If the corresponding thread has not completed execution within
// `ns` toNanoseconds, the method will return Option<T>.None.
// If an exception occurs in the corresponding thread, the method will throw the exception.
func get(ns:Int64 ):Option <T>
// Non-blocking method that immediately returns None if thread has not finished execution.
// Returns the computed result otherwise.
// If an exception occurs in the corresponding thread, the method will throw the exception.
func tryGet ():Option <T>
}
If the threadcorresponding to the Future<T> object terminates due to an exception, an exception will be
thrown when calling get(). E.g.
main() {
let fut:Future <Int64 >=spawn {
throw TestException()
return 100
}
try {
let res:Int64 =fut.get()
print( "val = ${res}\n")
}catch (e:TestExcetpion) {
print( "Exception occured \n")
}
}
// OUTPUT:
// Exception occured: TestException
15.1.2 thread sleep
The sleepfunction that makes a threadsleep for a duration is defined as:
func sleep (duration :Int64 ) // Sleep for at least `duration` toNanoseconds.
The sleep()function can let the current threadyield, sleep for a period of time, and resume its execution
later.
Ifduration <= 0 , the current ‘thread’ will yield execution resources but not sleep.
15.1.3 thread terminate
If the closure corresponding to threadcompletes, the threadis terminated automatically.
15.2 thread context
Each threadalways runs in a thread context, which could affect the behavior of the thread at runtime.
When users create a thread, in addition to the default spawnexpression, they can also choose different thread
contexts by passing various instances of type ThreadContext , to determine concurrent behaviors of the thread.
### Interface ThreadContext Interface ThreadContext is defined as following: - The termination method end
is used to send a shutdown request to the thread context (see below for a description of ThreadContext
termination). - The check method hasEnded is used to check whether the current context has ended.
interface ThreadContext {
func end():Unit
func hasEnded ():Bool
}
Currently, users are not allowed to implement the ThreadContext interface by themselves. The Cangjie
Language provides the following thread context types according to usage scenarios: - MainThreadContext :
Users can use this thread context for UI application development from the UI framework library; - Python-
ThreadContext : Users can find and use this thread context from the Python interop standard library; -
JSThreadContext : Users can find and use this thread context from the JS interop library; Specific interface
definitions above can be found in the corresponding libraries. ### thread context termination The method
end()ofThreadContext could send a shutdown request to the thread context, which is asynchronous, return
immediately, when the thread context needs to be terminated. It will send termination requests (see thread
termination) to all threadsbinding to the context, and then terminate the context until all threadsbinding
to the context finish. It will not affect the execution of perious threadsrunning on the context when shut-
down requests is submitted. Programmers themselves are responsible for handling termination requests, that
is, deciding if and how to terminate the thread, depending on the check function hasPendingCancellation() .
The following example illustrates how to shutdown an endable thread context.
main() :Unit {
// Create an instance of `PythonThreadContext` which suppose to be an endable thread context.
let context =PythonThreadContext()
let future =spawn (context) {// Create a new thread
while (true ){
//...
if(hasPendingCancellation()) {
return // Terminate when having a request
}
//...
}
}
// Shutdown the context with the method `end()`
context.end()
// Current state of the context is `Ended`
let state =if(context.hasEnded()) {"Ended" }else {"Open" }
println( "The context state is ${state }")
try {
spawn (context) {... }// Throw an Exception
}catch (e:Exception) {
println( "Exception: could not create a thread to a closed context" )
}
}
15.2.1 Thread-local variables
Class ThreadLocal can be used to define thread-local variables. Compared to ordinary variables, thread-local
variables have a different accessing semantics. If there are multiple threads sharing a thread-local variable,
each thread has its own value copy of the variable. Threads will read/write its local value when accessing the
variable, and modifications from one thread will not be visible to others. Thus, ThreadLocal<T> is thread-safe.
Class ThreadLocal<T> is defined as following.
•Constructor method initis used to define thread-local variables. If a variable is defined but not
assigned with any value, Nonevalue will be obtained when a thread accesses it.
•Accessing methods get/set can read/write the value of a thread-local variable. If a thread sets a
thread-local variable’s value as None, the original value of the thread will be cleaned up.
class ThreadLocal <T>{
/**
* Construct a thread-local variable contains None.
*/
public init ()
/**
* Get the value of the thread-local variable of the current executing thread.
*/
public func get():?T
/**
* Set a value to the thread-local variable.
*/
public func set(value :?T):Unit
}
The following example illustrates how to use thread-local variables.
let tlv =ThreadLocal <Int64 >()// Define a thread-local variable
main() :Unit {
for (iin0..3){// Spawn three threads
spawn {
tlv.set(i) // Each thread sets a different value
// ...
println( "${tlv.get() }")// Each thread prints its own value
}
}
// ...
println( "${tlv.get() }")// Print `None`
// since the current thread does not set any value.
}
15.3 Synchronization mechanism
15.3.1 Atomic operation
atomic operations ensure that instructions are executed in an atomic (non-divisible) manner, i.e., there are
no interruptions during the execution. Furthermore, a write operation on an atomic variable is always visible
to its subsequent read operations on the same atomic variable.
Atomic operations are non-blocking and will not block threads.
We provide atomic operations for integer types (Int8,Int16,Int32,Int64,UInt8,UInt16,UInt32,UInt64),
boolean type (Bool), and reference type .
•For integer types, we provide basic read, write, exchange, and arithmetic operations:
–load: read
–store: write
–swap: exchange
–compareAndSwap : compare and exchange
–fetchAdd : add to
–fetchSub : subtract from
–fetchAnd : apply bitwise AND
–fetchOr: apply bitwise OR
–fetchXor : apply bitwise XOR
// Signed Integers.
class AtomicInt8 {
... ...
init (val :Int8 )
public func load ():Int8
public func store (val :Int8 ):Unit
public func swap (val :Int8 ):Int8
public func compareAndSwap (old :Int8 ,new:Int8 ):Bool
public func fetchAdd (val :Int8 ):Int8
public func fetchSub (val :Int8 ):Int8
public func fetchAnd (val :Int8 ):Int8
public func fetchOr (val :Int8 ):Int8
public func fetchXor (val :Int8 ):Int8
... ... // Operator overloading, etc.
}
class AtomicInt16 {...}
class AtomicInt32 {...}
class AtomicInt64 {...}
// Unsigned Integers.
class AtomicUInt8 {...}
class AtomicUInt16 {...}
class AtomicUInt32 {...}
class AtomicUInt64 {...}
•For a boolean type, only basic read, write and exchange operations are provided, and there are no
arithmetic operations provided:
–load: read
–store: write
–swap: exchange
–compareAndSwap : compare and exchange
// Boolean.
class AtomicBool {
... ...
init (val :Bool )
public func load ():Bool
public func store (val :Bool ):Unit
public func swap (val :Bool ):Bool
public func compareAndSwap (old :Bool ,new:Bool ):Bool
... ... // Operator overloading, etc.
}
•For a reference type, only basic read, write and exchange operations are provided, no arithmetic
operations are provided:
–load: read
–store: write
–swap: exchange
–compareAndSwap : compare and exchange
class AtomicReference <T>where T <: Object {
... ...
init (val :T)
public func load ():T
public func store (val :T):Unit
public func swap (val :T):T
public func compareAndSwap (old :T,new:T):Bool
}
•Besides, AtomicOptionReference can be used to store “NULL” references, which are represented as None
values.
class AtomicOptionReference <T>where T <: Object {
public init (val :Option(T))
public func load ():Option <T>
public func store (val :Option <T>):Unit
public func swap (val :Option <T>):Option <T>
public func compareAndSwap (old :Option <T>,new:Option <T>):Bool
}
All above methods have a hidden parameter memory order . Currently, only sequential consistency
is supported. Relaxed memory models with acquire/release semantics will be considered in the
future.
15.3.2 IllegalSynchronizationStateException
IllegalSynchronizationStateException is a runtime exception that is used by all built-in concurrency prim-
itives to report violations of any invariants, e.g. when threadtries to unlock mutex that was not previously
acquired by this particular thread.
15.3.3 IReentrantMutex
IReentrantMutex is a common interface for reentrant mutual exclusion concurrency primitives, provides the
following methods that needs developers to implement: - lock(): Unit : acquire the lock, blocks the current
thread if the mutex is not available. - tryLock(): Bool : try to acquire the lock - unlock(): Unit : release the
lock
interface IReentrantMutex {
// Locks the mutex, blocks the current thread if the mutex is not available.
public func lock ():Unit
// Tries to lock the mutex, returns false if the mutex is not available, otherwise locks the
mutex and returns true. ↪
public func tryLock ():Bool
// Unlocks the mutex. If the mutex was locked repeatedly N times, this method should be
invoked N times to ↪
// fully unlock the mutex. When the mutex is fully unlocked, unblocks one of the threads
waiting on its `lock` ↪
// (no particular admission policy implied).
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
public func unlock ():Unit
}
Note:
1.It is a responsibility of the implementor to guarantee that the underlying mutex actually supports
nested locking.
2.It is a responsibility of the implementor to throw IllegalSynchronizationStateException if the contract
is violated.
15.3.4 ReentrantMutex
AReentrantMutex provides the following methods:
•lock(): Unit : acquire the lock, blocks the current thread if the mutex is not available.
•tryLock(): Bool : try to acquire the lock
•unlock(): Unit : release the lock
ReentrantMutex is a built-in lock that can be held by at most one threadat any one time. If the given
ReentrantMutex is already held by another thread, the lockmethod will block the current thread until
the mutex is released, whereas the tryLock method will immediately return false.ReentrantMutex is a
reentrant lock, i.e., if a thread tries to acquire a ReentrantMutex lock that it already holds, it will acquire
theReentrantMutex lock immediately. In order to successfully release the lock, the number of calls to unlock
must match the number of calls to lock.
Note: ReentrantMutex is a built-in lock that does not allow developers to inherit.
// Base class for built-in reentrant mutual exclusion concurrency primitives.
open class ReentrantMutex <:IReentrantMutex {
// Constructor.
init ()
// Locks the mutex, blocks current thread if the mutex is not available.
public func lock ():Unit
// Tries to lock the mutex, returns false if the mutex is not available, otherwise locks the
mutex and returns true. ↪
public func tryLock ():Bool
// Unlocks the mutex. If the mutex was locked repeatedly N times, this method should be
invoked N times to ↪
// fully unlock the mutex. Once the mutex is fully unlocked, unblocks one of the threads
waiting in its `lock` method, if any ↪
// (no particular admission policy implied).
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
public func unlock ():Unit
}
15.3.5 synchronized
The synchronized keyword and a ReentrantMutex object can be used to protect a code block that follows, so
that only one thread is allowed to execute the code in that block at a time. An instance of ReentrantMutex
itself or a derived class may be passed as an argument to the synchronized keyword, which will result in the
following transformation:
let m:ReentrantMutex =...
synchronized (m) {
foo()
}
let m:ReentrantMutex =...
m.lock()
try {
foo()
}finally {
m.unlock()
}
Note:The synchronized keyword is not compatible with IReentrantMutex interface.
•The thread automatically tries to acquire the lock of the mutex mbefore entering a synchronized(m)
code block, if acquisition fails, the thread gets blocked.
•The thread automatically releases the mutex mwhen it leaves a synchronized(m) code block. Only one
unlockoperation is performed, so nested blocks synchronized on the same mutex are allowed.
•Upon reaching a return e expression in the synchronized code block, eis first evaluated to a value v,
then m.unlock() is called, and, finally, the value vis returned.
•If there is a breakorcontinue expression in the synchronized code block, and the execution of that
expression would cause the program to exit the code block, m.unlock() gets called automatically.
•If an exception occurs in the synchronized code block that causes the program to exit that code block,
m.unlock() gets called automatically.
The syntax of the synchronized expression is as follows:
synchronizedExpression
: 'synchronized' '(' identifier ')' block
;
The above identifier is a ReentrantMutex object.
15.3.6 Monitor
Monitoris a built-in implementation of a data structure that combines a mutex with a single associated
condition (a.k.a. wait queue). Monitorenables a thread to block and wait for a signal from another thread
to resume execution. It is a mechanism for synchronizing threads using variables shared between them. A
Monitorprovides the following methods:
•wait(timeout!: UInt64 = INFINITE_TIMEOUT): Bool : Wait for a signal, blocking the current thread.
•notify(): Unit : Wake up one thread of those waiting on the monitor, if any.
•notifyAll(): Unit : Wake up all threads waiting on the monitor, if any.
Before calling the wait￿notifyornotifyAll methods of the Monitorobject, you need to ensure that the
corresponding Monitorlock is held by the current thread. The waitmethod logically consists of the following
steps:
1.Add the current thread into the wait queue associated with this Monitor.
2.Block the current thread and simultaneously fully release theMonitorlock, memorising the number
of acquisitions.
3.Wait until some other thread signals this thread using either notifyornotifyAll method of the same
Monitorinstance.
4.Unblock the current thread and simultaneously acquire the Monitor lock, restoring the number of
acquisitions memorised on step 2.
Note: The waitmethod accepts an optional timeout parameter. Be aware that many conventional
operation systems commonly used in the industry do not provide real-time guarantees for scheduling ,
therefore it is not possible to ensure that a thread will be blocked for “precisely N toNanoseconds” – a system-
specific imprecision may and will be observed. Moreover, the current language specification explicitly allows
implementations to emit spurious wakeups – in such a case, value returned by waitis implementation-defined
– it may be either true or false . Therefore developers are encouraged to always wrap waitinto a condition-
testing loop:
synchronized (obj) {
while (<condition isnot true >){
obj.wait();
}
}
Monitoris defined as follows:
let INFINITE_TIMEOUT :UInt64 =0
class Monitor <:ReentrantMutex {
// Constructor.
init ()
// Blocks until either a paired `notify` is invoked or `timeout` toNanoseconds pass.
// Returns `true` if the monitor was signalled by another thread or `false` on timeout.
Spurious wakeups are allowed. ↪
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
func wait (timeout !:UInt64 =INFINITE_TIMEOUT) :Bool
// Wakes up a single thread waiting on this monitor, if any (no particular admission policy
implied). ↪
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
func notify ():Unit
// Wakes up all threads waiting on this monitor, if any (no particular admission policy
implied). ↪
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
func notifyAll ():Unit
}
15.3.7 MultiConditionMonitor
MultiConditionMonitor is a built-in implementation of a data structure that combines a mutex with a set
of dynamically created condition instances associated with this mutex. This class should only be used for
implementing advanced concurrent algorithms when the MonitorAPI is not enough.
Provides the following methods:
•newCondition(): ConditionID : Create, associate a new wait queue with this monitor and returns a
uniqure Condition identifier.
•wait(id: ConditionID, timeout!: UInt64 = INFINITE_TIMEOUT): Bool : Wait for a signal, blocking the
current thread.
•notify(id: ConditionID): Unit : Wake up one thread of those waiting on the monitor, if any.
•notifyAll(id: ConditionID): Unit : Wake up all threads waiting on the monitor, if any.
Initially, a MultiConditionMonitor has no associated conditions. Each invocation of newCondition asso-
ciates a new wait queue with this monitor and returns a unique identifer of the following type:
external struct ConditionID {
private init (){... }// constructor is intentionally private to prevent
// creation of such structs outside of MultiConditionMonitor
}
Please note that a user must not pass a ConditionID returned by one instance of MultiConditionMonitor
to other instances or create ConditionID s manually (e.g. using unsafetricks). ConditionID contains data (it
can be, for instance, an index in an internal array, direct address of an internal queue, or any other kind
of data) which associates with its creator MultiConditionMonitor , so passing a “foreign” ConditionID to a
MultiConditionMonitor results into IllegalSynchronizationStateException .
class MultiConditionMonitor <:ReentrantMutex {
// Constructor.
init ()
// Returns a new ConditionID associated with this monitor. May be used to implement
// "single mutex -- multiple wait queues" concurrent primitives.
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
func newCondition ():ConditionID
// Blocks until either a paired `notify` is invoked or `timeout` toNanoseconds pass.
// Returns `true` if the specified condition was signalled by another thread or `false` on
timeout. ↪
// Spurious wakeups are allowed.
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
// Throws ISSE("Invalid condition") if `id` was not returned by `newCondition` of this
MultiConditionMonitor instance. ↪
func wait (id:ConditionID, timeout !:UInt64 =INFINITE_TIMEOUT) :Bool
// Wakes up a single thread waiting on the specified condition, if any (no particular
admission policy implied). ↪
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
// Throws ISSE("Invalid condition") if `id` was not returned by `newCondition` of this
MultiConditionMonitor instance. ↪
func notify (id:ConditionID) :Unit
// Wakes up all threads waiting on the specified condition, if any (no particular admission
policy implied). ↪
// Throws ISSE("Mutex is not locked by the current thread") if the current thread does not
hold this mutex. ↪
// Throws ISSE("Invalid condition") if `id` was not returned by `newCondition` of this
MultiConditionMonitor instance. ↪
func notifyAll (id:ConditionID) :Unit
}
Example: Use MultiConditionMonitor to implement a “fixed-length bounded FIFO queue”, when the
queue is empty, get()will be blocked; when the queue is full, put()will be blocked.
class BoundedQueue {
// Create a MultiConditionMonitor, two Conditions.
let m:MultiConditionMonitor =MultiConditionMonitor()
var notFull :ConditionID
var notEmpty :ConditionID
var count :Int64 // Object count in buffer.
var head :Int64 // Write index.
var tail :Int64 // Read index.
// Queue's length is 100.
let items :Array <Object >=Array <Object >(100,{i=>Object()})
init (){
count =0
head =0
tail =0
synchronized (m) {
notFull =m.newCondition()
notEmpty =m.newCondition()
}
}
// Insert an object, if the queue is full, block the current thread.
public func put(x:Object) {
// Acquire the mutex.
synchronized (m) {
while (count ==100){
// If the queue is full, wait for the "queue notFull" event.
m.wait(notFull)
}
items[head] =x
head ++
if(head ==100){
head =0
}
count ++
// An object has been inserted and the current queue is no longer
// empty, so wake up the thread previously blocked on get()
// because the queue was empty.
m.notify(notEmpty)
}// Release the mutex.
}
// Pop an object, if the queue is empty, block the current thread.
public func get():Object {
// Acquire the mutex.
synchronized (m) {
while (count ==0){
// If the queue is empty, wait for the "queue notEmpty" event.
m.wait(notEmpty)
}
let x:Object =items[tail]
tail ++
if(tail ==100){
tail =0
}
count --
// An object has been popped and the current queue is no longer
// full, so wake up the thread previously blocked on put()
// because the queue was full.
m.notify(notFull)
return x
}// Release the mutex.
}
}
15.4 Memory Model
The memory model tackles the problem of memory visibility in concurrent programming. It specifies when
a write operation on a variable from a threadcan be observed by read operations on the same variable from
other threads
•If a data race happens, then its behavior is undefined.
•If there are no data races, the value read by a read operation is written by a write operation that is
the closest write operation (to the read operation) according to the happens-before order.
The memory model addresses the problem of memory visibility in concurrent programming, i.e.,
when a write operation in one thread becomes visible to another thread.
15.4.1 Data Race
If two threads access the same data , at least one of them is a write operation, and there is no happens-before
relation (defined in Section 15.4.2) between them, there is a data race.
Definition of access on the same data :
1.Accessestothesamevariableofthesameprimitivetype, enum, array, ortothesamefieldofstruct/class
type, are regarded as accesses the same data .
2.The accesses to different fields of struct/class type are considered as accesses on different data .
15.4.2 Happens-Before
•Program Order Rule : Each operation in a threadhappens before every subsequent operation in the
same thread.
var a:String
main() :Int64 {
a="hello, world"
println(a)
return 0
}
// OUTPUT:
// hello, world
•threadStart Rule : If threadA creates threadB by spawn, then the spawnoperation of threadA
happens before every operation in threadB
var a:String
func foo():Unit {
prtinln(a)
}
main() :Int64 {
a="hello, world"
let fut:Future <Unit >=spawn {
foo()
}
fut.get()
return 0
}
// OUTPUT:
// hello, world
•threadTermination Rule : If threadA calls futureB.get() and returns successfully, then every
operation in threadB happens before all subsequent operations after futureB.get() inthreadA.
var a:String
func foo():Unit {
a="hello, world"
}
main() :Int64 {
let fut:Future <Unit >=spawn {
foo()
}
fut.get()
println(a)
return 0
}
// OUTPUT:
// hello, world
•MutexSynchronization Rule : For operations on the same Mutexobject, there exists a Total Order ,
and the unlock operation ( unlock) on a Mutexin a thread can happens-before the subsequent lock
operation ( lock) on the Total Order on the Mutex.
•Atomic Variable Rule : For all operations on atomic variables, there exists a Total Order , a thread’s
operation on an atomic variable, happens-before all subsequent operations on atomic variables on this
Total Order .
•Transmissibility Rule : If A happens before B, and B happens before C, then A happens before C.Chapter 16
Automatic Differentiation
16.1 Introduction
Automatic differentiation , orADfor short, is a family of techniques to evaluate the derivative of a
function. AD offers advantages over other approaches by avoiding the expression swell caused by symbolic
differentiation while not incurring approximation errors as is the case with numerical differentiation.
For a quick overview of AD, we refer the reader to following references.
In CangJie, to generate the derivative of a function (the primal function ) at a given input point, AD
operates in the following steps.
•First, the primal function is converted into a composition of simple expressions (the Trace) whose
derivatives are known.
•Second, AD applies the Chain-Rule to calculate the derivative of the Trace in terms of the derivatives
of its components.
•Third, from these components AD generates a new function (the adjoint function ). Given the same
input of primal function, the adjoint function outputs
–the same result of the primal function
–a lambda function which implements the derivative of the primal function
•Finally, AD wraps the adjoint function in a series of differentiation expressions and provides them to
user, so they can directly access the result and gradient of the primal function.
Two main kinds of AD exist:
•Forward-modeAD ,whichoperatesbytraversingtheTraceandapplyingtheChain-Ruleinaforward
direction
•Reverse-mode AD , which operates by traversing the Trace and applying the Chain-Rule in a back-
ward direction
Of these, forward-mode AD is the more eﬀicient than reverse-mode when faced with functions with few
inputs and many outputs, whereas reverse-mode AD is preferable if the function has many inputs. Currently,
we only support reverse-mode AD in CangJie.
16.2 Limitations
Additionally, there are some other limitations in current AD in CangJie.
•only reverse-mode AD is supported
•only a subset of CangJie language features are supported to be differentiated (details below)
16.3 Differentiable Data Types
In the CangJie AD library, we provide a Differentiable interface to define the differentiation behavior of
data types in CangJie. Any data types on which AD will be performed MUST implement this interface to
make sure the AD accept this type as a valid differentiable type .
// Defined in the AD library
interface Differentiable <T>where T <: Differentiable<T >{
// Initialize a zero Tangent
func TangentZero ():T
// Sum up the tangent value `y`
func TangentAdd (y:T):T
}
For differentiable data types (such as floating point type, tuple type, structtype), the compiler auto-
matically generate a proper interface instance. For the differentiable structtype, you can also manually
implement the interface instance. More detailed examples are presented later.
16.3.1 Differentiable Numerical types
By default, the differentiable numerical types in CangJie are:
The Differentiable interface instances for differentiable numerical types are created by compiler.
extend Float16 <:Differentiable<Float16 >{
func TangentZero ():Float16 {
return 0.0
}
func TangentAdd (y:Float16 ):Float16 {
return this +y
}
}
extend Float32 <:Differentiable<Float32 >{
func TangentZero ():Float32 {
return 0.0
}
func TangentAdd (y:Float32 ):Float32 {
return this +y
}
}
extend Float64 <:Differentiable<Float64 >{
func TangentZero ():Float64 {
return 0.0
}
func TangentAdd (y:Float64 ):Float64 {
return this +y
}
}
No custom Differentiable interface instances can be provided by user to change their default differen-
tiation behaviors. If the users really want to do this, they can wrap it in a structand provide a custom
Differentiable instance for the structtype as presented later.
16.3.2 Differentiable T uple Type
ATupleis differentiable if and only if all its elements are of differentiable types.
let a:(Float16 ,Float16 )=(1.0,1.0) // differentiable
let b:(Float16 ,String) =(1.0,"foo" )// NOT differentiable
The Differentiable interface instances for differentiable Tupletypes are created by compiler. No cus-
tom Differentiable interface instances can be provided by the user to change their default differentiation
behaviors.
For example, the Differentiable interface instance of a tuple type (T0,T1)is as follows.
extend (T0, T1) <:Differentiable <(T0, T1)>where T0 <: Differentiable <T0>,T1<:
Differentiable <T1>{ ↪
func TangentZero ():(T0, T1) {
return (this [0].TangentZero(), this [1].TangentZero())
}
func TangentAdd (y:(T0, T1)) :(T0, T1) {
return (this [0].TangentAdd(y[ 0]), this [1].TangentAdd(y[ 1]))
}
}
16.3.3 Differentiable struct Type
A struct is not differentiable by default, but it can be defined as differentiable using the following syntax.
differentiableDataTypeAnnotation
:'@Differentiable' (customization )?
customization
:'[' exceptClause ']'
exceptClause
:'except:' '[' ((identifier )(',' identifier )*)? ']'
In this syntax, user can add @Differentiable annotation right above the structdefinition to make it
differentiable and also configure its differentiation behavior by exceptlist. Given the exceptlist, the member
variables in the structwill be divided into two kinds.
•Any member variables notin the exceptlist mustbe with differentiable type. The AD system will
perform differentiation on these member variables when differentiating the object of this structtype
•Any member variables in the exceptlist will be ignored when differentiating the object of this struct
type. The AD system will leave these member variables un-initialized. Therefore, user must make
sure they will notaccess these member variables in the differentiation result. Otherwise, it leads to
un-defined behavior
// Differentiable
@Differentiable
struct Point {
let x:Float16
let y:Float16
init (x:Float16 ,y:Float16 ){
this .x=x
this .y=y
}
}
// Differentiable, but no back-propagation will happen in the excepted field `tag`
@Differentiable [except: [tag]]
struct TaggedPoint {
let x:Float16
let y:Float16
let tag:String
init (x:Float16 ,y:Float16 ,tag:String) {
this .x=x
this .y=y
this .tag =tag
}
}
// Compilation Error: member 'tag' has non-differentiable type 'String',
// but is not in the except list of the annotation '@Differentiable'
@Differentiable
struct TaggedWrong {
let x:Float16
let y:Float16
let tag:String
init (x:Float16 ,y:Float16 ,tag:String) {
this .x=x
this .y=y
this .tag =tag
}
}
We also provide another syntax sugar for the definition of exceptlist. User can define a includelist for
astructin following syntax. In this situation, all the member variables of the structwhich are notin the
includelist will be defined as in the exceptlist.
differentiableDataTypeAnnotation
:'@Differentiable' (customization )?
customization
:'[' includeClause ']'
includeClause
:'include:' '[' ((identifier )(',' identifier )*)? ']'
// Differentiable, but no back-propagation will happen in the excepted field `tag`
@Differentiable [include: [x, y]]
struct TaggedPoint {
let x:Float16
let y:Float16
let tag:String
init (x:Float16 ,y:Float16 ,tag:String) {
this .x=x
this .y=y
this .tag =tag
}
}
By default, the Differentiable interface instances for differentiable structtypes are created by the
compiler.
// Tangent operation for Point
extend Point <:Differentiable<Point >{
func TangentZero ():Point {
return Point( this .x.TangentZero(), this .y.TangentZero())
}
func TangentAdd (b:Point) :Point {
return Point( this .x.TangentAdd(b.x), this .y.TangentAdd(b.y))
}
}
extend TaggedPoint <:Differentiable<TaggedPoint >{
// Tangent operation for TaggedPoint
func TangentZero ():Point {
return TaggedPoint( this .x.TangentZero(), this .y.TangentZero(), NULL)
}
func TangentAdd (b:TaggedPoint) :TaggedPoint {
return TaggedPoint( this .x.TangentAdd(b.x), this .y.TangentAdd(b.y), NULL)
}
}
However, user can define custom differentiation behavior for a struct type by manually providing Dif-
ferentiable interface instance for it.
extend TaggedPoint <:Differentiable<TaggedPoint >{
func TangentZero ():TaggedPoint {
var bias :Float16 =0.01
return TaggedPoint(bias, bias, "")
}
func TangentAdd (b:TaggedPoint) :TaggedPoint {
return TaggedPoint( this .x.TangentAdd(b.x), this .y.TangentAdd(b.y), this .tag)
}
}
16.3.4 Differentiable Unit Type
In AD, Unittype is a special differentiable type. No custom Differentiable interface instance can be
provided by user to change its default differentiation behaviors. No Differentiable interface instance will be
generated by the complier either. Any differentiation on the Unittype objects will still be with Unittype.
16.4 Un-Differentiable Data Types
Currently, String,Range,Array,enum,Option,Int16,Int32,Int64,Classand Interface are notsupported in
the AD system. Therefore, they are notdifferentiable.
16.5 Differentiable F unctions
A function is not differentiable by default, but it can be defined as differentiable using the following syntax.
differentiableFunctionAnnotation
:'@Differentiable' (configuration )?
configuration
:'[' exceptClause ']'
exceptClause
:'except:' '[' ((identifier )(',' identifier )*)? ']'
In this syntax, user can add @Differentiable annotation right above the function definition to make it
differentiable and also configure its differentiation behavior by exceptlist. Given the exceptlist, the function
arguments will be divided into two kinds.
•Any function arguments notin the exceptlist mustbe with differentiable type. The AD system
will perform differentiation on these function arguments. The differentiation result will include the
derivative of the function with respect to these function arguments
•Any function arguments in the exceptlist and the intermediate values depend on these function argu-
ments will be ignored when differentiating the function. The differentiation result will notinclude the
derivative of the function with respect to these function arguments
// Differentiable function, its derivatives will be calculated with respect to `x` and `y`
@Differentiable
func f(x:Float64 ,y:Float64 ){
return x*y
}
// Differentiable function, its derivative will only be calculated with respect to `x`
@Differentiable [except: [y]]
func f(x:Float64 ,y:Float64 ){
return x*y
}
// Compilation Error: parameter 'z' has non-differentiable type 'String',
// but is not in the except list of the annotation '@Differentiable'
@Differentiable
func f(x:Float64 ,y:Float64 ,z:String) {
return x+y
}
Similarly, we also provide another syntax sugar for the definition of exceptlist. User can define a include
list for a function in following syntax. In this situation, all the parameters of the function which are notin
theincludelist will be defined as in the exceptlist. Either exceptorincludecan be present.
differentiableFunctionAnnotation
:'@Differentiable' (configuration )?
configuration
:'[' includeClause ']'
includeClause
:'include:' '[' ((identifier )(',' identifier )*)? ']'
// Differentiable function, its derivative will only be calculated with respect to `x`
@Differentiable [include: [x]]
func f(x:Float64 ,y:Float64 ){
x*y
}
Note that, when defining a differentiable function by the syntax above, user needs to make sure the
function meets the following conditions.
•the return type of the function is a differentiable type
•global variables are notallowed to be used in the function
•all the expressions in the function body are valid expressions in differentiable function . In other
words, they will all satisfy any one of the following conditions.
•the expression is differentiable, i.e., its differentiation behavior is known
•the expression does notdirectly or indirectly depends on the function arguments which are notin the
exceptlist. If it directly or indirectly depends on captured environment variables, then in the outer
scope function, these environment variables should notdirectly or indirectly depends on the function
arguments which are notin the exceptlist of the outer scope function
In the AD system, the following expressions are with known differentiation behavior.
•Built-in math operators +,-,*,/when the operands are valid expressions in differentiable function
•Function calls when the callee function is differentiable
•Lambda expressions when the body are valid expressions
•Conditional expressions when the expressions in the true and false branches are valid expressions in
differentiable function
•Loop expressions when the expressions in the loop body are valid expressions in differentiable function
•Tupleinitializations when the Tupletype is differentiable type
•Tupledeconstructions and subscript accesses when the Tupletype is differentiable type
•structinitializations when the structtype is differentiable type and constructors being called are
differentiable (the implicit default constructor of a differentiable struct is always differentiable, custom
constructors need to be explicitly annotated as differentiable)
•structmember variable accesses when the structtype is differentiable type and the member variable
being accessed is notin the exceptlist
•Return expression which only occur once in the function body (AD system will ignore the return in
the nested functions and lambdas)
•Assign expressions (not the initialization) when the -enable-state-threading compilation flag is en-
abled
Other expressions are not differentiable or not supported yet in current AD system.
// Not differentiable
func f(x:Float64 ,y:Float64 ):Float64 {
return x+y
}
// Compilation Error: expression x is marked for back-propagation,
// but is used in a context that cannot be back-propagated
@Differentiable
func g(x:Float64 ,y:Float64 ):Float64 {
return f(x, y)
}
16.5.1 Custom Differentiation Behavior
Themoreexperiencedusercandefinecustomdifferentiationbehaviorforadifferentiablefunctionbymanually
writing a custom adjoint function. In order to do so correctly, it is important to understand the basic math
concepts of AD and how they apply to CangJie AD system.
16.5.1.1 Chain rules
Suppose we want to differentiate the following mathematical function 𝐹to get𝜕𝑦
𝜕𝑥.
𝑦 = 𝐹(𝑥) = 𝑚(𝑛(𝑥))
And the computation process of F will be:
𝑎 = 𝑛(𝑥)
𝑦 = 𝑚(𝑎)
By definition, the chain rule states that𝜕𝑦
𝜕𝑥can be calculated as follows.
𝜕𝑦
𝜕𝑥=𝜕𝑦
𝜕𝑎𝜕𝑎
𝜕𝑥
16.5.1.2 Jacobian Matrix
Given a mathematical function (𝑦1, 𝑦2, ..., 𝑦𝑛) = 𝐹(𝑥1, 𝑥2, 𝑥𝑛), itsJacobian matrix Jis a matrix whose rows
are the partial derivatives of F.
𝐽 =⎡
⎢
⎣𝜕𝑦1
𝜕𝑥1...𝜕𝑦1
𝜕𝑥𝑛
... ... ...
𝜕𝑦𝑚
𝜕𝑥1...𝜕𝑦𝑚
𝜕𝑥𝑛⎤
⎥
⎦
16.5.1.3 Jacobian Vector Product & Vector Jacobian Product
Similarly, given a math function f to be differentiated.
𝑦 = 𝑓(𝑥1, 𝑥2, ..., 𝑥𝑛) = 𝑚(𝑛(𝑥1, 𝑥2, ..., 𝑥𝑛))
The computation process of f will be:
(𝑎1, 𝑎2, ..., 𝑎𝑘) = 𝑛(𝑥1, 𝑥2, ..., 𝑥𝑛)
𝑦 = 𝑚(𝑎1, 𝑎2, ..., 𝑎𝑘)
According to the chain rule, the derivatives of F can be calculated as:
⎛⎜⎜⎜⎜⎜
⎝𝜕𝑦
𝜕𝑥1𝜕𝑦
𝜕𝑥2
...
𝜕𝑦
𝜕𝑥𝑛⎞⎟⎟⎟⎟⎟
⎠=⎛⎜⎜⎜⎜⎜
⎝𝜕𝑦
𝜕𝑎1𝜕𝑎1
𝜕𝑥1+𝜕𝑦
𝜕𝑎2𝜕𝑎2
𝜕𝑥1+ ... +𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥1𝜕𝑦
𝜕𝑎1𝜕𝑎1
𝜕𝑥2+𝜕𝑦
𝜕𝑎2𝜕𝑎2
𝜕𝑥2+ ... +𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥2
...
𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥𝑛+𝜕𝑦
𝜕𝑎2𝜕𝑎2
𝜕𝑥𝑛+ ... +𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥𝑛⎞⎟⎟⎟⎟⎟
⎠=⎛⎜⎜⎜⎜⎜
⎝𝜕𝑎1
𝜕𝑥1𝜕𝑎2
𝜕𝑥1...𝜕𝑎𝑘
𝜕𝑥1𝜕𝑎1
𝜕𝑥2𝜕𝑎2
𝜕𝑥2...𝜕𝑎𝑘
𝜕𝑥2
...
𝜕𝑎1
𝜕𝑥𝑛𝜕𝑎2
𝜕𝑥𝑛...𝜕𝑎𝑘
𝜕𝑥𝑛⎞⎟⎟⎟⎟⎟
⎠∗⎛⎜⎜⎜⎜⎜
⎝𝜕𝑦
𝜕𝑎1𝜕𝑦
𝜕𝑎2
...
𝜕𝑦
𝜕𝑎𝑘⎞⎟⎟⎟⎟⎟
⎠= (𝐽𝑛)𝑇∗⎛⎜⎜⎜⎜⎜
⎝𝜕𝑦
𝜕𝑎1𝜕𝑦
𝜕𝑎2
...
𝜕𝑦
𝜕𝑎𝑘⎞⎟⎟⎟⎟⎟
⎠
Where J_n is the jacobian matrix of function n.
We call the above equation as Jacobian Vector Product (JVP) . We can also express the transposed
jacobian vector product as Vector Jacobian Product (VJP) .
(𝜕𝑦
𝜕𝑥1, ...,𝜕𝑦
𝜕𝑥𝑥) = (𝜕𝑦
𝜕𝑎1𝜕𝑎1
𝜕𝑥1+ ... +𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥1, ...,𝜕𝑦
𝜕𝑎1𝜕𝑎1
𝜕𝑥𝑛+ ... +𝜕𝑦
𝜕𝑎𝑘𝜕𝑎𝑘
𝜕𝑥𝑛)
= (𝜕𝑦
𝜕𝑎1, ...,𝜕𝑦
𝜕𝑎𝑘) ∗⎛⎜⎜
⎝𝜕𝑎1
𝜕𝑥1...𝜕𝑎1
𝜕𝑥𝑛
...
𝜕𝑎𝑘
𝜕𝑥1...𝜕𝑎𝑘
𝜕𝑥𝑛⎞⎟⎟
⎠
= (𝜕𝑦
𝜕𝑎1, ...,𝜕𝑦
𝜕𝑎𝑘) ∗ 𝐽𝑛
16.5.1.4 Adjoint Function
As for CangJie, given a function f which implements the above mathematical function F, it should be with
type of (X1, X2, ..., Xm)->(Y) where the Xiis the type of corresponding input 𝑥𝑖of F and Yis the return
type of F. More specificly, the Yis a Tupletype (Y1, Y2, ..., Yn) where the Yiis the type of corresponding
output 𝑦𝑖of F.
As mentioned above, when user differentiates the primal function f, the AD system in CangJie will
generate an adjoint function for f. Given the same input of primal function f, the outputs of the adjoint
function outputs will be:
•the same result as the primal function
•afunctionwhichimplementsthedifferentiationChain-Ruleoftheprimalfunction. Wecallthisfunction
as ‘propagator’ (also ‘back-propagator’ in the reverse-mode AD). According to the math definition, the
back-propagator should implement the calculation of Jacobian Vector Product
Note that, the compiler will notbe able to check if the adjoint function provided by user is correct in
math. It is the responsibility of the user to ensure that it satisfies the math formula. But the AD system will
check if the custom adjoint function satisfies the typing rule introduced by the math formula and throw out
compilation errors if there is any type mismatch. In addition, CangJie AD does notsupport custom adjoint
functions for differentiable functions whose input or return types contain function type components.
•the number, types and order of the function arguments in the adjoint function should be totally the
same with the primal function (the identifier can be different)
•the return type of the adjoint function should be a Tupletype
–the first element should be with same type with the return type of primal function
–the second element should be a function type
∗the function argument type should be the return type of primal function
∗the return type should be a Tupletype (X1, X2, ..., Xm) containing all the argument types
of primal function. If the element number in this Tupletype is 0, then it will be downgraded
into Unittype. If there is only one element Xjin this Tupletype, then it will be downgraded
into Xjtype
16.5.1.5 Custom Adjoints
Given a function fannotated as differentiable, the fcan only be a global function, user can use the following
syntax to add annotation right above the function definition of adj_f. Then the function adj_fwill be
specified as the custom adjoint function of f:
customAdjointAnnotation
:'@Adjoint' '[' 'primal' ':' identifier ']'
// Function `f` is differentiable and its custom adjoint function is `g`
@Differentiable
func f(x:Float64 ):Float64 {
return x*x*x
}
@Adjoint [primal: f]
func g(x:Float64 ):(Float64 ,(Float64 )->Float64 ){
let xSquare =x*x
return (
xSquare *x,
{dy:Float64 =>
return dy*xSquare *3.0
}
)
}
After the user specifies a custom adjoint function for the primal function, the AD system will treat the
primal function as a black box and will not try to differentiate its body. Instead, it will directly use the
custom adjoint function as the differentiation result of the primal function.
16.5.2 Non T op-level Differentiable F unctions
Note that the syntax and rules above are used on global functions by default. Actually, there are several
kinds of non global functions in CangJie. In the AD system, we also support the definition of the following
kinds of non global functions as differentiable.
16.5.2.1 structConstructors and Member Functions
User can use same differentiable function annotation syntax to define the structconstructors or member
functions as differentiable.
•Define the structconstructors as differentiable. To do this, user need to make sure that the structtype
itself is differentiable. In this situation, all the initializations of the structwhich call this constructor
is differentiable. Otherwise, if the constructor is notdefined as differentiable, then the initializations
will be notdifferentiable
•Define the member functions in the structas differentiable. In this situation, all the calls to this
member function will be de-sugared and differentiated as a normal function call. Note that, the
de-sugared structmember function will have another thisargument representing the structobject
itself. Therefore, user can also put thisin the exceptlist to determine if the structobject will be
differentiated. And the structtype is notnecessary to be differentiable when user tries to define its
member functions to be differentiable. The only thing user need to do is to add thisin the exceptlist
to ignore this non differentiable structobject
@Differentiable
struct Point {
let a:Float64
let b:Float64
// Differentiable constructor
@Differentiable
init (x:Float64 ){
a=x
b=x
}
}
@Differentiable
func foo(x:Float64 ){
// The initialization will call the differentiable constructor.
// Therefore it is differentiable here.
return Point(x)
}
@Differentiable
struct Point {
let a:Float64
let b:Float64
init (a:Float64 ,b:Float64 ){
this .a=a
this .b=b
}
// The AD system will de-sugar this function to `Point_sum` below and
// then differentiate it in the following AD process
@Differentiable
func sum(bias :Float64 ):Float64 {
return a+b+bias
}
}
// De-sugared global function `Point_sum`
// @Differentiable
// func Point_sum(this: Point, bias: Float64): Float64 {
// return this.a + this.b + bias
// }
@Differentiable
func foo(p:Point) {
// Will be de-sugared to `return Point_sum(p, 0.0)` and then differentiated
return p.sum( 0.0)
}
16.5.2.2 Class Member Function
User also can use same differentiable function annotation syntax to define the classmember functions as
differentiable (except for functions that will be override since the dynamic dispatch is notsupported in the
AD system yet). The only difference is that, since the classtype itself is notdifferentiable, user must add
thisto the exceptlist except for the static member function. Then all the call to this member function will
be de-sugared and differentiated as a normal function call.
class Point {
let a:Float64
let b:Float64
init (a:Float64 ,b:Float64 ){
this .a=a
this .b=b
}
// User must add `this` in the `except` list here.
// Then the AD system will de-sugar this function to
// `Point_sum` below and differentiate it in the
// following AD process
@Differentiable [except: [this]]
func sum(bias :Float64 ):Float64 {
return a+b+bias
}
}
// De-sugared global function `Point_sum`
// @Differentiable [except: [this]]
// func Point_sum(this: Point, bias: Float64): Float64 {
// return this.a + this.b + bias
// }
Note that:
•if a differentiable classmember function is shadowed, in the AD system, the shadowing function and
the shadowed function are two independent functions whose differentiability is irrelevant.
16.5.2.3 Interface Function
User also can use same differentiable function annotation syntax to define the Interface functions as differ-
entiable (except for functions that will be override since the dynamic dispatch is notsupported in the AD
system yet). Similarly, since the Interface type itself is notdifferentiable, user must add thisto the except
list except for the static function. Then all the call to these functions will be de-sugared and differentiated
as a normal function call.
interface Point {
// User must add `this` in the `except` list here.
// Then the AD system will de-sugar this function to
// `Point_sum` below and differentiate it in the
// following AD process
@Differentiable [except: [this]]
func sum(a:Float64 ,b:Float64 ):Float64 {
return a+b
}
}
// De-sugared global function `Point_sum`
// @Differentiable [except: [this]]
// func Point_sum(this: Point, a: Float64, b: Float64): Float64 {
// return a + b
// }
Note that:
•if user define a abstract function in interface as differentiable, user mustmake sure all its implemen-
tations are defined as differentiable and with the same exceptlist
•if a differentiable function in Interface is shadowed, in the AD system, the shadowing function and
the shadowed function are two independent functions whose differentiability is irrelevant.
16.6 Differentiation Expressions
As mentioned above, the AD system will automatically differentiate the differentiable functions and generate
their adjoint functions. However, these adjoint functions are internal and not exposed to the user directly.
Instead, the AD system will wrap them in differentiation expressions and provide to the user so they can
easily obtain the derivative result of a differentiable function, i.e., gradient.
16.6.1 @Grad expressions
The @Gradexpression allows the user to obtain the gradient of a differentiable function at a given input value.
GradExpression
:'@Grad' '(' diffFunc (',' inputVal )*')'
diffFunc
:identifier
inputVal
:expression
Note the following when using the @Gradexpression.
•As shown in the above syntax definition, the @Gradexpression can only be used in the var,letvariable
initialization expression. Any other usages will lead to compilation error
•The diffFunc identifier must refer to a differentiable function￿and make sure the function meets the
following conditions. Otherwise, it will leads to compilation error
–non global functions are notallowed
–must refer to a differentiable function
–function does not support named parameters and parameter default values
–the return type of this function must be one of the following types, Float16,Float32orFloat64
•The set of inputVal identifier(can be an empty set) should match with the arguments of the func-
tion referred by diffFunc , the matching rules are the same as the function invoking expression diff-
Func(inputVal, ...) .
•Given the function fwith type (X1, X2, ..., Xm)->Y ,
–If the exceptlist is empty, then the type of @Gradexpression will be (X1, X2, ..., Xm) . If the
element number in this Tupletype is 0, then it will be downgraded into Unittype. If there is only
one element Xjin this Tupletype, then it will be downgraded into Xjtype
–If the exceptlist is not empty, then we need to exclude the argument in the exceptlist. Say
argument 𝑥𝑗 is in the exceptlist, then the type of @Gradexpression will be (X1, X2, ..., Xj-1,
Xj+1, Xm)
@Differentiable [except: [negate]]
func product (x:Float64 ,y:Float64 ,negate :Bool ):Float64 {
return if(negate) {-x*y}else {x*y}
}
main() :Int64 {
// Since `negate` is excepted, the gradient of product only has two components
let productGrad =@Grad (product, 2.0, 3.0, true)
print(productGrad[ 0].toString()) // Prints -3.000000
print(productGrad[ 1].toString()) // Prints -2.000000
return 0
}
@Differentiable
func foo(x:Float64 ,y:Float64 ):Float64 {
return x*y
}
main() {
let res =@Grad (foo, 2.0, 3.0) // Ok
// Compilation Error: @Grad expr must be used in var decl with an identifier
print( @Grad (foo, 2.0, 3.0)[ 0].toString())
// Compilation Error: @Grad expr must be used in var decl with an identifier
let (gradx, grady) =@Grad (foo, 2.0, 3.0)
return 0
}
16.6.2 @ValWithGrad expressions
we provide another @ValWithGrad expression to user. It allows the user to obtain both the result and the
gradient of a differentiable function at given input value.
ValWithGradExpression
:'@ValWithGrad' '(' diffFunc (',' inputVal )*')'
diffFunc
:identifier
inputVal
:expression
Note the following when using the @ValWithGrad expression.
•As shown in the above syntax definition, the @ValWithGrad expression can only be used in the var,let
variable initialization expression. Any other usages will lead to compilation error
•The diffFunc identifier must refer to a differentiable function￿and make sure the function meets the
following conditions. Otherwise, it will leads to compilation error
–non global functions are notallowed
–must refer to a differentiable function
–function does not support named parameters and parameter default values
–the return type of this function must be one of the following types, Float16,Float32orFloat64
•The set of inputVal identifier(can be an empty set) should match with the arguments of the func-
tion referred by diffFunc , the matching rules are the same as the function invoking expression diff-
Func(inputVal, ...) .
•Given the function fwith type (X1, X2, ..., Xm)->Y ,
–If the exceptlist is empty, then the type of @ValWithGrad expression will be (Y, (X1, X2, ...,
Xm)). If the element number in this Tupletype is 0, then it will be downgraded into (Y, Unit)
type. If there is only one element Xjin this Tupletype, then it will be downgraded into (Y, Xj)
type
–If the exceptlist is not empty, then we need to exclude the argument in the exceptlist. Say
argument Xjis in the exceptlist, then the type of @ValWithGrad expression will be (Y, (X1, X2,
..., Xj-1, Xj+1, Xm))
@Differentiable [except: [negate]]
func product (x:Float64 ,y:Float64 ,negate :Bool ):Float64 {
return if(negate) {-x*y}else {x*y}
}
main() :Int64 {
let productValWithGrad =@ValWithGrad (product, 2.0, 3.0, true)
let (productRes, productGrad) =productValWithGrad
print(productRes.toString()) // prints -6.000000
print(productGrad[ 0].toString()) // Prints -3.000000
print(productGrad[ 1].toString()) // Prints -2.000000
return 0
}
@Differentiable
func foo(x:Float64 ,y:Float64 ):Float64 {
return x*y
}
main() {
let res =@ValWithGrad (foo, 2.0, 3.0) // Ok
// Compilation Error: @ValWithGrad expr must be used in var decl with an identifier
print( @ValWithGrad (foo, 2.0, 3.0)[ 0].toString())
// Compilation Error: @ValWithGrad expr must be used in var decl with an identifier
let (res, (gradx, grady)) =@ValWithGrad (foo, 2.0, 3.0)
return 0
}
16.6.3 @VJP expressions
we provide another @VJPexpression to user. It allows the user to obtain both the result and the back-
propagator of a differentiable function at given input value.
VJPExpression
:'@VJP' '(' diffFunc (',' inputVal )*')'
diffFunc
:identifier
inputVal
:expression
Note the following when using the @VJPexpression.
•The diffFunc identifier must refer to a differentiable function￿and make sure the function meets the
following conditions. Otherwise, it will leads to compilation error
–non global functions are notallowed
–must refer to a differentiable function
–function does not support named parameters and parameter default values
•The set of inputVal identifier(can be an empty set) should match with the arguments of the func-
tion referred by diffFunc , the matching rules are the same as the function invoking expression diff-
Func(inputVal, ...) .
•Given the function fwith type (X1, X2, ..., Xm)->Y ,
–If the exceptlist is empty, then the type of @VJPexpression will be (Y, (Y) -> (X1, X2, ...,
Xm)). If the element number in this Tupletype is 0, then it will be downgraded into (Y, (Y) ->
Unit)type. If there is only one element Xjin this Tupletype, then it will be downgraded into (Y,
(Y) -> Xj) type
–If the exceptlist is not empty, then we need to exclude the argument in the exceptlist. Say
argument Xjis in the exceptlist, then the type of @VJPexpression will be (Y, (Y) -> (X1, X2,
..., Xj-1, Xj+1, Xm))
@Differentiable [except: [negate]]
func product (x:Float64 ,y:Float64 ,negate :Bool ):Float64 {
return if(negate) {-x*y}else {x*y}
}
main() :Int64 {
let productVJP =@VJP (product, 2.0, 3.0, true)
let (productRes, productBP) =productVJP
print(productRes.toString()) // prints -6.000000
let productGrad =productBP( 1.0)
print(productGrad[ 0].toString()) // Prints -3.000000
print(productGrad[ 1].toString()) // Prints -2.000000
return 0
}
16.6.4 stopGradient API
This function is defined in the AD library. Obviously, its implementation is an identity function (that is,
stopGradient<T>(x: T) = x ). But from the perspective of the differentiability checker, the rule for this
function is special.
•the function argument xis a value that needs to be differentiated
•no differentiation should happen on the return value
public func stopGradient <T>(x:T):T{
return x
}
In other words, this function has the effect of converting a value that needs to be differentiated into a
value on which no differentiation can happen (a conversion that would otherwise be forbidden).
User can explicitly use the API to implement some programs which are forbidden by the checking system.
For example, this can be used when calling non- differentiable functions as the code below.
// Not differentiable, therefore no differentiation
// will happen on all the values here
func sign (x:Float64 ){
if(x<0.0){return -1.0 }else {return 1.0 }
}
// Within the scope of `abs`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func abs(x:Float64 ){
// `x` needs to be differentiated, yet
// no differentiation can happen on `x`
// since it is passed into a non-differentiable
// function.
return sign(x) *x
}
This code will not pass the differentiability checker since xneeds to be differentiated inside abs, but
is passed to the function signwhich is not differentiable (and therefore none of its arguments are back-
propagable). In this situation, user can use the stopGradient API to fix the problem as follows.
func sign (x:Float64 ){
if(x<0.0){return -1.0 }else {return 1.0 }
}
@Differentiable
func abs(x:Float64 ){
return sign(stopGradient <Float64 >(x)) *x
}
16.7 Export/Import of Adjoint functions
Given a primal function defined in a package, the AD system will differentiate it and generate its adjoint
function in the same package. User can make sure the adjoint function will have the same behavior in
importing/exporting by using import a.* clause. Thus, when user imports the primal function, the adjoint
function will also be imported, then user can differentiate the primal function in current package.
//================================= file A
package a
// AD system will generate `fooAdj` as the adjoint of `foo`
// `fooAdj` also has `public` attribute
@Differentiable
public func foo(x:Float64 ){
return x
}
//================================= file B
// Will also import a.fooAdj implicitly
import a.*
main (){
// The AD system will use the `a.fooAdj` as the adjoint of `a.foo` for differentiation
let gradRes =@Grad (foo, 2.0)
print(gradRes.toString()) // Prints 1.000000
0
}
Note that, if user wants to provide custom adjoint function, they also need to manually set the public
attribute for the adjoint function. To make sure the adjoint function will be imported with the primal
function.
//================================= file A
package a
@Differentiable
public func foo(x:Float64 ):Float64 {
return x
}
// Also set the `public` attribute for the custom adjoint function
@Adjoint [primal: foo]
public func dfoo (x:Float64 ):(Float64 ,(Float64 )->Float64 ){
return (
x,
{dy:Float64 =>
return 1.0 *dy
}
)
}
//================================= file B
import a.*
main (){
// The AD system will use the `a.dfoo` as the adjoint of `a.foo` for differentiation`
let gradRes =@Grad (foo, 2.0)
print(gradRes.toString()) // Prints 1.000000
0
}
Besides, in the scenarios of importing/exporting, given a primal function, there might be multiple adjoint
functions from different sources. In this situation, we define the following rules to define the priority and
which adjoint function we will pick to use.
•The local adjoint function defined in the current package has a higher priority than the imported
adjoint functions. The latter will be shadowed by the former
•The compiler will throw out compilation errors when there are multiple imported adjoint functions but
no local adjoint function
//================================= file A
package a
@Differentiable
public func foo(x:Float64 ):Float64 {
return x
}
@Adjoint [primal: foo]
public func dfoo (x:Float64 ):(Float64 ,(Float64 )->Float64 ){
return (
x,
{dy:Float64 =>
return 1.0 *dy
}
)
}
//================================= file B
import a.*
@Adjoint [primal: foo]
func localDFoo (x:Float64 ):(Float64 ,(Float64 )->Float64 ){
return (
x,
{dy:Float64 =>
return 1.0 *dy
}
)
}
main() {
// The AD system will use the `localDFoo` as the
// adjoint of `a.foo` for differentiation, since
// it has higher priority than the `a.dfoo`
let gradRes =@Grad (foo, 2.0)
print(gradRes.toString()) // Prints 1.000000
0
}
//================================= file A
package a
@Differentiable
public func foo(x:Float64 ):Float64 {
return x
}
//================================= file B
package b
import a.*
@Adjoint [primal: foo]
public func dfooB (x:Float64 ):(Float64 ,(Float64 )->Float64 ){
return (
x,
{dy:Float64 =>
return 1.0 *dy
}
)
}
//================================= file C
package c
import a.*
@Adjoint [primal: foo]
public func dfooC (x:Float64 ):(Float64 ,(Float64 )->Float64 ){
return (
x,
{dy:Float64 =>
return 1.0 *dy
}
)
}
//================================= file D
import a.*,b.*,c.*
main (){
// Compilation Error: multiple imported adjoint for function foo are found
let grad_res =@Grad (foo, 2.0)
0
}
16.8 Except-V alidity Checking
Apart from the presented typing rules and differentiation rules checking, to help the user correctly use the
exceptmechanism in CangJie AD system, the compiler will run an extra static checking on the differentiable
function.
For example, the code below is not valid, as the user expects the function footo be differentiable, but
its derivative would depend on the derivative of abswith respect to its argument x. However this derivative
does not exist as xis in the exceptlist of abs, and the final result may not be what the user expects.
@Differentiable [except: [x]]
func abs(x:Float64 ){
return if(x<=0.0){-x}else {x}
}
@Differentiable
func foo(x:Float64 ){
return abs(x) +x
}
Therefore, we define and implement a series of checking rules.
•No differentiation can happen on the function arguments that are in the exceptlist of function
•No differentiation can happen on the member variables that are in the exceptlist of struct
•No differentiation can happen on the literal constant values
•No differentiation can happen on intermediate values if they are depended by other values where
differentiation will not happen
Besides, due to the implementation of AD system, we have some extra rules in the checking.
•Since the elements of a Tuplecannot be annotated as except(unlike the member variables of a struct),
when the elements in a Tuplehave different differentiation behavior, we have to pick the worst from
them as the result for the whole Tupleexpression
•Since there is no support for exceptannotations on the types of function arguments (we can only
annotate a function definition instead of a function type), for a differentiable function, we assume that
the followings are all differentiable function with an empty exceptlist
–values of function type that appear in the arguments which are notin the exceptlist
–values of function type that appear in the return value
•within a differentiable function, every local function and lambda is implicitly differentiable and with a
empty exceptlist
•the mutable variables that are assigned to more than once must be differentiable
We will illustrate a series of example programs to demonstrate some common scenarios in Except-Validity
checking.
Example One: function exceptmechanism
// Within the scope of `abs`, no differentiation
// can happen on `x` as it is in the except list
@Differentiable [except: [x]]
func abs(x:Float64 ){
return if(x<=0.0){-x}else {x}
}
// Within the scope of `foo`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func foo(x:Float64 ){
// `x` needs to be differentiated yet no
// differentiation on `x` can happen as it
// is passed to the argument of `abs` which
// is in the `except` list
return abs(x) +x
}
For the above example program, the compiler will emit the following error.
error: function foo failed the differentiability check
error: expression x is marked for back-propagation, but is used in a context that cannot be
back-propagated ↪
error: error caused by x appearing in expression
let v0: Float64 = abs(x)
error: consider including x in an except list
Example Two: Variable Dependency
// Within the scope of `abs`, no differentiation
// can happen on `x` as it is in the except list
@Differentiable [except: [x]]
func abs(x:Float64 ){
if(x<=0.0){-x}else {x}
}
// Within the scope of `cube`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func cube (x:Float64 ){
return x*x*x
}
// Within the scope of `cube`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func foo(x:Float64 ){
// `x` needs to be differentiated yet no differeniation
// can happend on `x` as it is depended by the `u` where
// no differentiation can happen
let u=cube(x)
// No differentiation can happend on `u` as it is passed
// to the argument of `abs` which is in the `except` list
let v=abs(u)
// `v` will be differentiated as `bar` is differentiable
return v
}
For the above example program, the compiler will emit the following error.
error: function foo failed the differentiability check
error: expression x is marked for back-propagation, but is used in a context that cannot be
back-propagated ↪
error: error caused by x appearing in expression
let u: Float64 = cube(x)
error: consider including x in an except list
On the other hand, the following program is valid.
// Within the scope of `abs`, no differentiation
// can happen on `x` as it is in the except list
@Differentiable [except: [x]]
func abs(x:Float64 ){
if(x<=0.0){-x}else {x}
}
// Within the scope of `cube`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func bar(x:Float64 ){
// No differentiation can happen on constant
// value 10.0, so it is ok to be passed to the
// argument of `abs` which is in the `except` list
let u=abs( 10.0 )
// No differentiation can happen on constant
// value 2.0
// `x` will be differentiated as `*` is
// differentiable built-in operators
let v=x*2.0
// `u` and `v` will be differentiated as `+`
// is differentiable built-in operators
let w=u+v
// `w` will be differentiated as `bar`
// is differentiable
return w
}
Example Three: Tupletype value
// Within the scope of `multiply`, no differentiation
// can happen on `x` as it is in the except list
// Within the scope of `multiply`, `y` needs to be
// differentiated as it is NOT in the except list
@Differentiable [except: [x]]
func multiply (x:Float64 ,y:Float64 ){
return x*y
}
// Within the scope of `test`, no differentiation
// can happen on `x` as it is in the except list
// Within the scope of `test`, `y` needs to be
// differentiated as it is NOT in the except list
@Differentiable [except: [x]]
func test (x:Float64 ,y:Float64 ){
// `y` needs to be differentiated yet no differeniation
// can happend on `y` as it is depended by the `pair` where
// no differentiation can happen
let pair =(x, y)
// `pair[0]` needs to be differentiated, yet
// no differentiation can happen on `pair[1]`.
// thus eventually no differentiation can happend on `pair`
return multiply(pair[ 1],pair[ 0])
}
For the above example program, the compiler will emit the following error.
error: function test failed the differentiability check
error: expression y is marked for back-propagation, but is used in a context that cannot be
back-propagated ↪
error: error caused by y appearing in expression
let v2: Float64 = multiply(y, x)
error: consider including y in an except list
Example Four: function value in the argument or return value of a higher-order function
// Within the scope of `multiply`, no differentiation
// can happen on `x` as it is in the except list
// Within the scope of `multiply`, `y` needs to be
// differentiated as it is NOT in the except list
@Differentiable [except: [x]]
func multiply (x:Float64 ,y:Float64 ){
return x*y
}
// Within the scope of `duplicateArgument`, `f` needs to be
// differentiated as it is NOT in the except list
// Within the scope of `duplicateArgument`, `x` needs to be
// differentiated as it is NOT in the except list
@Differentiable
func duplicateArgument (f:(Float64 ,Float64 )->Float64 ,x:Float64 ):Float64 {
// `x` will be differentiated as `f`
// is differentiable and with empty
// `except` list by default
return f(x, x)
}
@Differentiable
func foo(x:Float64 ){
// `multiply` is differentiable and with
// `x` in its `except` list, yet it is passed
// to argument which should be differentiable
// and with a empty `except` list
return duplicateArgument(multiply, x)
}
For the above example program, the compiler will emit the following error.
error: function foo failed the differentiability check
error: function multiply has type (/*@except*/Float64*Float64->Float64),
which is required to be a subtype of (Float64*Float64->Float64)
error: conversion triggered by expression
let v0: Float64 = duplicateArgument(multiply, x)
error: consider modifying the except list of multiply
As mentioned above, the Except-Validity checking is to avoid variables that need to be differentiated are
used in the context where no differentiation can happen. However, in some situations, if user do want to
ignore some gradients, they can implement it by stopGradient API.
16.9 Example Code
@Differentiable [except: [size]]
struct Tensor {
let data :Float32
let size :Int32
init (data :Float32 ,size :Int32 ){
this .data =data
this .size =size
}
}
@Differentiable
func mul(input0 :Tensor, input1 :Tensor)
{
return input0.data *input1.data
}
@Adjoint [primal: mul]
func adjointMul (input0 :Tensor, input1 :Tensor)
{
return (
mul(input0, input1),
{sens :Float32 =>(
Tensor(sens *input1.data, input0.size),
Tensor(sens *input0.data, input1.size))
}
)
}
main() {
let input0 =Tensor( 1.0,1)
let input1 =Tensor( 2.0,1)
let gradient =@Grad (mul, input0, input1)
return 0
}Appendix A
Cangjie Grammar Summary
A.1 Lexical Grammar
A.1.1 Comments
DelimitedComment
: '/*' ( DelimitedComment | . )*? '*/'
;
LineComment
: '//' ~[\u000A\u000D]*
;
A.1.2 Whitespace and Newline
WS
: [\u0020\u0009\u000C]
;
NL: '\u000A' | '\u000D' '\u000A' ;
A.1.3 Symbols
DOT: '.' ;
COMMA: ',' ;
LPAREN: '(' ;
RPAREN: ')' ;
LSQUARE: '[' ;
RSQUARE: ']' ;
LCURL: '{' ;
RCURL: '}' ;
EXP: '**' ;
MUL: '*' ;
MOD: '%' ;
DIV: '/' ;
ADD: '+' ;
SUB: '-' ;
PIPELINE: '|>' ;
COMPOSITION: '~>' ;
INC: '++' ;
DEC: '--' ;
AND: '&&' ;
OR: '||' ;
NOT: '!' ;
BITAND: '&' ;
BITOR: '|' ;
BITXOR: '^' ;
LSHIFT: '<<' ;
RSHIFT: '>>' ;
COLON: ':' ;
SEMI: ';' ;
ASSIGN: '=' ;
ADD_ASSIGN: '+=' ;
SUB_ASSIGN: '-=' ;
MUL_ASSIGN: '*=' ;
EXP_ASSIGN: '**=' ;
DIV_ASSIGN: '/=' ;
MOD_ASSIGN: '%=' ;
AND_ASSIGN: '&&=' ;
OR_ASSIGN: '||=' ;
BITAND_ASSIGN: '&=' ;
BITOR_ASSIGN: '|=' ;
BITXOR_ASSIGN: '^=' ;
LSHIFT_ASSIGN: '<<=' ;
RSHIFT_ASSIGN: '>>=' ;
ARROW: '->' ;
BACKARROW: '<-' ;
DOUBLE_ARROW: '=>' ;
ELLIPSIS: '...' ;
CLOSEDRANGEOP: '..=' ;
RANGEOP: '..' ;
HASH: '#' ;
AT: '@' ;
QUEST: '?' ;
UPPERBOUND: '<:';
LT: '<' ;
GT: '>' ;
LE: '<=' ;
GE: '>=' ;
NOTEQUAL: '!=' ;
EQUAL: '==' ;
WILDCARD: '_' ;
BACKSLASH: '\\' ;
QUOTESYMBOL: '`';
DOLLAR: '$';
QUOTE_OPEN: '"' ;
TRIPLE_QUOTE_OPEN: '"""' NL;
QUOTE_CLOSE: '"' ;
TRIPLE_QUOTE_CLOSE: '"""' ;
LineStrExprStart: '${' ;
MultiLineStrExprStart: '${' ;
A.1.4 Keywords
INT8: 'Int8' ;
INT16: 'Int16' ;
INT32: 'Int32' ;
INT64: 'Int64' ;
INTNATIVE: 'IntNative' ;
UINT8: 'UInt8' ;
UINT16: 'UInt16' ;
UINT32: 'UInt32' ;
UINT64: 'UInt64' ;
UINTNATIVE: 'UIntNative' ;
FLOAT16: 'Float16' ;
FLOAT32: 'Float32' ;
FLOAT64: 'Float64' ;
CHAR: 'Rune' ;
BOOLEAN: 'Bool' ;
UNIT: 'Unit' ;
Nothing: 'Nothing' ;
STRUCT: 'struct' ;
ENUM: 'enum' ;
THISTYPE: 'This';
PACKAGE: 'package' ;
IMPORT: 'import' ;
CLASS: 'class' ;
INTERFACE: 'interface' ;
FUNC: 'func';
MAIN: 'main';
LET: 'let' ;
VAR: 'var' ;
TYPE_ALIAS: 'type' ;
INIT: 'init' ;
THIS: 'this' ;
SUPER: 'super' ;
IF: 'if' ;
ELSE: 'else' ;
CASE: 'case' ;
TRY: 'try' ;
CATCH: 'catch' ;
FINALLY: 'finally' ;
FOR: 'for' ;
DO: 'do' ;
WHILE: 'while' ;
THROW: 'throw' ;
RETURN: 'return' ;
CONTINUE: 'continue' ;
BREAK: 'break' ;
IS: 'is' ;
AS: 'as' ;
IN: 'in' ;
MATCH: 'match' ;
FROM: 'from' ;
WHERE: 'where';
EXTEND: 'extend';
SPAWN: 'spawn';
SYNCHRONIZED: 'synchronized';
MACRO: 'macro';
QUOTE: 'quote';
TRUE: 'true';
FALSE: 'false';
STATIC: 'static';
PUBLIC: 'public' ;
PRIVATE: 'private' ;
PROTECTED: 'protected' ;
OVERRIDE: 'override' ;
REDEF: 'redef' ;
ABSTRACT: 'abstract' ;
OPEN: 'open' ;
OPERATOR: 'operator' ;
FOREIGN: 'foreign';
INOUT: 'inout';
PROP: 'prop';
MUT: 'mut';
UNSAFE: 'unsafe';
GET: 'get';
SET: 'set';
A.1.5 Literals
IntegerLiteralSuffix
: 'i8' |'i16' |'i32' |'i64' |'u8' |'u16' |'u32' | 'u64'
;
IntegerLiteral
: BinaryLiteral IntegerLiteralSuffix?
| OctalLiteral IntegerLiteralSuffix?
| DecimalLiteral '_'* IntegerLiteralSuffix?
| HexadecimalLiteral IntegerLiteralSuffix?
;
BinaryLiteral
: '0' [bB] BinDigit (BinDigit | '_')*
;
BinDigit
: [01]
;
OctalLiteral
: '0' [oO] OctalDigit (OctalDigit | '_')*
;
OctalDigit
: [0-7]
;
DecimalLiteral
: (DecimalDigitWithOutZero (DecimalDigit | '_')*) | DecimalDigit
;
fragment DecimalFragment
: DecimalDigit (DecimalDigit | '_')*
;
fragment DecimalDigit
: [0-9]
;
fragment DecimalDigitWithOutZero
: [1-9]
;
HexadecimalLiteral
: '0' [xX] HexadecimalDigits
;
HexadecimalDigits
: HexadecimalDigit (HexadecimalDigit | '_')*
;
HexadecimalDigit
: [0-9a-fA-F]
;
FloatLiteralSuffix
: 'f16' | 'f32' | 'f64'
;
FloatLiteral
: (DecimalLiteral DecimalExponent | DecimalFraction DecimalExponent? | (DecimalLiteral
DecimalFraction) DecimalExponent?) FloatLiteralSuffix? ↪
| ( Hexadecimalprefix (HexadecimalDigits | HexadecimalFraction | (HexadecimalDigits
HexadecimalFraction)) HexadecimalExponent) ↪
;
fragment DecimalFraction : '.' DecimalFragment ;
fragment DecimalExponent : FloatE Sign? DecimalFragment ;
fragment Sign : [-] ;
fragment Hexadecimalprefix : '0' [xX] ;
DecimalFraction : '.' DecimalLiteral ;
DecimalExponent : FloatE Sign? DecimalLiteral ;
HexadecimalFraction : '.' HexadecimalDigits ;
HexadecimalExponent : FloatP Sign? DecimalFragment ;
FloatE : [eE] ;
FloatP : [pP] ;
Sign : [-] ;
Hexadecimalprefix : '0' [xX] ;
CharacterLiteral
: '\'' (SingleChar | EscapeSeq ) '\''
;
SingleChar
: ~['\\\r\n]
;
EscapeSeq
: UniCharacterLiteral
| EscapedIdentifier
;
UniCharacterLiteral
: '\\' 'u' '{' HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit HexadecimalDigit '}' ↪
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit
HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit '}' ↪
;
EscapedIdentifier
: '\\' ('t' | 'b' | 'r' | 'n' | '\'' | '"' | '\\' | 'f' | 'v' | '0' | '$')
;
CharacterByteLiteral
: 'b' '\'' (SingleCharByte | ByteEscapeSeq) '\''
;
ByteEscapeSeq
: HexCharByte
| ByteEscapedIdentifier
;
SingleCharByte
// ASCII 0x00~0x7F without \n \r \' \" \\
// +-------+-----+-----+
// | Rune | Hex | Dec |
// +-------+-----+-----+
// | \n | 0A | 10 |
// | \r | 0D | 13 |
// | \" | 22 | 34 |
// | \' | 27 | 39 |
// | \\ | 5C | 92 |
// +-------+-----+-----+
: [\u0000-\u0009\u000B\u000C\u000E-\u0021\u0023-\u0026\u0028-\u005B\u005D-\u007F]
;
fragment ByteEscapedIdentifier
: '\\' ('t' | 'b' | 'r' | 'n' | '\'' | '"' | '\\' | 'f' | 'v' | '0')
;
fragment HexCharByte
: '\\' 'u' '{' HexadecimalDigit '}'
| '\\' 'u' '{' HexadecimalDigit HexadecimalDigit '}'
;
ByteStringArrayLiteral
: 'b' '"' (SingleCharByte | ByteEscapeSeq)* '"'
;
JStringLiteral
: 'J' '"' (SingleChar | EscapeSeq)* '"'
;
LineStrText
: ~["\\\r\n]
| EscapeSeq
;
TRIPLE_QUOTE_CLOSE
: MultiLineStringQuote? '"""' ;
MultiLineStringQuote
: '"'+
;
MultiLineStrText
: ~('\\')
| EscapeSeq
;
MultiLineRawStringLiteral
: MultiLineRawStringContent
;
fragment MultiLineRawStringContent
: HASH MultiLineRawStringContent HASH
| HASH '"' .*? '"' HASH
;
A.1.6 Identifiers
identifier
: Identifier
| PUBLIC
| PRIVATE
| PROTECTED
| OVERRIDE
| ABSTRACT
| OPEN
| REDEF
| GET
| SET
;
Identifier
: '_'* Letter (Letter | '_' | DecimalDigit)*
| '`' '_'* Letter (Letter | '_' | DecimalDigit)* '`'
;
Letter
: [a-zA-Z]
;
DollarIdentifier
: '$' Identifier
;
A.2 Syntactic Grammar
A.2.1 T ranslation Unit
translationUnit
: NL* preamble end* topLevelObject* (end+ mainDefinition)? NL* (topLevelObject (end+
topLevelObject?)*)? EOF ↪
;
end
: NL | SEMI
;
A.2.2 Package Definition and Package Import
preamble
: packageHeader? importList*
;
packageHeader
: PACKAGE NL* packageNameIdentifier end+
;
packageNameIdentifier
: identifier (NL* DOT NL* identifier)*
;
importList
: (FROM NL* identifier)? NL* IMPORT NL* importAllOrSpecified
(NL* COMMA NL* importAllOrSpecified)* end+
;
importAllOrSpecified
: importAll
| importSpecified (NL* importAlias)?
;
importSpecified
: (identifier NL* DOT NL*)+ identifier
;
importAll
: (identifier NL* DOT NL*)+ MUL
;
importAlias
: AS NL* identifier
;
A.2.3 T op-Level Definitions
topLevelObject
: classDefinition
| interfaceDefinition
| functionDefinition
| variableDeclaration
| enumDefinition
| structDefinition
| typeAlias
| extendDefinition
| foreignDeclaration
| macroDefinition
| macroExpression
;
A.2.3.1 Class Definitions
classDefinition
: (classModifierList NL*)? CLASS NL* identifier
(NL* typeParameters NL*)?
(NL* UPPERBOUND NL* superClassOrInterfaces)?
(NL* genericConstraints)?
NL* classBody
;
superClassOrInterfaces
: superClass (NL* BITAND NL* superInterfaces)?
| superInterfaces
;
classModifierList
: classModifier+
;
classModifier
: PUBLIC
| ABSTRACT
| OPEN
;
typeParameters
: LT NL* identifier (NL* COMMA NL* identifier)* NL* GT
;
superClass
: classType
;
classType
: (identifier NL* DOT NL*)* identifier (NL* typeParameters)?
;
typeArguments
: LT NL* type (NL* COMMA NL* type)* NL* GT
;
superInterfaces
: interfaceType (NL* COMMA NL* interfaceType )*
;
interfaceType
: classType
;
genericConstraints
: WHERE NL* (identifier | THISTYPE) NL* UPPERBOUND NL* upperBounds (NL* COMMA NL* (identifier
| THISTYPE) NL* UPPERBOUND NL* upperBounds)* ↪
;
upperBounds
: userType (NL* BITAND NL* userType)*
;
classBody
: LCURL end*
classMemberDeclaration* NL*
classPrimaryInit? NL*
classMemberDeclaration* end* RCURL
;
classMemberDeclaration
: (classInit
| staticInit
| variableDeclaration
| functionDefinition
| operatorFunctionDefinition
| macroExpression
| propertyDefinition
) end*
;
classInit
: (classNonStaticMemberModifier NL*)? INIT NL* functionParameters NL* block
;
staticInit
: STATIC INIT LPAREN RPAREN
LCURL
expressionOrDeclarations?
RCURL
;
classPrimaryInit
: (classNonStaticMemberModifier NL*)? className NL* LPAREN NL*
classPrimaryInitParamLists
NL* RPAREN NL*
LCURL NL*
(SUPER callSuffix)? end
expressionOrDeclarations?
NL* RCURL
;
className
: identifier
;
classPrimaryInitParamLists
: unnamedParameterList (NL* COMMA NL* namedParameterList)? (NL* COMMA NL*
classNamedInitParamList)? ↪
| unnamedParameterList (NL* COMMA NL* classUnnamedInitParamList)? (NL* COMMA NL*
classNamedInitParamList)? ↪
| classUnnamedInitParamList (NL* COMMA NL* classNamedInitParamList)?
| namedParameterList (NL* COMMA NL* classNamedInitParamList)?
| classNamedInitParamList
;
classUnnamedInitParamList
: classUnnamedInitParam (NL* COMMA NL* classUnnamedInitParam)*
;
classNamedInitParamList
: classNamedInitParam (NL* COMMA NL* classNamedInitParam)*
;
classUnnamedInitParam
: (classNonSMemberModifier NL*)? (LET | VAR) NL* identifier NL* COLON NL* type
;
classNamedInitParam
: (classNonSMemberModifier NL*)? (LET | VAR) NL* identifier NL* NOT NL* COLON NL* type (NL*
ASSIGN NL* expression)? ↪
;
classNonStaticMemberModifier
: PUBLIC
| PRIVATE
| PROTECTED
;
A.2.3.2 Interface Definitions
interfaceDefinition
: (interfaceModifierList NL*)? INTERFACE NL* identifier
(NL* typeParameters NL*)?
(NL* UPPERBOUND NL* superInterfaces)?
(NL* genericConstraints)?
(NL* interfaceBody)
;
interfaceBody
: LCURL end* interfaceMemberDeclaration* end* RCURL
;
interfaceMemberDeclaration
: (functionDefinition
| operatorFunctionDefinition
| macroExpression
| propertyDefinition) end*
;
interfaceModifierList
: (interfaceModifier NL*)+
;
interfaceModifier
: PUBLIC
| OPEN
;
A.2.3.3 Function Definitions
functionDefinition
:(functionModifierList NL*)? FUNC
NL* identifier
(NL* typeParameters NL*)?
NL* functionParameters
(NL* COLON NL* type)?
(NL* genericConstraints)?
(NL* block)?
;
operatorFunctionDefinition
: (functionModifierList NL*)? OPERATOR NL* FUNC
NL* overloadedOperators
(NL* typeParameters NL*)?
NL* functionParameters
(NL* COLON NL* type)?
(NL* genericConstraints)?
(NL* block)?
;
functionParameters
: (LPAREN (NL* unnamedParameterList ( NL* COMMA NL* namedParameterList)? )?
NL* RPAREN NL*)
| (LPAREN NL* (namedParameterList NL*)? RPAREN NL*)
;
nondefaultParameterList
: unnamedParameter (NL* COMMA NL* unnamedParameter)*
(NL* COMMA NL* namedParameter)*
| namedParameter (NL* COMMA NL* namedParameter)*
;
unnamedParameterList
: unnamedParameter (NL* COMMA NL* unnamedParameter)*
;
unnamedParameter
: (identifier | WILDCARD) NL* COLON NL* type
;
namedParameterList
: (namedParameter | defaultParameter)
(NL* COMMA NL* (namedParameter | defaultParameter))*
;
namedParameter
: identifier NL* NOT NL* COLON NL* type
;
defaultParameter
: identifier NL* NOT NL* COLON NL* type NL* ASSIGN NL* expression
;
functionModifierList
: (functionModifier NL*)+
;
functionModifier
: PUBLIC
| PRIVATE
| PROTECTED
| STATIC
| OPEN
| OVERRIDE
| OPERATOR
| REDEF
| MUT
| UNSAFE
;
A.2.3.4 Variable Definitions
variableDeclaration
: variableModifier* NL* (LET | VAR) NL* patternsMaybeIrrefutable ( (NL* COLON NL* type)? (NL*
ASSIGN NL* expression) ↪
| (NL* COLON NL* type)
)
;
variableModifier
: PUBLIC
| PRIVATE
| PROTECTED
| STATIC
;
A.2.3.5 Enum Definitions
enumDefinition
: (enumModifier NL*)? ENUM NL* identifier (NL* typeParameters NL*)?
(NL* UPPERBOUND NL* superInterfaces)?
(NL* genericConstraints)? NL* LCURL end* enumBody end* RCURL
;
enumBody
: (BITOR NL*)? caseBody (NL* BITOR NL* caseBody)*
(NL*
( functionDefinition
| operatorFunctionDefinition
| propertyDefinition
| macroExpression
))*
;
caseBody
: identifier ( NL* LPAREN NL* type (NL* COMMA NL* type)* NL* RPAREN)?
;
enumModifier
: PUBLIC
;
A.2.3.6 Struct Definitions
structDefinition
: (structModifier NL*)? STRUCT NL* identifier (NL* typeParameters NL*)?
(NL* UPPERBOUND NL* superInterfaces)?
(NL* genericConstraints)? NL* structBody
;
structBody
: LCURL end*
structMemberDeclaration* NL*
structPrimaryInit? NL*
structMemberDeclaration*
end* RCURL
;
structMemberDeclaration
: (structInit
| staticInit
| variableDeclaration
| functionDefinition
| operatorFunctionDefinition
| macroExpression
| propertyDefinition
) end*
;
structInit
: (structNonStaticMemberModifier NL*)? INIT NL* functionParameters NL* block
;
staticInit
: STATIC INIT LPAREN RPAREN
LCURL
expressionOrDeclarations?
RCURL
;
structPrimaryInit
: (structNonStaticMemberModifier NL*)? structName NL* LPAREN NL*
structPrimaryInitParamLists? NL* RPAREN NL* ↪
LCURL NL*
expressionOrDeclarations?
NL* RCURL
;
structName
: identifier
;
structPrimaryInitParamLists
: unnamedParameterList (NL* COMMA NL* namedParameterList)? (NL* COMMA NL*
structNamedInitParamList)? ↪
| unnamedParameterList (NL* COMMA NL* structUnnamedInitParamList)? (NL* COMMA NL*
structNamedInitParamList)? ↪
| structUnnamedInitParamList (NL* COMMA NL* structNamedInitParamList)?
| namedParameterList (NL* COMMA NL* structNamedInitParamList)?
| structNamedInitParamList
;
structUnnamedInitParamList
: structUnnamedInitParam (NL* COMMA NL* structUnnamedInitParam)*
;
structNamedInitParamList
: structNamedInitParam (NL* COMMA NL* structNamedInitParam)*
;
structUnnamedInitParam
: (structNonStaticMemberModifier NL*)? (LET | VAR) NL* identifier NL* COLON NL* type
;
structNamedInitParam
: (structNonStaticMemberModifier NL*)? (LET | VAR) NL* identifier NL* NOT NL* COLON NL* type
(NL* ASSIGN NL* expression)? ↪
;
structModifier
: PUBLIC
;
structNonStaticMemberModifier
: PUBLIC
| PRIVATE
;
A.2.3.7 Typealias Definitions
typeAlias
: (typeModifier NL*)? TYPE_ALIAS NL* identifier (NL* typeParameters)? NL* ASSIGN NL* type end*
;
typeModifier
: PUBLIC
;
A.2.3.8 Extension Definitions
extendDefinition
: EXTEND NL* extendType
(NL* UPPERBOUND NL* superInterfaces)? (NL* genericConstraints)?
NL* extendBody
;
extendType
: (identifier NL* DOT NL*)* identifier (NL* typeParameters)?
| INT8
| INT16
| INT32
| INT64
| INTNATIVE
| UINT8
| UINT16
| UINT32
| UINT64
| UINTNATIVE
| FLOAT16
| FLOAT32
| FLOAT64
| CHAR
| BOOLEAN
| NOTHING
| UNIT
;
extendBody
: LCURL end* extendMemberDeclaration* end* RCURL
;
extendMemberDeclaration
: (functionDefinition
| operatorFunctionDefinition
| macroExpression
| propertyDefinition
) end*
;
A.2.3.9 Foreign Declarations
foreignDeclaration
: FOREIGN NL* (foreignBody | foreignMemberDeclaration)
;
foreignBody
: LCURL end* foreignMemberDeclaration* end* RCURL
;
foreignMemberDeclaration
: (classDefinition
| interfaceDefinition
| functionDefinition
| macroExpression
| variableDeclaration) end*
;
A.2.3.10 Macro Declarations
macroDefinition
: PUBLIC NL* MACRO NL* identifier NL*
(macroWithoutAttrParam | macroWithAttrParam) NL*
(COLON NL* identifier NL*)?
(ASSIGN NL* expression | block)
;
macroWithoutAttrParam
: LPAREN NL* macroInputDecl NL* RPAREN
;
macroWithAttrParam
: LPAREN NL* macroAttrDecl NL* COMMA NL* macroInputDecl NL* RPAREN
;
macroInputDecl
: identifier NL* COLON NL* identifier
;
macroAttrDecl
: identifier NL* COLON NL* identifier
;
A.2.3.11 Properties Definitions
propertyDefinition
: propertyModifier* NL* PROP NL* identifier NL* COLON NL* type NL* propertyBody?
;
propertyBody
: LCURL end* propertyMemberDeclaration+ end* RCURL
;
propertyMemberDeclaration
: GET NL* LPAREN RPAREN NL* block end*
| SET NL* LPAREN identifier RPAREN NL* block end*
;
propertyModifier
: PUBLIC
| PRIVATE
| PROTECTED
| STATIC
| OPEN
| OVERRIDE
| REDEF
| MUT
;
A.2.3.12 Program Entry Point Definitions
mainDefinition
: MAIN
NL* functionParameters
(NL* COLON NL* type)?
NL* block
;
A.2.4 Types
type
: arrowType
| tupleType
| prefixType
| atomicType
;
arrowType
: arrowParameters NL* ARROW NL* type
;
arrowParameters
: LPAREN NL* (type (NL* COMMA NL* type)* NL*)? RPAREN
;
tupleType
: LPAREN NL* type (NL* COMMA NL* type)+ NL* RPAREN
;
prefixType
: prefixTypeOperator type
;
prefixTypeOperator
: QUEST
;
atomicType
: charLangTypes
| userType
| parenthesizedType
;
charLangTypes
: numericTypes
| CHAR
| BOOLEAN
| Nothing
| UNIT
| THISTYPE
;
numericTypes
: INT8
| INT16
| INT32
| INT64
| INTNATIVE
| UINT8
| UINT16
| UINT32
| UINT64
| UINTNATIVE
| FLOAT16
| FLOAT32
| FLOAT64
;
userType
: (identifier NL* DOT NL*)* identifier ( NL* typeArguments)?
;
parenthesizedType
: LPAREN NL* type NL* RPAREN
;
A.2.5 Expressions Syntax
expression
: assignmentExpression
;
assignmentExpression
: leftValueExpressionWithoutWildCard NL* assignmentOperator NL* flowExpression
| leftValueExpression NL* ASSIGN NL* flowExpression
| tupleLeftValueExpression NL* ASSIGN NL* flowExpression
| flowExpression
;
tupleLeftValueExpression
: LPAREN NL* (leftValueExpression | tupleLeftValueExpression) (NL* COMMA NL*
(leftValueExpression | tupleLeftValueExpression))+ NL* COMMA? NL* RPAREN ↪
;
leftValueExpression
: leftValueExpressionWithoutWildCard
| WILDCARD
;
leftValueExpressionWithoutWildCard
: identifier
| leftAuxExpression QUEST? NL* assignableSuffix
;
leftAuxExpression
: identifier (NL* typeArguments)?
| type
| thisSuperExpression
| leftAuxExpression QUEST? NL* DOT NL* identifier (NL* typeArguments)?
| leftAuxExpression QUEST? callSuffix
| leftAuxExpression QUEST? indexAccess
;
assignableSuffix
: fieldAccess
| indexAccess
;
fieldAccess
: NL* DOT NL* identifier
;
flowExpression
: coalescingExpression (NL* flowOperator NL* coalescingExpression)*
;
coalescingExpression
: logicDisjunctionExpression (NL* QUEST QUEST NL* logicDisjunctionExpression)*
;
logicDisjunctionExpression
: logicConjunctionExpression (NL* OR NL* logicConjunctionExpression)*
;
logicConjunctionExpression
: rangeExpression (NL* AND NL* rangeExpression)*
;
rangeExpression
: bitwiseDisjunctionExpression NL* (CLOSEDRANGEOP | RANGEOP) NL*
bitwiseDisjunctionExpression (NL* COLON NL* bitwiseDisjunctionExpression)? ↪
| bitwiseDisjunctionExpression
;
bitwiseDisjunctionExpression
: bitwiseXorExpression (NL* BITOR NL* bitwiseXorExpression)*
;
bitwiseXorExpression
: bitwiseConjunctionExpression (NL* BITXOR NL* bitwiseConjunctionExpression)*
;
bitwiseConjunctionExpression
: equalityComparisonExpression (NL* BITAND NL* equalityComparisonExpression)*
;
equalityComparisonExpression
: comparisonOrTypeExpression (NL* equalityOperator NL* comparisonOrTypeExpression)?
;
comparisonOrTypeExpression
: shiftingExpression (NL* comparisonOperator NL* shiftingExpression)?
| shiftingExpression (NL* IS NL* type)?
| shiftingExpression (NL* AS NL* type)?
;
shiftingExpression
: additiveExpression (NL* shiftingOperator NL* additiveExpression)*
;
additiveExpression
: multiplicativeExpression (NL* additiveOperator NL* multiplicativeExpression)*
;
multiplicativeExpression
: exponentExpression (NL* multiplicativeOperator NL* exponentExpression)*
;
exponentExpression
: prefixUnaryExpression (NL* exponentOperator NL* prefixUnaryExpression)*
;
prefixUnaryExpression
: prefixUnaryOperator* incAndDecExpression
;
incAndDecExpression
: postfixExpression (INC | DEC )?
;
postfixExpression
: atomicExpression
| type NL* DOT NL* identifier
| postfixExpression NL* DOT NL* identifier (NL* typeArguments)?
| postfixExpression callSuffix
| postfixExpression indexAccess
| postfixExpression NL* DOT NL* identifier callSuffix? trailingLambdaExpression
| identifier callSuffix? trailingLambdaExpression
| postfixExpression (QUEST questSeperatedItems)+
;
questSeperatedItems
: questSeperatedItem+
;
questSeperatedItem
: itemAfterQuest (callSuffix | callSuffix? trailingLambdaExpression | indexAccess)?
;
itemAfterQuest
: DOT identifier (NL* typeArguments)?
| callSuffix
| indexAccess
| trailingLambdaExpression
;
callSuffix
: LPAREN NL* (valueArgument (NL* COMMA NL* valueArgument)* NL*)? RPAREN
;
valueArgument
: identifier NL* COLON NL* expression
| expression
| refTransferExpression
;
refTransferExpression
: INOUT (expression DOT)? identifier
;
indexAccess
: LSQUARE NL* (expression | rangeElement) NL* RSQUARE
;
rangeElement
: RANGEOP
| ( CLOSEDRANGEOP | RANGEOP ) NL* expression
| expression NL* RANGEOP
;
atomicExpression
: literalConstant
| collectionLiteral
| tupleLiteral
| identifier (NL* typeArguments)?
| unitLiteral
| ifExpression
| matchExpression
| loopExpression
| tryExpression
| jumpExpression
| numericTypeConvExpr
| thisSuperExpression
| spawnExpression
| synchronizedExpression
| parenthesizedExpression
| lambdaExpression
| quoteExpression
| macroExpression
| unsafeExpression
;
literalConstant
: IntegerLiteral
| FloatLiteral
| CharacterLiteral
| CharacterByteLiteral
| booleanLiteral
| stringLiteral
| ByteStringArrayLiteral
| unitLiteral
;
booleanLiteral
: TRUE
| FALSE
;
stringLiteral
: lineStringLiteral
| multiLineStringLiteral
| MultiLineRawStringLiteral
;
lineStringContent
: LineStrText
;
lineStringLiteral
: QUOTE_OPEN (lineStringExpression | lineStringContent)* QUOTE_CLOSE
;
lineStringExpression
: LineStrExprStart SEMI* (expressionOrDeclaration (SEMI+ expressionOrDeclaration?)*) SEMI*
RCURL ↪
;
multiLineStringContent
: MultiLineStrText
;
multiLineStringLiteral
: TRIPLE_QUOTE_OPEN (multiLineStringExpression | multiLineStringContent)* TRIPLE_QUOTE_CLOSE
;
multiLineStringExpression
: MultiLineStrExprStart end* (expressionOrDeclaration (end+ expressionOrDeclaration?)*) end*
RCURL ↪
;
collectionLiteral
: arrayLiteral
;
arrayLiteral
: LSQUARE (NL* elements)? NL* RSQUARE
;
elements
: element ( NL* COMMA NL* element )*
;
element
: expressionElement
| spreadElement
;
expressionElement
: expression
;
spreadElement
: MUL expression
;
tupleLiteral
: LPAREN NL* expression (NL* COMMA NL*expression)+ NL* RPAREN
;
unitLiteral
: LPAREN NL* RPAREN
;
ifExpression
: IF NL* LPAREN NL* (LET NL* deconstructPattern NL* BACKARROW NL*)? expression NL* RPAREN NL*
block ↪
(NL* ELSE (NL* ifExpression | NL* block))?
;
deconstructPattern
: constantPattern
| wildcardPattern
| varBindingPattern
| tuplePattern
| enumPattern
;
matchExpression
: MATCH NL* LPAREN NL* expression NL* RPAREN NL* LCURL NL* matchCase+ NL* RCURL
| MATCH NL* LCURL NL* (CASE NL* (expression | WILDCARD) NL* DOUBLE_ARROW NL*
expressionOrDeclaration (end+ expressionOrDeclaration?)*)+ NL* RCURL ↪
;
matchCase
: CASE NL* pattern NL* patternGuard? NL* DOUBLE_ARROW NL* expressionOrDeclaration (end+
expressionOrDeclaration?)* ↪
;
patternGuard
: WHERE NL* expression
;
pattern
: constantPattern
| wildcardPattern
| varBindingPattern
| tuplePattern
| typePattern
| enumPattern
;
constantPattern
: literalConstant NL* ( NL* BITOR NL* literalConstant)*
;
wildcardPattern
: WILDCARD
;
varBindingPattern
: identifier
;
tuplePattern
: LPAREN NL* pattern (NL* COMMA NL* pattern)+ NL* RPAREN
;
typePattern
: (WILDCARD | identifier) NL* COLON NL* type
;
enumPattern
: NL* ((userType NL* DOT NL*)? identifier enumPatternParameters?) (NL* BITOR NL* ((userType
NL* DOT NL*)? identifier enumPatternParameters?))* ↪
;
enumPatternParameters
: LPAREN NL* pattern (NL* COMMA NL* pattern)* NL* RPAREN
;
loopExpression
: forInExpression
| whileExpression
| doWhileExpression
;
forInExpression
: FOR NL* LPAREN NL* patternsMaybeIrrefutable NL* IN NL* expression NL* patternGuard? NL*
RPAREN NL* block ↪
;
patternsMaybeIrrefutable
: wildcardPattern
| varBindingPattern
| tuplePattern
| enumPattern
;
whileExpression
: WHILE NL* LPAREN NL* (LET NL* deconstructPattern NL* BACKARROW NL*)? expression NL* RPAREN
NL* block ↪
;
doWhileExpression
: DO NL* block NL* WHILE NL* LPAREN NL* expression NL* RPAREN
;
tryExpression
: TRY NL* block NL* FINALLY NL* block
| TRY NL* block (NL* CATCH NL* LPAREN NL* catchPattern NL* RPAREN NL* block)+ (NL* FINALLY
NL* block)? ↪
| TRY NL* LPAREN NL* resourceSpecifications NL* RPAREN NL* block
(NL* CATCH NL* LPAREN NL* catchPattern NL* RPAREN NL* block)* (NL* FINALLY NL* block)?
;
catchPattern
: wildcardPattern
| exceptionTypePattern
;
exceptionTypePattern
: (WILDCARD | identifier) NL* COLON NL* type (NL* BITOR NL* type)*
;
resourceSpecifications
: resourceSpecification (NL* COMMA NL* resourceSpecification)*
;
resourceSpecification
: identifier (NL* COLON NL* classType)? NL* ASSIGN NL* expression
;
jumpExpression
: THROW NL* expression
| RETURN (NL* expression)?
| CONTINUE
| BREAK
;
numericTypeConvExpr
: numericTypes LPAREN NL* expression NL* RPAREN
;
thisSuperExpression
: THIS
| SUPER
;
lambdaExpression
: LCURL NL* lambdaParameters? NL* DOUBLE_ARROW NL* expressionOrDeclarations? RCURL
;
trailingLambdaExpression
: LCURL NL* (lambdaParameters? NL* DOUBLE_ARROW NL*)? expressionOrDeclarations? RCURL
;
lambdaParameters
: lambdaParameter (NL* COMMA NL* lambdaParameter)*
;
lambdaParameter
: (identifier | WILDCARD) (NL* COLON NL* type)?
;
spawnExpression
: SPAWN NL* trailingLambdaExpression
;
synchronizedExpression
: SYNCHRONIZED LPAREN NL* identifier NL* RPAREN NL* block
;
parenthesizedExpression
: LPAREN NL* expression NL* RPAREN
;
block
: LCURL expressionOrDeclarations RCURL
;
unsafeExpression
: UNSAFE NL* block
;
expressionOrDeclarations
: end* (expressionOrDeclaration (end+ expressionOrDeclaration?)*)?
;
expressionOrDeclaration
: expression
| varOrfuncDeclaration
;
varOrfuncDeclaration
: functionDefinition
| variableDeclaration
;
quoteExpression
: QUOTE quoteExpr
;
quoteExpr
: LPAREN NL* quoteParameters NL* RPAREN
;
quoteParameters
: (NL* quoteToken | NL* quoteInterpolate | NL* macroExpression)+
;
quoteToken
: DOT | COMMA | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURL | RCURL | EXP | MUL | MOD | DIV |
ADD | SUB ↪
| PIPELINE | COMPOSITION
| INC | DEC | AND | OR | NOT | BITAND | BITOR | BITXOR | LSHIFT | RSHIFT | COLON | SEMI
| ASSIGN | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | EXP_ASSIGN | DIV_ASSIGN | MOD_ASSIGN
| AND_ASSIGN | OR_ASSIGN | BITAND_ASSIGN | BITOR_ASSIGN | BITXOR_ASSIGN | LSHIFT_ASSIGN |
RSHIFT_ASSIGN ↪
| ARROW | BACKARROW | DOUBLE_ARROW | ELLIPSIS | CLOSEDRANGEOP | RANGEOP | HASH | AT | QUEST |
UPPERBOUND | LT | GT | LE | GE ↪
| NOTEQUAL | EQUAL | WILDCARD | BACKSLASH | QUOTESYMBOL | DOLLAR
| INT8 | INT16 | INT32 | INT64 | INTNATIVE | UINT8 | UINT16 | UINT32 | UINT64 | UINTNATIVE |
FLOAT16 ↪
| FLOAT32 | FLOAT64 | CHAR | BOOL | UNIT | NOTHING | STRUCT | ENUM | THIS
| PACKAGE | IMPORT | CLASS | INTERFACE | FUNC | LET | VAR | TYPE
| INIT | THIS | SUPER | IF | ELSE | CASE | TRY | CATCH | FINALLY
| FOR | DO | WHILE | THROW | RETURN | CONTINUE | BREAK | AS | IN
| MATCH | FROM | WHERE | EXTEND | SPAWN | SYNCHRONIZED | MACRO | QUOTE | TRUE | FALSE
| STATIC | PUBLIC | PRIVATE | PROTECTED
| OVERRIDE | ABSTRACT | OPEN | OPERATOR | FOREIGN
| Identifier | DollarIdentifier
| literalConstant
;
quoteInterpolate
: DOLLAR LPAREN NL* expression NL* RPAREN
;
macroExpression
: AT Identifier macroAttrExpr? NL* (macroInputExprWithoutParens | macroInputExprWithParens)
;
macroAttrExpr
: LSQUARE NL* quoteToken* NL* RSQUARE
;
macroInputExprWithoutParens
: functionDefinition
| operatorFunctionDefinition
| staticInit
| structDefinition
| structPrimaryInit
| structInit
| enumDefinition
| caseBody
| classDefinition
| classPrimaryInit
| classInit
| interfaceDefinition
| variableDeclaration
| propertyDefinition
| extendDefinition
| macroExpression
;
macroInputExprWithParens
: LPAREN NL* macroTokens NL* RPAREN
;
macroTokens
: (quoteToken | macroExpression)*
;
assignmentOperator
: ASSIGN
| ADD_ASSIGN
| SUB_ASSIGN
| EXP_ASSIGN
| MUL_ASSIGN
| DIV_ASSIGN
| MOD_ASSIGN
| AND_ASSIGN
| OR_ASSIGN
| BITAND_ASSIGN
| BITOR_ASSIGN
| BITXOR_ASSIGN
| LSHIFT_ASSIGN
| RSHIFT_ASSIGN
;
equalityOperator
: NOTEQUAL
| EQUAL
;
comparisonOperator
: LT
| GT
| LE
| GE
;
shiftingOperator
: LSHIFT | RSHIFT
;
flowOperator
: PIPELINE | COMPOSITION
;
additiveOperator
: ADD | SUB
;
exponentOperator
: EXP
;
multiplicativeOperator
: MUL
| DIV
| MOD
;
prefixUnaryOperator
: SUB
| NOT
;
overloadedOperators
: LSQUARE RSQUARE
| INC
| DEC
| NOT
| ADD
| SUB
| EXP
| MUL
| DIV
| MOD
| LSHIFT
| RSHIFT
| LT
| GT
| LE
| GE
| EQUAL
| NOTEQUAL
| BITAND
| BITXOR
| BITOR
| AND
| OR
;