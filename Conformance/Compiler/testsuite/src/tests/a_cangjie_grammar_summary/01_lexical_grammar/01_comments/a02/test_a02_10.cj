
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 * 
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Name:        A_01_01_a02_10

  @Level:         1
  @Assertion:   A.1.1(2)
                LineComment
                    : '//' ~[\u000A\u000D]*
                    ;
  @Description: Check line comment syntax
  @Comment:     Auto-generated tests by gen_comments_tests_a02.py with seed = 1
  @Mode:        run
  @Negative:    no
  @Structure:   single
*/
import utils.assert.Assert

main() { //Moment { while loop; if the class does not modified, and wait for details •redefmeans redefine the process of two operator needs to the scope starts after the type names For example, a pair of the super class D<T>where T <: I1 & Tr } }catch (e:ArrayIndexOutOfBoundsException) { i+=1 g() //
  var t1: Int64 = 123 //f3():Item } No other than the preceding class Child <:Base { } } The syntax of a lambda type, the implementor to define operator function; if ; t1 = 321
  Assert.equals(123, t1)
  return 0
}

//e.g c.f(...) , it is only if the current declaration or the subinterface (and therefore no catch block) Each operation in JavaScript variable outside the current ‘thread’ sleep for the imported and way can have accessibility of type being imported by Tr, it and no function call with a static func f3():Unit
