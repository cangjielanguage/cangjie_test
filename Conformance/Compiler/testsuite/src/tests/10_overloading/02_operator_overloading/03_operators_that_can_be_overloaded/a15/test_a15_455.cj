
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 * 
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Name:        10_02_03_a15_455

  @Level:         1

  @Assertion:   10.2.3(15) 2. Once the two binary operators other than the relational operators <, <=, >, >=, == and
                !=) are overloaded on a certain type, and the return type of the operator function is the same as or a
                subtype of the type of the left operator, then the corresponding compound assignment symbol can be
                naturally used on this type. However, if the type of the return value of the operator function is not
                the same as nor the subtype of the type of the left operand, a type mismatch error is generated when
                using the corresponding compound assignment symbol on this type.
  @Description: Checks that if overloaded operator << for type K with argument type T has 
                return type A, then compound assignment operator <<= cannot be
                used with types K and T.
  @Mode: compileonly
  @Negative: yes
  @Structure: single
  @CompileWarning: no
  @Comment: Auto-generated by gen.py

*/

open class A <: J {
    public operator func <<(x : Unit) { A() }
}

open class B <: A {}

open class C <: B {}

open class D <: A {}

interface I {}

interface J <: I {}

interface K <: J {
    operator func <<(x : Unit) : A
}

interface L <: I {}

open class CI <: I {
    public operator func <<(x : Unit) { A() }
}

open class CJ <: J {
    public operator func <<(x : Unit) { A() }
}

open class CK <: K {
    public operator func <<(x : Unit) { A() }
    static func k() : K { CK() }
}

open class CL <: L {
    public operator func <<(x : Unit) { A() }
}

main() {
    var a = CK.k()
    a <<= ()

    return 0
}
