
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 * 
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Name:        10_02_03_a18_001

  @Level:         1

  @Assertion:   10.2.3(18)  5. For a type T, if T already supports some of the above operators that can be overloaded
                by default, then implementing the operator function with the same signature for T by extension will
                result in a redefinition error. For example, a redefinition error is reported when overloading a
                supported operator with the same signature such as an arithmetic operator, bitwise operator or
                relational operator for a numeric type, or overloading a relational operator with the same signature
                for the Rune type, or overloading a same signatured logical, equal or unequal operator for the Bool
                type, etc. 
  @Description: Checks some operators that can be overloaded for integral types
  @Mode: run
  @Negative: no
  @Structure: single
  @CompileWarning: ignore
  @Comment: Auto-generated by gen.py

*/

type Tuple = (Int64, Int64)

type Array = Array<Int64>

type Range = Range<Int64>

class C {
    let x : Int64

    init(y : Int64) { x = y }

    operator func ==(other : C) { x == other.x }
}

struct S {
    let x : Int64

    init(y : Int64) { x = y }

    operator func ==(other : S) { x == other.x }
}

extend Int8 {
    operator func >(x: C) { }

    operator func %(x: Unit) { }

    operator func <(x: C) { }

    operator func +(x: Int16) { }

    operator func ^(x: Int32) { }

    operator func !=(x: Array) { }

    operator func <(x: UInt64) { }

    operator func >(x: Unit) { }

    operator func /(x: UInt8) { }

    operator func ==(x: Float64) { }
}

extend Int16 {
    operator func !=(x: Float32) { }

    operator func >=(x: Range) { }

    operator func <(x: Float32) { }

    operator func <(x: UInt8) { }

    operator func ^(x: Tuple) { }

    operator func -(x: Float64) { }

    operator func |(x: UInt64) { }
}

extend Int32 {
    operator func -(x: Tuple) { }

    operator func ^(x: UInt16) { }

    operator func *(x: Array) { }

    operator func ==(x: Float16) { }

    operator func >=(x: Int64) { }

    operator func <(x: C) { }
}

extend Int64 {
    operator func -(x: Float32) { }

    operator func <=(x: Int16) { }
}

extend UInt8 {
    operator func <<(x: Float32) { }

    operator func /(x: Float32) { }

    operator func *(x: Int32) { }

    operator func !=(x: S) { }

    operator func >(x: Float32) { }

    operator func +(x: Float16) { }
}

extend UInt16 {
    operator func >(x: Unit) { }

    operator func -(x: Array) { }

    operator func /(x: Tuple) { }

    operator func &(x: Unit) { }

    operator func |(x: UInt32) { }

    operator func &(x: Int32) { }

    operator func <(x: Range) { }

    operator func &(x: UInt32) { }

    operator func >>(x: Unit) { }

    operator func *(x: Tuple) { }
}

extend UInt32 {
    operator func +(x: C) { }

    operator func <(x: Float16) { }

    operator func %(x: UInt64) { }

    operator func !=(x: Array) { }

    operator func |(x: UInt16) { }

    operator func >(x: Unit) { }
}

extend UInt64 {
    operator func *(x: UInt32) { }

    operator func |(x: Float64) { }

    operator func ^(x: UInt8) { }

    operator func <(x: S) { }

    operator func !=(x: UInt32) { }

    operator func %(x: Int16) { }
}

extend Float16 {
    operator func <<(x: S) { }

    operator func !=(x: Int16) { }

    operator func <(x: Array) { }

    operator func %(x: Int32) { }

    operator func *(x: Range) { }

    operator func <<(x: Float64) { }

    operator func -(x: Int64) { }

    operator func <<(x: Tuple) { }

    operator func <=(x: Float64) { }

    operator func %(x: Int64) { }

    operator func !() { }
}

extend Float32 {
    operator func /(x: UInt32) { }

    operator func <=(x: UInt32) { }

    operator func <=(x: S) { }

    operator func ==(x: Float64) { }

    operator func <=(x: UInt64) { }

    operator func -(x: Int8) { }

    operator func >>(x: C) { }

    operator func *(x: UInt8) { }

    operator func !() { }
}

extend Float64 {
    operator func <(x: Int32) { }

    operator func |(x: Float32) { }

    operator func >(x: Tuple) { }

    operator func %(x: Float32) { }

    operator func !=(x: Tuple) { }

    operator func >=(x: C) { }

    operator func !() { }
}

extend String {
    operator func *(x: Float32) { }

    operator func %(x: Int8) { }

    operator func <=(x: UInt16) { }

    operator func *(x: Int8) { }

    operator func ==(x: Int16) { }

    operator func %(x: C) { }

    operator func !() { }

    operator func -() { }
}

extend Rune {
    operator func &(x: Float32) { }

    operator func <<(x: Float64) { }

    operator func >(x: Int8) { }

    operator func <(x: C) { }

    operator func %(x: Float32) { }

    operator func |(x: Float32) { }

    operator func |(x: S) { }

    operator func >>(x: UInt16) { }

    operator func !() { }

    operator func -() { }
}

extend Bool {
    operator func *(x: Float64) { }

    operator func ==(x: Range) { }

    operator func >=(x: Float64) { }

    operator func ==(x: Int16) { }

    operator func !=(x: UInt32) { }

    operator func !=(x: Int64) { }

    operator func >(x: Float32) { }

    operator func |(x: Tuple) { }

    operator func ^(x: UInt16) { }

    operator func -() { }
}

main() {1i8 > C(1)
    1u8 << 1.0f32
    1i16 != 1.0f32
    r'1' & 1.0f32
    1u32 + C(1)
    1u8 / 1.0f32
    1i16 >= (1..2)
    true * 1.0f64
    1i8 % ()
    1u32 < 1.0f16
    1.0f16 << S(1)
    1.0f32 / 1u32
    1u16 > ()
    1u16 - [1]
    true == (1..2)
    1i8 < C(1)
    1i32 - (1, 1)
    1i32 ^ 1u16
    1u16 / (1, 1)
    1.0f32 <= 1u32
    1u16 & ()
    "1" * 1.0f32
    1u8 * 1i32
    1i32 * [1]
    1i8 + 1i16
    1u64 * 1u32
    r'1' << 1.0f64
    1i16 < 1.0f32
    1.0f32 <= S(1)
    1u32 % 1u64
    1i16 < 1u8
    1i8 ^ 1i32
    1u16 | 1u32
    r'1' > 1i8
    1u64 | 1.0f64
    1i16 ^ (1, 1)
    1i8 != [1]
    1i16 - 1.0f64
    "1" % 1i8
    1i32 == 1.0f16
    1i32 >= 1i64
    r'1' < C(1)
    1i8 < 1u64
    1u8 != S(1)
    1u64 ^ 1u8
    1.0f32 == 1.0f64
    1.0f16 != 1i16
    1u8 > 1.0f32
    1u64 < S(1)
    true >= 1.0f64
    1i8 > ()
    r'1' % 1.0f32
    1u16 & 1i32
    1u16 < (1..2)
    1.0f16 < [1]
    true == 1i16
    1.0f16 % 1i32
    1i64 - 1.0f32
    true != 1u32
    1.0f64 < 1i32
    1.0f64 | 1.0f32
    1.0f16 * (1..2)
    1.0f32 <= 1u64
    true != 1i64
    1u16 & 1u32
    1i8 / 1u8
    1u32 != [1]
    r'1' | 1.0f32
    1.0f64 > (1, 1)
    1.0f16 << 1.0f64
    1u64 != 1u32
    "1" <= 1u16
    1.0f32 - 1i8
    1.0f64 % 1.0f32
    r'1' | S(1)
    "1" * 1i8
    1.0f32 >> C(1)
    true > 1.0f32
    1.0f16 - 1i64
    1.0f16 << (1, 1)
    "1" == 1i16
    1u64 % 1i16
    1u32 | 1u16
    1.0f16 <= 1.0f64
    1i8 == 1.0f64
    true | (1, 1)
    r'1' >> 1u16
    1.0f64 != (1, 1)
    1i64 <= 1i16
    "1" % C(1)
    true ^ 1u16
    1i16 | 1u64
    1.0f16 % 1i64
    1.0f64 >= C(1)
    1u8 + 1.0f16
    1i32 < C(1)
    1u16 >> ()
    1u16 * (1, 1)
    1.0f32 * 1u8
    1u32 > ()
    !1.0f16
    !1.0f32
    !1.0f64
    !"1"
    !r'1'
    -"1"
    -r'1'
    -true
}
