// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// automatically generated by the FlatBuffers compiler, do not modify
// This source file is part of the Cangjie project.

package std.ast

import std.collection.ArrayList
public import std.collection.ArrayList

@!APILevel[12, atomicservice : true]
public class NodeFormat_MatchCase <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MatchCaseOther <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Pattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ConstPattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_WildcardPattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VarPattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ExceptTypePattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TypePattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_EnumPattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VarOrEnumPattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TuplePattern <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_BinaryExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_IsExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_AsExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_UnaryExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_WildcardExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ArrayExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ParenExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_LitConstExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncArg <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_CallExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_RefExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ReturnExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_AssignExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MemberAccess <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_IfExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_LetPatternDestructor <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_LambdaExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ArrayLit <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TupleLit <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_SubscriptExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MatchExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_RangeExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ForInExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_WhileExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_AdjointExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_GradExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ValWithGradExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VJPExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_SpawnExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_SynchronizedExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TrailingClosureExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TypeConvExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ThrowExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TryExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_DoWhileExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_IncOrDecExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_OptionalExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_OptionalChainExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Token <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TokenPart <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_QuoteExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Reference <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncParamList <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncParam <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncBody <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_JumpExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Expr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_PrimitiveTypeExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TypeBase <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_RefType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_PrimitiveType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ThisType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ParenType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_QualifiedType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_OptionType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TupleType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VArrayType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ConstantType <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Type <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VarDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_VarWithPatternDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_FuncDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MainDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MacroDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_StructBody <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_StructDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ClassBody <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ClassDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_InterfaceBody <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_InterfaceDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_EnumDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_GenericParamDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_PrimaryCtorDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_PropDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_GenericConstraint <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Generic <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Annotation <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Modifier <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_DeclBase <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_TypeAliasDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ExtendDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Decl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Block <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MacroInvocation <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MacroExpandExpr <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MacroExpandDecl <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_MacroExpandParam <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_File <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_PackageSpec <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ImportContent <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_ImportSpec <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_NodeBase <: FlatBufferObject {
}

@!APILevel[12, atomicservice : true]
public class NodeFormat_Node <: FlatBufferObject {
}

/**
* Return true if two tokens are considered equal somehow(exclude NL, END and position info).
*/
@!APILevel[12, atomicservice : true]
public func compareTokens(tokens1: Tokens, tokens2: Tokens): Bool

@!APILevel[12, atomicservice : true]
public open class Decl <: Node {
    @!APILevel[12, atomicservice : true]
    public open mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop annotations: ArrayList<Annotation>
    
    @!APILevel[12, atomicservice : true]
    public mut prop modifiers: ArrayList<Modifier>
    
    @!APILevel[12, atomicservice : true]
    public mut prop genericParam: GenericParam
    
    @!APILevel[12, atomicservice : true]
    public mut prop genericConstraint: ArrayList<GenericConstraint>
    
    @!APILevel[12, atomicservice : true]
    public mut prop constraintCommas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public func hasAttr(attr: String): Bool
    
    @!APILevel[12, atomicservice : true]
    public func getAttrs(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop isGenericDecl: Bool
    
    @!APILevel[12, atomicservice : true]
    public open func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public open func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ClassDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypes: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypeBitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop body: Body
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class StructDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypes: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypeBitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop body: Body
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class InterfaceDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypes: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypeBitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop body: Body
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class EnumDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypes: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypeBitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop constructors: ArrayList<Constructor>
    
    @!APILevel[12, atomicservice : true]
    public mut prop decls: ArrayList<Decl>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop ellipsis: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ExtendDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public override mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop extendType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypes: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop superTypeBitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop body: Body
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class FuncDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop overloadOp: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop funcParams: ArrayList<FuncParam>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop declType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func isConst(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MainDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop funcParams: ArrayList<FuncParam>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop declType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MacroDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop funcParams: ArrayList<FuncParam>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop declType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class PrimaryCtorDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop funcParams: ArrayList<FuncParam>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func isConst(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class VarDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop pattern: Pattern
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop declType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop assign: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func isConst(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public open class FuncParam <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop not: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop paramType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop assign: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func isMemberParam(): Bool
    
    @!APILevel[12, atomicservice : true]
    public open func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public open func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class PropDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop declType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop getter: FuncDecl
    
    @!APILevel[12, atomicservice : true]
    public mut prop setter: FuncDecl
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TypeAliasDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop assign: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop aliasType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MacroExpandDecl <: Decl {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop fullIdentifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroAttrs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroInputs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroInputDecl: Decl
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MacroExpandParam <: FuncParam {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop fullIdentifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroAttrs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroInputs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroInputDecl: Decl
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/**
* Level of diag report
*/
@!APILevel[12, atomicservice : true]
public enum DiagReportLevel {
    @!APILevel[12, atomicservice : true]
    ERROR |
    @!APILevel[12, atomicservice : true]
    WARNING
    @!APILevel[12, atomicservice : true]
    public func level(): Int32
}

@!APILevel[12, atomicservice : true]
public func diagReport(level: DiagReportLevel, tokens: Tokens, message: String, hint: String): Unit

@!APILevel[12, atomicservice : true]
public class ASTException <: Exception {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(message: String)
}

@!APILevel[12, atomicservice : true]
public class ParseASTException <: Exception {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(message: String)
}

@!APILevel[12, atomicservice : true]
public open class Expr <: Node {
    @!APILevel[12, atomicservice : true]
    public open func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public open func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class Block <: Expr {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop nodes: ArrayList<Node>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class BinaryExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop leftExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop op: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop rightExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class UnaryExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop op: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class IsExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop shiftType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class AsExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop shiftType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ParenExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop parenthesizedExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class LitConstExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop literal: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class RefExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArguments: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ReturnExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ThrowExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class AssignExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop assign: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop leftExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rightExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class CallExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop callFunc: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop arguments: ArrayList<Argument>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MemberAccess <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop baseExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop dot: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop field: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArguments: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class IfExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordI: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop condition: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop ifBlock: Block
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordE: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop elseExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class LetPatternExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop pattern: Pattern
    
    @!APILevel[12, atomicservice : true]
    public mut prop backArrow: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MatchExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop selector: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop matchCases: ArrayList<MatchCase>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class WhileExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop condition: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class DoWhileExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordD: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordW: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop condition: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class LambdaExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop funcParams: ArrayList<FuncParam>
    
    @!APILevel[12, atomicservice : true]
    public mut prop doubleArrow: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop nodes: ArrayList<Node>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class SpawnExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop threadContext: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lambdaExpr: LambdaExpr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class SynchronizedExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop structuredMutex: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TrailingClosureExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop lambdaExpr: LambdaExpr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TypeConvExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop targetType: PrimitiveType
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ForInExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordF: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop pattern: Pattern
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordI: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordW: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop patternGuard: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class PrimitiveTypeExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(kind: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ArrayLiteral <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop elements: ArrayList<Expr>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TupleLiteral <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop elements: ArrayList<Expr>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class RangeExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop start: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop op: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop end: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop step: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class SubscriptExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop baseExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop lSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop indexList: ArrayList<Expr>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class JumpExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(kind: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class IncOrDecExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop op: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TryExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordT: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop resourceSpec: ArrayList<VarDecl>
    
    @!APILevel[12, atomicservice : true]
    public mut prop tryBlock: Block
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordsC: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop catchPatterns: ArrayList<Pattern>
    
    @!APILevel[12, atomicservice : true]
    public mut prop catchBlocks: ArrayList<Block>
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordF: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop finallyBlock: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class OptionalExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init()
    
    // we construct a MemberAccess to help parse OptionalExpr because compiler can't parse OptionalExpr directly.
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop baseExpr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop quest: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class QuoteToken <: Expr {
    @!APILevel[12, atomicservice : true]
    public mut prop tokens: Tokens
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class QuoteExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop exprs: ArrayList<Expr>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class WildcardExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(keyword: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class VArrayExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop vArrayType: VArrayType
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop arguments: ArrayList<Argument>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class MacroExpandExpr <: Expr {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop at: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroAttrs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rSquare: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop macroInputs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/**
* @return cangjie tokens.
* @throws IllegalMemoryException if failed to call cangjieLex(code, true).
* @throws IllegalArgumentException if failed to call cangjieLex(code, true).
*/
@!APILevel[12, atomicservice : true]
public func cangjieLex(code: String): Tokens

/**
* XXX: need further consideration.
* @return cangjie tokens.
* @throws IllegalMemoryException if malloc failed.
* @throws IllegalArgumentException if the call of CJ_AST_Lex returns an invalid token array.
*/
@!APILevel[12, atomicservice : true]
public func cangjieLex(code: String, truncated: Bool): Tokens

/**
* This part is the Macro with context related API:
*/
@!APILevel[12, atomicservice : true]
public class MacroContextException <: Exception {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(message: String)
}

/**
* For situations an inner macro call finds itself nested inside a particular outer macro call.
*
* @param parentMacroName - a particular outer macro call name.
*
* @return Unit.
*
* Throw an error unless the inner macro call is nested in the given outer macro call.
*/
@!APILevel[12, atomicservice : true]
public func assertParentContext(parentMacroName: String): Unit

/**
* For situations an inner macro call finds itself nested inside a particular outer macro call.
*
* @param parentMacroName - a particular outer macro call name.
*
* @return Bool. Returns true only if the inner macro call is nested in the given outer macro call.
*/
@!APILevel[12, atomicservice : true]
public func insideParentContext(parentMacroName: String): Bool

/**
* For situations an inner macro can sending key/value pairs to the outer macro by setItem.
*
* @param key - the key send to outer macro for index.
*
* @param value - the value that send to outer macro.
*/
@!APILevel[12, atomicservice : true]
public func setItem(key: String, value: String): Unit

@!APILevel[12, atomicservice : true]
public func setItem(key: String, value: Int64): Unit

@!APILevel[12, atomicservice : true]
public func setItem(key: String, value: Bool): Unit

@!APILevel[12, atomicservice : true]
public func setItem(key: String, value: Tokens): Unit

@!APILevel[12, atomicservice : true]
public class MacroMessage {
    /*
    * Check the given 'key' wheather have an item
    */
    @!APILevel[12, atomicservice : true]
    public func hasItem(key: String): Bool
    
    /**
    * Get info of key, and return a string value
    * @param key - the key send to outer macro for index.
    * @return String - return a string value.
    * throw an exception if there is no such key/value pairs.
    */
    @!APILevel[12, atomicservice : true]
    public func getString(key: String): String
    
    /**
    * Get info of key, and return the Int64 value
    * @param key - the key send to outer macro for index.
    * @return Int64 - return the Int64 value.
    * throw an exception if there is no such key/value pairs.
    */
    @!APILevel[12, atomicservice : true]
    public func getInt64(key: String): Int64
    
    /**
    * Get info of key, and return the Bool value
    * @param key - the key send to outer macro for index.
    * @return Bool - return the Bool value.
    * throw an exception if there is no such key/value pairs.
    */
    @!APILevel[12, atomicservice : true]
    public func getBool(key: String): Bool
    
    /**
    * Get info of key, and return the Tokens value
    * @param key - the key send to outer macro for index.
    * @return Tokens - return the Tokens value.
    * throw an exception if there is no such key/value pairs.
    */
    @!APILevel[12, atomicservice : true]
    public func getTokens(key: String): Tokens
}

/**
* Getting one message (a map of key/value pairs) for each inner macro invocation that sent messages.
* @param innerMacroName - the inner macro name that has send to the current outer macro.
* @return String - return the arraylist of hashmap info.
* If there are no such messages, this is not an error, it's just an empty list.
*/
@!APILevel[12, atomicservice : true]
public func getChildMessages(children: String): ArrayList<MacroMessage>

@!APILevel[12, atomicservice : true]
public open class FlatBufferObject {
    @!APILevel[12, atomicservice : true]
    public init(buf: Array<UInt8>, root: UInt32)
}

@!APILevel[12, atomicservice : true]
abstract sealed class Node <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public mut prop beginPos: Position
    
    @!APILevel[12, atomicservice : true]
    public mut prop endPos: Position
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
    
    @!APILevel[12, atomicservice : true]
    public func dump(): Unit
}

@!APILevel[12, atomicservice : true]
public class Annotation <: Node {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop at: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop arguments: ArrayList<Argument>
    
    @!APILevel[12, atomicservice : true]
    public mut prop attributes: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop condition: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class Modifier <: Node {
    @!APILevel[12, atomicservice : true]
    public init(keyword: Token)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class GenericParam <: Node {
    @!APILevel[12, atomicservice : true]
    public init(parameters: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop parameters: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/*
* GenericConstraint is:
*   where T <: A, K <: B
*/
@!APILevel[12, atomicservice : true]
public class GenericConstraint <: Node {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArgument: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBound: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop upperBounds: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop bitAnds: Tokens
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/*
* Body is:
*   {...}
* For mutable types, like ClassDecl, StructDecl, InterfaceDecl
*/
@!APILevel[12, atomicservice : true]
public class Body <: Node {
    @!APILevel[12, atomicservice : true]
    public init(decls: ArrayList<Decl>)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop decls: ArrayList<Decl>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/*
* Argument is actual parameter Node:
*   foo(arg1:value1)
*   "arg1:value1" is an Argument type
*/
@!APILevel[12, atomicservice : true]
public class Argument <: Node {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/*
* MatchCase is the children node of Match Expression:
*   var scoreResult: String = match (score) {
*       case 0 => "zero" // This is a MatchCase Node
*       case 10 | 20 | 30 | 40 | 50 => "fail" // This is a MatchCase Node
*       case _ => "not a valid score"
*   }
*/
@!APILevel[12, atomicservice : true]
public class MatchCase <: Node {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordC: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop expr: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop patterns: ArrayList<Pattern>
    
    @!APILevel[12, atomicservice : true]
    public mut prop bitOrs: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordW: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop patternGuard: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop arrow: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop block: Block
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/**
* Program is the Cangjie source File node.
*/
@!APILevel[12, atomicservice : true]
public class Program <: Node {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop packageHeader: PackageHeader
    
    @!APILevel[12, atomicservice : true]
    public mut prop importLists: ArrayList<ImportList>
    
    @!APILevel[12, atomicservice : true]
    public mut prop decls: ArrayList<Decl>
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/**
* PackageHeader node represents the package of the current file.
* The PackageHeader starts with the keyword package, followed by the package name.
*/
@!APILevel[12, atomicservice : true]
public class PackageHeader <: Node {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop accessible: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordM: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordP: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop prefixPaths: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop prefixDots: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop packageIdentifier: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public enum ImportKind <: ToString {
    @!APILevel[12, atomicservice : true]
    Single |
    @!APILevel[12, atomicservice : true]
    Alias |
    @!APILevel[12, atomicservice : true]
    All |
    @!APILevel[12, atomicservice : true]
    Multi
    @!APILevel[12, atomicservice : true]
    public func toString(): String
}

@!APILevel[12, atomicservice : true]
public class ImportContent <: Node {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop importKind: ImportKind
    
    @!APILevel[12, atomicservice : true]
    public mut prop prefixPaths: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop prefixDots: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop importAlias: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop lBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop items: ArrayList<ImportContent>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rBrace: Token
    
    @!APILevel[12, atomicservice : true]
    public func isImportAlias(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func isImportAll(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func isImportMulti(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func isImportSingle(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ImportList <: Node {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop modifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop keywordI: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop content: ImportContent
    
    @!APILevel[12, atomicservice : true]
    public func isImportMulti(): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

/**
* Constructor node represents the values related to enum.
* enum TimeUnit1 {
*   Year | Month | Day | Hour(Float32) // Constructor node
* }
*/
@!APILevel[12, atomicservice : true]
public class Constructor <: Node {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArguments: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

extend<T> ArrayList<T> <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend<T> Array<T> <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

@!APILevel[12, atomicservice : true]
public func parseDecl(input: Tokens, astKind!: String = ""): Decl

@!APILevel[12, atomicservice : true]
public func parseDeclFragment(input: Tokens, startFrom!: Int64 = 0): (Decl, Int64)

@!APILevel[12, atomicservice : true]
public func parseExpr(input: Tokens): Expr

@!APILevel[12, atomicservice : true]
public func parseExprFragment(input: Tokens, startFrom!: Int64 = 0): (Expr, Int64)

@!APILevel[12, atomicservice : true]
public func parseProgram(input: Tokens): Program

@!APILevel[12, atomicservice : true]
public func parsePattern(input: Tokens)

@!APILevel[12, atomicservice : true]
public func parsePatternFragment(input: Tokens, startFrom!: Int64 = 0): (Pattern, Int64)

@!APILevel[12, atomicservice : true]
public func parseType(input: Tokens)

@!APILevel[12, atomicservice : true]
public func parseTypeFragment(input: Tokens, startFrom!: Int64 = 0): (TypeNode, Int64)

@!APILevel[12, atomicservice : true]
public open class Pattern <: Node {
    @!APILevel[12, atomicservice : true]
    public open func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public open func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ConstPattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop litConstExpr: LitConstExpr
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class WildcardPattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init(keyword: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop wildcard: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class VarPattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init(identifier: Token)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class VarOrEnumPattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init(identifier: Token)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ExceptTypePattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop pattern: Pattern
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop types: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TypePattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop pattern: Pattern
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop patternType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class EnumPattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop constructor: Expr
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop patterns: ArrayList<Pattern>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TuplePattern <: Pattern {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop patterns: ArrayList<Pattern>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public struct Position <: ToBytes {
    /* Fields */
    @!APILevel[12, atomicservice : true]
    public let fileID: UInt32
    
    @!APILevel[12, atomicservice : true]
    public let line: Int32
    
    @!APILevel[12, atomicservice : true]
    public let column: Int32
    
    /* Constructors *//** Create an empty position. */
    @!APILevel[12, atomicservice : true]
    public init()
    
    /** Create a new position which is formed by fileID, line, column. */
    @!APILevel[12, atomicservice : true]
    public init(fileID: UInt32, line: Int32, column: Int32)
    
    /* Methods *//** Returns true if and only if this position line and column equal to 0. */
    @!APILevel[12, atomicservice : true]
    public func isEmpty(): Bool
    
    /** Returns true if and only if the two positions are identical. */
    @!APILevel[12, atomicservice : true]
    public operator func ==(r: Position): Bool
    
    /** Returns true if and only if the two positions are not identical. */
    @!APILevel[12, atomicservice : true]
    public operator func !=(r: Position): Bool
    
    /** Print the information of this position. */
    @!APILevel[12, atomicservice : true]
    public func dump(): Unit
    
    @!APILevel[12, atomicservice : true]
    public func toBytes(): Array<UInt8>
}

@!APILevel[12, atomicservice : true]
public interface ToBytes {
}

@!APILevel[12, atomicservice : true]
public struct Token <: ToBytes {
    /**
    Fields
    */
    @!APILevel[12, atomicservice : true]
    public let kind: TokenKind
    
    @!APILevel[12, atomicservice : true]
    public let value: String
    
    @!APILevel[12, atomicservice : true]
    public let pos: Position
    
    @!APILevel[12, atomicservice : true]
    public var delimiterNum: UInt16 = 1
    
    /**
    Constructors
    */// Create an token with default value.
    @!APILevel[12, atomicservice : true]
    public init()
    
    // Create a new token without value, position from enumerated type token.
    @!APILevel[12, atomicservice : true]
    public init(kind: TokenKind)
    
    // Create a new token with empty position from token kind and token value.
    @!APILevel[12, atomicservice : true]
    public init(kind: TokenKind, value: String)
    
    @!APILevel[12, atomicservice : true]
    public func addPosition(fileID: UInt32, line: Int32, colum: Int32): Token
    
    // Returns true if and only if the two token's kind id, value, position are identical.// XXX: Bound check.
    @!APILevel[12, atomicservice : true]
    public operator func ==(r: Token): Bool
    
    // Returns true if and only if the two token's kind id, value, position are not identical.
    @!APILevel[12, atomicservice : true]
    public operator func !=(r: Token): Bool
    
    // Token + Tokens => Tokens
    @!APILevel[12, atomicservice : true]
    public operator func +(r: Tokens): Tokens
    
    // Token + Token => Tokens
    @!APILevel[12, atomicservice : true]
    public operator func +(r: Token): Tokens
    
    // Print the information of this token.
    @!APILevel[12, atomicservice : true]
    public func dump(): Unit
    
    @!APILevel[12, atomicservice : true]
    public func toBytes(): Array<UInt8>
}

/**
* Note: If Tokens.inc is changed, TokenKind and PATTERNS should change accordingly.
*/
@!APILevel[12, atomicservice : true]
public enum TokenKind <: ToString {
    @!APILevel[12, atomicservice : true]
    DOT |
    @!APILevel[12, atomicservice : true]
    /*  "."           */
    COMMA |
    @!APILevel[12, atomicservice : true]
    /*  ","           */
    LPAREN |
    @!APILevel[12, atomicservice : true]
    /*  "("           */
    RPAREN |
    @!APILevel[12, atomicservice : true]
    /*  ")"           */
    LSQUARE |
    @!APILevel[12, atomicservice : true]
    /*  "["           */
    RSQUARE |
    @!APILevel[12, atomicservice : true]
    /*  "]"           */
    LCURL |
    @!APILevel[12, atomicservice : true]
    /*  "{"           */
    RCURL |
    @!APILevel[12, atomicservice : true]
    /*  "}"           */
    EXP |
    @!APILevel[12, atomicservice : true]
    /*  "**"          */
    MUL |
    @!APILevel[12, atomicservice : true]
    /*  "*"           */
    MOD |
    @!APILevel[12, atomicservice : true]
    /*  "%"           */
    DIV |
    @!APILevel[12, atomicservice : true]
    /*  "/"           */
    ADD |
    @!APILevel[12, atomicservice : true]
    /*  "+"           */
    SUB |
    @!APILevel[12, atomicservice : true]
    /*  "-"           */
    INCR |
    @!APILevel[12, atomicservice : true]
    /*  "++"          */
    DECR |
    @!APILevel[12, atomicservice : true]
    /*  "--"          */
    AND |
    @!APILevel[12, atomicservice : true]
    /*  "&&"          */
    OR |
    @!APILevel[12, atomicservice : true]
    /*  "||"          */
    COALESCING |
    @!APILevel[12, atomicservice : true]
    /*  "??"          */
    PIPELINE |
    @!APILevel[12, atomicservice : true]
    /*  "|>"          */
    COMPOSITION |
    @!APILevel[12, atomicservice : true]
    /*  "~>"          */
    NOT |
    @!APILevel[12, atomicservice : true]
    /*  "!"           */
    BITAND |
    @!APILevel[12, atomicservice : true]
    /*  "&"           */
    BITOR |
    @!APILevel[12, atomicservice : true]
    /*  "|"           */
    BITXOR |
    @!APILevel[12, atomicservice : true]
    /*  "^"           */
    BITNOT |
    @!APILevel[12, atomicservice : true]
    /*  "~"           */
    LSHIFT |
    @!APILevel[12, atomicservice : true]
    /*  "<<"          */
    RSHIFT |
    @!APILevel[12, atomicservice : true]
    /*  ">>"          */
    COLON |
    @!APILevel[12, atomicservice : true]
    /*  ":"           */
    SEMI |
    @!APILevel[12, atomicservice : true]
    /*  ";"           */
    ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "="           */
    ADD_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "+="          */
    SUB_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "-="          */
    MUL_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "*="          */
    EXP_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "**="         */
    DIV_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "/="          */
    MOD_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "%="          */
    AND_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "&&="         */
    OR_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "||="         */
    BITAND_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "&="          */
    BITOR_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "|="          */
    BITXOR_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "^="          */
    LSHIFT_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  "<<="         */
    RSHIFT_ASSIGN |
    @!APILevel[12, atomicservice : true]
    /*  ">>="         */
    ARROW |
    @!APILevel[12, atomicservice : true]
    /*  "->"          */
    BACKARROW |
    @!APILevel[12, atomicservice : true]
    /*  "<-"          */
    DOUBLE_ARROW |
    @!APILevel[12, atomicservice : true]
    /*  "=>"          */
    RANGEOP |
    @!APILevel[12, atomicservice : true]
    /*  ".."          */
    CLOSEDRANGEOP |
    @!APILevel[12, atomicservice : true]
    /*  "..="         */
    ELLIPSIS |
    @!APILevel[12, atomicservice : true]
    /*  "..."         */
    HASH |
    @!APILevel[12, atomicservice : true]
    /*  "#"           */
    AT |
    @!APILevel[12, atomicservice : true]
    /*  "@"           */
    QUEST |
    @!APILevel[12, atomicservice : true]
    /*  "?"           */
    LT |
    @!APILevel[12, atomicservice : true]
    /*  "<"           */
    GT |
    @!APILevel[12, atomicservice : true]
    /*  ">"           */
    LE |
    @!APILevel[12, atomicservice : true]
    /*  "<="          */
    GE |
    @!APILevel[12, atomicservice : true]
    /*  ">="          */
    IS |
    @!APILevel[12, atomicservice : true]
    /*  "is"          */
    AS |
    @!APILevel[12, atomicservice : true]
    /*  "as"          */
    NOTEQ |
    @!APILevel[12, atomicservice : true]
    /*  "!="          */
    EQUAL |
    @!APILevel[12, atomicservice : true]
    /*  "=="          */
    WILDCARD |
    @!APILevel[12, atomicservice : true]
    /*  "_"           */
    INT8 |
    @!APILevel[12, atomicservice : true]
    /*  "Int8"        */
    INT16 |
    @!APILevel[12, atomicservice : true]
    /*  "Int16"       */
    INT32 |
    @!APILevel[12, atomicservice : true]
    /*  "Int32"       */
    INT64 |
    @!APILevel[12, atomicservice : true]
    /*  "Int64"       */
    INTNATIVE |
    @!APILevel[12, atomicservice : true]
    /*  "IntNative"   */
    UINT8 |
    @!APILevel[12, atomicservice : true]
    /*  "UInt8"       */
    UINT16 |
    @!APILevel[12, atomicservice : true]
    /*  "UInt16"      */
    UINT32 |
    @!APILevel[12, atomicservice : true]
    /*  "UInt32"      */
    UINT64 |
    @!APILevel[12, atomicservice : true]
    /*  "UInt64"      */
    UINTNATIVE |
    @!APILevel[12, atomicservice : true]
    /*  "UIntNative"  */
    FLOAT16 |
    @!APILevel[12, atomicservice : true]
    /*  "Float16"     */
    FLOAT32 |
    @!APILevel[12, atomicservice : true]
    /*  "Float32"     */
    FLOAT64 |
    @!APILevel[12, atomicservice : true]
    /*  "Float64"     */
    RUNE |
    @!APILevel[12, atomicservice : true]
    /*  "Rune"        */
    BOOLEAN |
    @!APILevel[12, atomicservice : true]
    /*  "Bool"        */
    NOTHING |
    @!APILevel[12, atomicservice : true]
    /*  "Nothing"     */
    UNIT |
    @!APILevel[12, atomicservice : true]
    /*  "Unit"        */
    STRUCT |
    @!APILevel[12, atomicservice : true]
    /*  "struct"      */
    ENUM |
    @!APILevel[12, atomicservice : true]
    /*  "enum"        */
    VARRAY |
    @!APILevel[12, atomicservice : true]
    /*  "VArray"      */
    THISTYPE |
    @!APILevel[12, atomicservice : true]
    /*  "This"        */
    PACKAGE |
    @!APILevel[12, atomicservice : true]
    /*  "package"     */
    IMPORT |
    @!APILevel[12, atomicservice : true]
    /*  "import"      */
    CLASS |
    @!APILevel[12, atomicservice : true]
    /*  "class"       */
    INTERFACE |
    @!APILevel[12, atomicservice : true]
    /*  "interface"   */
    FUNC |
    @!APILevel[12, atomicservice : true]
    /*  "func"        */
    MACRO |
    @!APILevel[12, atomicservice : true]
    /*  "macro"       */
    QUOTE |
    @!APILevel[12, atomicservice : true]
    /*  "quote"       */
    DOLLAR |
    @!APILevel[12, atomicservice : true]
    /*  "$"           */
    LET |
    @!APILevel[12, atomicservice : true]
    /*  "let"         */
    VAR |
    @!APILevel[12, atomicservice : true]
    /*  "var"         */
    CONST |
    @!APILevel[12, atomicservice : true]
    /*  "const"       */
    TYPE |
    @!APILevel[12, atomicservice : true]
    /*  "type"        */
    INIT |
    @!APILevel[12, atomicservice : true]
    /*  "init"        */
    THIS |
    @!APILevel[12, atomicservice : true]
    /*  "this"        */
    SUPER |
    @!APILevel[12, atomicservice : true]
    /*  "super"       */
    IF |
    @!APILevel[12, atomicservice : true]
    /*  "if"          */
    ELSE |
    @!APILevel[12, atomicservice : true]
    /*  "else"        */
    CASE |
    @!APILevel[12, atomicservice : true]
    /*  "case"        */
    TRY |
    @!APILevel[12, atomicservice : true]
    /*  "try"         */
    CATCH |
    @!APILevel[12, atomicservice : true]
    /*  "catch"       */
    FINALLY |
    @!APILevel[12, atomicservice : true]
    /*  "finally"     */
    FOR |
    @!APILevel[12, atomicservice : true]
    /*  "for"         */
    DO |
    @!APILevel[12, atomicservice : true]
    /*  "do"          */
    WHILE |
    @!APILevel[12, atomicservice : true]
    /*  "while"       */
    THROW |
    @!APILevel[12, atomicservice : true]
    /*  "throw"       */
    RETURN |
    @!APILevel[12, atomicservice : true]
    /*  "return"      */
    CONTINUE |
    @!APILevel[12, atomicservice : true]
    /*  "continue"    */
    BREAK |
    @!APILevel[12, atomicservice : true]
    /*  "break"       */
    IN |
    @!APILevel[12, atomicservice : true]
    /*  "in"          */
    NOT_IN |
    @!APILevel[12, atomicservice : true]
    /*  "!in"         */
    MATCH |
    @!APILevel[12, atomicservice : true]
    /*  "match"       */
    WHERE |
    @!APILevel[12, atomicservice : true]
    /*  "where"       */
    EXTEND |
    @!APILevel[12, atomicservice : true]
    /*  "extend"      */
    WITH |
    @!APILevel[12, atomicservice : true]
    /*  "with"        */
    PROP |
    @!APILevel[12, atomicservice : true]
    /*  "prop"        */
    STATIC |
    @!APILevel[12, atomicservice : true]
    /*  "static"      */
    PUBLIC |
    @!APILevel[12, atomicservice : true]
    /*  "public"      */
    PRIVATE |
    @!APILevel[12, atomicservice : true]
    /*  "private"     */
    INTERNAL |
    @!APILevel[12, atomicservice : true]
    /*  "internal"     */
    PROTECTED |
    @!APILevel[12, atomicservice : true]
    /*  "protected"   */
    OVERRIDE |
    @!APILevel[12, atomicservice : true]
    /*  "override"    */
    REDEF |
    @!APILevel[12, atomicservice : true]
    /*  "redef"       */
    ABSTRACT |
    @!APILevel[12, atomicservice : true]
    /*  "abstract"    */
    SEALED |
    @!APILevel[12, atomicservice : true]
    /*  "sealed"      */
    OPEN |
    @!APILevel[12, atomicservice : true]
    /*  "open"        */
    FOREIGN |
    @!APILevel[12, atomicservice : true]
    /*  "foreign"     */
    INOUT |
    @!APILevel[12, atomicservice : true]
    /*  "inout"       */
    MUT |
    @!APILevel[12, atomicservice : true]
    /*  "mut"         */
    UNSAFE |
    @!APILevel[12, atomicservice : true]
    /*  "unsafe"      */
    OPERATOR |
    @!APILevel[12, atomicservice : true]
    /*  "operator"    */
    SPAWN |
    @!APILevel[12, atomicservice : true]
    /*  "spawn"       */
    SYNCHRONIZED |
    @!APILevel[12, atomicservice : true]
    /*  "synchronized */
    UPPERBOUND |
    @!APILevel[12, atomicservice : true]
    /*  "<:"          */
    MAIN |
    @!APILevel[12, atomicservice : true]
    /*  "main"        */
    IDENTIFIER |
    @!APILevel[12, atomicservice : true]
    /*  "x"           */
    PACKAGE_IDENTIFIER |
    @!APILevel[12, atomicservice : true]
    /*  "x-y"         */
    INTEGER_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "1"      */
    RUNE_BYTE_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "b'x'"   */
    FLOAT_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "'1.0'"  */
    COMMENT |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "/*xx*/" */
    NL |
    @!APILevel[12, atomicservice : true]
    /*  newline         */
    END |
    @!APILevel[12, atomicservice : true]
    /*  end of file     */
    SENTINEL |
    @!APILevel[12, atomicservice : true]
    /*  ";"             */
    RUNE_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "r'x'"      */
    STRING_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. ""xx""     */
    SINGLE_QUOTED_STRING_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "'xx'"     */
    JSTRING_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "J"xx""     */
    MULTILINE_STRING |
    @!APILevel[12, atomicservice : true]
    /*  e.g. """"aaa""""   */
    MULTILINE_RAW_STRING |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "#"aaa"#"     */
    BOOL_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  "true" or "false"  */
    UNIT_LITERAL |
    @!APILevel[12, atomicservice : true]
    /*  "()"               */
    DOLLAR_IDENTIFIER |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "$x"          */
    ANNOTATION |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "@When"       */
    AT_EXCL |
    @!APILevel[12, atomicservice : true]
    /*  e.g. "@!"          */
    ILLEGAL
    @!APILevel[12, atomicservice : true]
    public operator func ==(right: TokenKind): Bool
    
    @!APILevel[12, atomicservice : true]
    public operator func !=(right: TokenKind): Bool
    
    @!APILevel[12, atomicservice : true]
    public func toString(): String
}

/**
* Conversion function for UInt16 to Enum
*/
@!APILevel[12, atomicservice : true]
public func getTokenKind(no: UInt16): TokenKind

@!APILevel[12, atomicservice : true]
public class TokensIterator <: Iterator<Token> {
    /* Constructors */
    @!APILevel[12, atomicservice : true]
    public init(tokens: Tokens)
    
    /* Methods *//** Returns the current Option<Token>. */
    @!APILevel[12, atomicservice : true]
    public func peek(): Option<Token>
    
    /** Returns true if current token is the kind, otherwise false. */
    @!APILevel[12, atomicservice : true]
    public func seeing(kind: TokenKind): Bool
    
    /** Returns next Option<Token>. */
    @!APILevel[12, atomicservice : true]
    public func next(): Option<Token>
}

@!APILevel[12, atomicservice : true]
public open class Tokens <: ToString & Iterable<Token> & ToBytes {
    /* Constructors *//** Create an empty tokens. */
    @!APILevel[12, atomicservice : true]
    public init()
    
    /** Create a new tokens from token array. */
    @!APILevel[12, atomicservice : true]
    public init(tokArray: Array<Token>)
    
    /** Create a new tokens from token array. */
    @!APILevel[12, atomicservice : true]
    public init(tokArrayList: ArrayList<Token>)
    
    /* Methods *//** Returns the size of tokens. */
    @!APILevel[12, atomicservice : true]
    public open prop size: Int64
    
    /** Returns the token from the index, if the index is out of bound or its element is null then throws IndexOutOfBoundsException. */
    @!APILevel[12, atomicservice : true]
    public open func get(index: Int64): Token
    
    /** Returns an iterator over the tokens. */
    @!APILevel[12, atomicservice : true]
    public func iterator(): TokensIterator
    
    /** Returns the concatenation of this Tokens and the argument. */
    @!APILevel[12, atomicservice : true]
    public func concat(tokens: Tokens): Tokens
    
    /* Operator functions *//** Returns the token at the specified index. */
    @!APILevel[12, atomicservice : true]
    public operator func [](index: Int64): Token
    
    @!APILevel[12, atomicservice : true]
    public open operator func [](range: Range<Int64>): Tokens
    
    /** Returns a tokens which is the result of concatenating `ts1` and `ts2`. */
    @!APILevel[12, atomicservice : true]
    public operator func +(r: Tokens): Tokens
    
    /** Returns a tokens which is the result of concatenating `ts1` and `t2`. */
    @!APILevel[12, atomicservice : true]
    public operator func +(r: Token): Tokens
    
    /** Returns current tokens which is the result of concatenating this and `tks`. */
    @!APILevel[12, atomicservice : true]
    public open func append(tokens: Tokens): Tokens
    
    /** Returns current tokens which is the result of concatenating this and `tk`. */
    @!APILevel[12, atomicservice : true]
    public open func append(token: Token): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func append(node: Node): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func remove(index: Int64): Tokens
    
    /** Print the information of this tokens. */
    @!APILevel[12, atomicservice : true]
    public func dump(): Unit
    
    /** Convert Tokens to String. */
    @!APILevel[12, atomicservice : true]
    public func toString(): String
    
    @!APILevel[12, atomicservice : true]
    public func toBytes(): Array<UInt8>
}

@!APILevel[12, atomicservice : true]
public interface ToTokens {
}

/**
Basical ToTokens method. List of supporting type in the following.
+ Token, Tokens
+ Int64, Int32, Int16, Int8
+ UInt64, UInt32, UInt16, UInt8
+ Float64, Float32, Float16
+ Bool, Rune, String
*/
extend Token <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Tokens <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Int64 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Int32 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Int16 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Int8 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend UInt64 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend UInt32 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend UInt16 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend UInt8 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Float64 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Float32 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Float16 <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Bool <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend Rune <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

extend String <: ToTokens {
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
}

@!APILevel[12, atomicservice : true]
public open class TypeNode <: Node {
    @!APILevel[12, atomicservice : true]
    public mut prop typeParameterName: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop colon: Token
    
    @!APILevel[12, atomicservice : true]
    public open func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public open func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class PrimitiveType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class RefType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArguments: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class QualifiedType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop baseType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop dot: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop identifier: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop typeArguments: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ParenType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop parenthesizedType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class TupleType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop types: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class ThisType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class PrefixType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop prefixOps: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop baseType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class FuncType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop types: ArrayList<TypeNode>
    
    @!APILevel[12, atomicservice : true]
    public mut prop commas: Tokens
    
    @!APILevel[12, atomicservice : true]
    public mut prop rParen: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop arrow: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop returnType: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public class VArrayType <: TypeNode {
    @!APILevel[12, atomicservice : true]
    public init(inputs: Tokens)
    
    @!APILevel[12, atomicservice : true]
    public init()
    
    @!APILevel[12, atomicservice : true]
    public mut prop keyword: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop lAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop elementTy: TypeNode
    
    @!APILevel[12, atomicservice : true]
    public mut prop dollar: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop size: Token
    
    @!APILevel[12, atomicservice : true]
    public mut prop rAngle: Token
    
    @!APILevel[12, atomicservice : true]
    public func toTokens(): Tokens
    
    @!APILevel[12, atomicservice : true]
    public func traverse(v: Visitor): Unit
}

@!APILevel[12, atomicservice : true]
public abstract class Visitor {
    @!APILevel[12, atomicservice : true]
    public func breakTraverse(): Unit
}

